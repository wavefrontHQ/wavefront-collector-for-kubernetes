
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>test-proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/test-proxy/diff.go (0.0%)</option>
				
				<option value="file1">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/test-proxy/main.go (2.8%)</option>
				
				<option value="file2">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/test-proxy/metric.go (87.5%)</option>
				
				<option value="file3">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/test-proxy/metric_grammar.peg.go (50.1%)</option>
				
				<option value="file4">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/test-proxy/metric_store.go (0.0%)</option>
				
				<option value="file5">github.com/wavefronthq/wavefront-collector-for-kubernetes/cmd/wavefront-collector/main.go (71.8%)</option>
				
				<option value="file6">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/agent/agent.go (31.6%)</option>
				
				<option value="file7">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration/listener.go (20.0%)</option>
				
				<option value="file8">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration/parser.go (75.0%)</option>
				
				<option value="file9">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration/util.go (50.0%)</option>
				
				<option value="file10">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/endpoint.go (41.7%)</option>
				
				<option value="file11">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/fake.go (0.0%)</option>
				
				<option value="file12">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/helper.go (18.8%)</option>
				
				<option value="file13">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/listener.go (0.0%)</option>
				
				<option value="file14">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/parser.go (25.0%)</option>
				
				<option value="file15">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/types.go (80.0%)</option>
				
				<option value="file16">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/utils/encoding.go (100.0%)</option>
				
				<option value="file17">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/experimental/feature.go (100.0%)</option>
				
				<option value="file18">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter/config.go (100.0%)</option>
				
				<option value="file19">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter/glob.go (97.9%)</option>
				
				<option value="file20">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter/util.go (93.5%)</option>
				
				<option value="file21">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/flags/flags.go (96.6%)</option>
				
				<option value="file22">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/flags/utils.go (50.0%)</option>
				
				<option value="file23">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil/client.go (57.4%)</option>
				
				<option value="file24">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil/parser.go (75.0%)</option>
				
				<option value="file25">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/kubernetes/configs.go (65.2%)</option>
				
				<option value="file26">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/kubernetes/terminate.go (0.0%)</option>
				
				<option value="file27">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership/election.go (76.7%)</option>
				
				<option value="file28">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership/manager.go (61.1%)</option>
				
				<option value="file29">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/batch.go (100.0%)</option>
				
				<option value="file30">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/error_decorator.go (83.3%)</option>
				
				<option value="file31">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/historical_types.go (0.0%)</option>
				
				<option value="file32">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/labels.go (0.0%)</option>
				
				<option value="file33">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file34">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/resource_key.go (100.0%)</option>
				
				<option value="file35">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/set.go (92.3%)</option>
				
				<option value="file36">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics/types.go (19.4%)</option>
				
				<option value="file37">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/options/adapter.go (68.7%)</option>
				
				<option value="file38">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/options/agent_type.go (65.0%)</option>
				
				<option value="file39">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/options/options.go (95.7%)</option>
				
				<option value="file40">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/dummies.go (92.5%)</option>
				
				<option value="file41">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/label_copier.go (100.0%)</option>
				
				<option value="file42">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/string_interner.go (100.0%)</option>
				
				<option value="file43">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/util.go (88.8%)</option>
				
				<option value="file44">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/wait.go (85.7%)</option>
				
				<option value="file45">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util/watcher.go (71.4%)</option>
				
				<option value="file46">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf/distribution.go (89.2%)</option>
				
				<option value="file47">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf/filter.go (100.0%)</option>
				
				<option value="file48">github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf/point.go (69.4%)</option>
				
				<option value="file49">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/auth_checker.go (91.7%)</option>
				
				<option value="file50">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/config.go (79.6%)</option>
				
				<option value="file51">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/discoverer.go (52.7%)</option>
				
				<option value="file52">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/endpoint_creator.go (92.9%)</option>
				
				<option value="file53">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/filter.go (82.4%)</option>
				
				<option value="file54">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/lister.go (10.0%)</option>
				
				<option value="file55">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/manager.go (65.4%)</option>
				
				<option value="file56">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/pod.go (80.8%)</option>
				
				<option value="file57">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/prometheus/encoder.go (88.4%)</option>
				
				<option value="file58">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/prometheus/handler.go (100.0%)</option>
				
				<option value="file59">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/service.go (66.7%)</option>
				
				<option value="file60">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/telegraf/handler.go (87.5%)</option>
				
				<option value="file61">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/events/eventrouter.go (0.0%)</option>
				
				<option value="file62">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/events/filter.go (100.0%)</option>
				
				<option value="file63">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/manager/manager.go (92.9%)</option>
				
				<option value="file64">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/cluster_aggregator.go (100.0%)</option>
				
				<option value="file65">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/cumulative_distribution_converter.go (90.9%)</option>
				
				<option value="file66">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/distribution_rate_calculator.go (96.3%)</option>
				
				<option value="file67">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/helper.go (84.0%)</option>
				
				<option value="file68">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/namespace_aggregator.go (81.8%)</option>
				
				<option value="file69">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/namespace_based_enricher.go (65.2%)</option>
				
				<option value="file70">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/node_aggregator.go (71.4%)</option>
				
				<option value="file71">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/node_autoscaling_enricher.go (95.3%)</option>
				
				<option value="file72">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/pod_aggregator.go (85.4%)</option>
				
				<option value="file73">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/pod_based_enricher.go (96.0%)</option>
				
				<option value="file74">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/rate_calculator.go (62.5%)</option>
				
				<option value="file75">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors/sum_count_aggregator.go (95.5%)</option>
				
				<option value="file76">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/factory.go (75.0%)</option>
				
				<option value="file77">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/manager.go (68.9%)</option>
				
				<option value="file78">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront/testsender.go (63.2%)</option>
				
				<option value="file79">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront/utils.go (84.0%)</option>
				
				<option value="file80">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront/wavefront.go (63.2%)</option>
				
				<option value="file81">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/cadvisor/generate_urls.go (100.0%)</option>
				
				<option value="file82">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/cadvisor/provider.go (70.4%)</option>
				
				<option value="file83">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/cadvisor/transform_permission_error.go (100.0%)</option>
				
				<option value="file84">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/controlplane/provider.go (93.8%)</option>
				
				<option value="file85">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/interval_timer.go (100.0%)</option>
				
				<option value="file86">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/cronjobs.go (0.0%)</option>
				
				<option value="file87">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/daemonsets.go (81.8%)</option>
				
				<option value="file88">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/deployments.go (80.0%)</option>
				
				<option value="file89">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/helper.go (88.2%)</option>
				
				<option value="file90">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/hpa.go (0.0%)</option>
				
				<option value="file91">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/jobs.go (83.3%)</option>
				
				<option value="file92">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/lister.go (86.7%)</option>
				
				<option value="file93">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/nodes.go (80.0%)</option>
				
				<option value="file94">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/non_running_pods.go (96.2%)</option>
				
				<option value="file95">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/provider.go (83.1%)</option>
				
				<option value="file96">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/replicasets.go (80.0%)</option>
				
				<option value="file97">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/replicationcontrollers.go (0.0%)</option>
				
				<option value="file98">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate/statefulsets.go (81.8%)</option>
				
				<option value="file99">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/manager.go (89.2%)</option>
				
				<option value="file100">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus/factory.go (87.5%)</option>
				
				<option value="file101">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus/lookahead_reader.go (100.0%)</option>
				
				<option value="file102">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus/metric_reader.go (100.0%)</option>
				
				<option value="file103">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus/point_builder.go (98.8%)</option>
				
				<option value="file104">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus/prometheus.go (89.7%)</option>
				
				<option value="file105">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/stats/provider.go (92.3%)</option>
				
				<option value="file106">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/stats/stats.go (95.2%)</option>
				
				<option value="file107">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/converter_utils.go (100.0%)</option>
				
				<option value="file108">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet/configs.go (88.2%)</option>
				
				<option value="file109">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet/kubelet_client.go (63.0%)</option>
				
				<option value="file110">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet/transport.go (90.0%)</option>
				
				<option value="file111">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/summary.go (91.5%)</option>
				
				<option value="file112">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/wavefront_converter.go (82.4%)</option>
				
				<option value="file113">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/systemd/filter.go (100.0%)</option>
				
				<option value="file114">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/systemd/systemd.go (0.0%)</option>
				
				<option value="file115">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf/accumulator.go (64.7%)</option>
				
				<option value="file116">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf/factory.go (87.5%)</option>
				
				<option value="file117">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf/parse.go (71.4%)</option>
				
				<option value="file118">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf/provider.go (77.8%)</option>
				
				<option value="file119">github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf/system.go (83.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "sort"
        "strings"

        "github.com/gobwas/glob"
)

type Diff struct {
        Missing  []*Metric
        Extra    []*Metric
        Unwanted []*Metric
}

func DiffMetrics(expected, excluded, actual []*Metric) *Diff <span class="cov0" title="0">{
        expectedKeyers := metricKeyers(expected)
        expectedKeyMap := metricKeyMap(expected, expectedKeyers)
        actualKeyMap := metricKeyMap(actual, expectedKeyers)
        missing, extra := disjunct(expectedKeyMap, actualKeyMap)

        excludedKeyers := metricKeyers(excluded)
        excludedKeyMap := metricKeyMap(excluded, excludedKeyers)
        actualExcludedKeyMap := metricKeyMap(actual, excludedKeyers)
        unwanted := intersect(excludedKeyMap, actualExcludedKeyMap)

        return &amp;Diff{
                Missing:  missing,
                Extra:    extra,
                Unwanted: unwanted,
        }
}</span>

// keyer returns whether or not it could generate a key and the key of the given metric
type keyer func(*Metric) (bool, string)

func metricKeyers(expected []*Metric) map[string][]keyer <span class="cov0" title="0">{
        keyersByMetric := map[string][]keyer{}
        for _, m := range expected </span><span class="cov0" title="0">{
                keyersByMetric[m.Name] = append(keyersByMetric[m.Name], metricKeyer(m))
        }</span>
        <span class="cov0" title="0">return keyersByMetric</span>
}

func metricKeyer(m *Metric) keyer <span class="cov0" title="0">{
        var keyers []keyer
        keyers = append(keyers, nameKey(m.Name))
        if m.Value != "" </span><span class="cov0" title="0">{
                keyers = append(keyers, valueKey(m.Value))
        }</span>
        <span class="cov0" title="0">if m.Timestamp != "" </span><span class="cov0" title="0">{
                keyers = append(keyers, timestampKey(m.Timestamp))
        }</span>
        <span class="cov0" title="0">keyers = append(keyers, tagsKey(m.Tags))
        return compositeKey(keyers...)</span>
}

func compositeKey(keyers ...keyer) keyer <span class="cov0" title="0">{
        return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                var keys []string
                for _, keyer := range keyers </span><span class="cov0" title="0">{
                        matched, key := keyer(metric)
                        if !matched </span><span class="cov0" title="0">{
                                return false, ""
                        }</span>
                        <span class="cov0" title="0">keys = append(keys, key)</span>
                }
                <span class="cov0" title="0">return true, strings.Join(keys, " ")</span>
        }
}

func nameKey(expected string) keyer <span class="cov0" title="0">{
        return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                return metric.Name == expected, metric.Name
        }</span>
}

func valueKey(expected string) keyer <span class="cov0" title="0">{
        return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                return metric.Value == expected, metric.Value
        }</span>
}

func timestampKey(expected string) keyer <span class="cov0" title="0">{
        return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                return metric.Timestamp == expected, metric.Timestamp
        }</span>
}

func tagNameKey(name string) keyer <span class="cov0" title="0">{
        key := strings.TrimPrefix(name, "!")
        if strings.HasPrefix(name, "!") </span><span class="cov0" title="0">{
                return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                        _, exists := metric.Tags[key]
                        return !exists, fmt.Sprintf("%s!=*", key)
                }</span>
        }
        <span class="cov0" title="0">return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                _, exists := metric.Tags[key]
                return exists, fmt.Sprintf("%s=*", key)
        }</span>
}

func fullTagKey(name, value string) keyer <span class="cov0" title="0">{
        key := strings.TrimPrefix(name, "!")
        if strings.HasPrefix(name, "!") </span><span class="cov0" title="0">{
                return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                        var adjustedKey string
                        if len(metric.Tags[key]) &gt; 0 </span><span class="cov0" title="0">{
                                adjustedKey = key
                        }</span> else<span class="cov0" title="0"> {
                                adjustedKey = strings.Replace(key, "!", "", 1)
                        }</span>
                        <span class="cov0" title="0">return metric.Tags[adjustedKey] != value, fmt.Sprintf("%s!=%#v", key, metric.Tags[key])</span>
                }
        }
        <span class="cov0" title="0">if strings.HasPrefix(name, "~") </span><span class="cov0" title="0">{
                g := glob.MustCompile(value)
                return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                        var adjustedKey string
                        if len(metric.Tags[key]) &gt; 0 </span><span class="cov0" title="0">{
                                adjustedKey = key
                        }</span> else<span class="cov0" title="0"> {
                                adjustedKey = strings.Replace(key, "~", "", 1)
                        }</span>
                        <span class="cov0" title="0">return g.Match(metric.Tags[adjustedKey]), fmt.Sprintf("%s≅%#v", key, value)</span>
                }
        }
        <span class="cov0" title="0">return func(metric *Metric) (bool, string) </span><span class="cov0" title="0">{
                return metric.Tags[key] == value, fmt.Sprintf("%s=%#v", key, metric.Tags[key])
        }</span>
}

func tagsKey(tags map[string]string) keyer <span class="cov0" title="0">{
        tagNames := make([]string, 0, len(tags))
        for name := range tags </span><span class="cov0" title="0">{
                tagNames = append(tagNames, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(tagNames)
        keyers := make([]keyer, len(tags))
        for i, name := range tagNames </span><span class="cov0" title="0">{
                if tags[name] == "" </span><span class="cov0" title="0">{
                        keyers[i] = tagNameKey(name)
                }</span> else<span class="cov0" title="0"> {
                        keyers[i] = fullTagKey(name, tags[name])
                }</span>
        }
        <span class="cov0" title="0">return compositeKey(keyers...)</span>
}

func metricKeyMap(metrics []*Metric, keyers map[string][]keyer) map[string]*Metric <span class="cov0" title="0">{
        keyMap := map[string]*Metric{}
        for _, metric := range metrics </span><span class="cov0" title="0">{
                foundKeyers := keyers[metric.Name]
                found := false
                for _, foundKeyer := range foundKeyers </span><span class="cov0" title="0">{
                        matched, key := foundKeyer(metric)
                        if matched </span><span class="cov0" title="0">{
                                keyMap[key] = metric
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        _, key := metricKeyer(metric)(metric)
                        keyMap[key] = metric
                }</span>
        }
        <span class="cov0" title="0">return keyMap</span>
}

func disjunct(a, b map[string]*Metric) (onlyInA []*Metric, onlyInB []*Metric) <span class="cov0" title="0">{
        onlyInA = []*Metric{}
        onlyInB = []*Metric{}
        for x := range a </span><span class="cov0" title="0">{
                if _, exists := b[x]; !exists </span><span class="cov0" title="0">{
                        onlyInA = append(onlyInA, a[x])
                }</span>
        }
        <span class="cov0" title="0">for y := range b </span><span class="cov0" title="0">{
                if _, exists := a[y]; !exists </span><span class="cov0" title="0">{
                        onlyInB = append(onlyInB, b[y])
                }</span>
        }
        <span class="cov0" title="0">return onlyInA, onlyInB</span>
}

func intersect(a, b map[string]*Metric) (common []*Metric) <span class="cov0" title="0">{
        common = []*Metric{}
        for x := range a </span><span class="cov0" title="0">{
                if v, exists := b[x]; exists </span><span class="cov0" title="0">{
                        common = append(common, v)
                }</span>
        }
        <span class="cov0" title="0">return common</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "flag"
        "net"
        "net/http"
        "os"

        log "github.com/sirupsen/logrus"
)

var proxyAddr = ":7777"
var controlAddr = ":8888"
var logLevel = log.InfoLevel.String()

func init() <span class="cov8" title="1">{
        flag.StringVar(&amp;proxyAddr, "proxy", proxyAddr, "host and port for the test \"wavefront proxy\" to listen on")
        flag.StringVar(&amp;controlAddr, "control", controlAddr, "host and port for the http control server to listen on")
        flag.StringVar(&amp;logLevel, "logLevel", logLevel, "change log level. Default is \"info\", use \"debug\" for metric logging")
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()

        log.SetFormatter(&amp;log.TextFormatter{})
        if level, err := log.ParseLevel(logLevel); err == nil </span><span class="cov0" title="0">{
                log.SetLevel(level)
        }</span> else<span class="cov0" title="0"> {
                log.SetLevel(log.InfoLevel)
        }</span>
        <span class="cov0" title="0">log.SetOutput(os.Stdout)

        store := NewMetricStore()

        go ServeProxy(store)
        http.HandleFunc("/metrics", DumpMetricsHandler(store))
        http.HandleFunc("/metrics/diff", DiffMetricsHandler(store))

        log.Infof("http control server listening on %s", controlAddr)
        if err := http.ListenAndServe(controlAddr, nil); err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                os.Exit(1)
        }</span>
}

func ServeProxy(store *MetricStore) <span class="cov0" title="0">{
        log.Infof("tcp metrics server listening on %s", proxyAddr)
        listener, err := net.Listen("tcp", proxyAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">go HandleIncomingMetrics(store, conn)</span>
        }
}

func HandleIncomingMetrics(store *MetricStore, conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()
        lines := bufio.NewScanner(conn)
        for lines.Scan() </span><span class="cov0" title="0">{
                if len(lines.Text()) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">metric, err := ParseMetric(lines.Text())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                        log.Error(lines.Text())
                        store.LogBadMetric(lines.Text())
                        continue</span>
                }
                <span class="cov0" title="0">if metric == nil </span><span class="cov0" title="0">{ // we got a histogram
                        continue</span>
                }
                <span class="cov0" title="0">log.Debugf("%#v", metric)
                store.LogMetric(metric)</span>
        }
        <span class="cov0" title="0">if err := lines.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error(err.Error())
        }</span>
        <span class="cov0" title="0">return</span>
}

func DumpMetricsHandler(store *MetricStore) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                if req.Method != http.MethodGet </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        log.Errorf("expected method %s but got %s", http.MethodGet, req.Method)
                        return
                }</span>
                <span class="cov0" title="0">badMetrics := store.BadMetrics()
                if len(badMetrics) &gt; 0 </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        err := json.NewEncoder(w).Encode(badMetrics)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err.Error())
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                err := json.NewEncoder(w).Encode(store.Metrics())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err.Error())
                }</span>
        }
}

func DiffMetricsHandler(store *MetricStore) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                if req.Method != http.MethodPost </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        log.Errorf("expected method %s but got %s", http.MethodGet, req.Method)
                        return
                }</span>
                <span class="cov0" title="0">badMetrics := store.BadMetrics()
                if len(badMetrics) &gt; 0 </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusUnprocessableEntity)
                        err := json.NewEncoder(w).Encode(badMetrics)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err.Error())
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">var expectedMetrics []*Metric
                var excludedMetrics []*Metric
                lines := bufio.NewScanner(req.Body)
                defer req.Body.Close()
                for lines.Scan() </span><span class="cov0" title="0">{
                        if len(lines.Bytes()) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">var err error
                        if lines.Bytes()[0] == '~' </span><span class="cov0" title="0">{
                                var excludedMetric *Metric
                                excludedMetric, err = decodeMetric(lines.Bytes()[1:])
                                excludedMetrics = append(excludedMetrics, excludedMetric)
                        }</span> else<span class="cov0" title="0"> {
                                var expectedMetric *Metric
                                expectedMetric, err = decodeMetric(lines.Bytes())
                                expectedMetrics = append(expectedMetrics, expectedMetric)
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusBadRequest)
                                err = json.NewEncoder(w).Encode(err.Error())
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(err.Error())
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
                <span class="cov0" title="0">linesErr := lines.Err()
                if linesErr != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        ioErr := json.NewEncoder(w).Encode(linesErr.Error())
                        if ioErr != nil </span><span class="cov0" title="0">{
                                log.Error(ioErr.Error())
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                linesErr = json.NewEncoder(w).Encode(DiffMetrics(expectedMetrics, excludedMetrics, store.Metrics()))
                if linesErr != nil </span><span class="cov0" title="0">{
                        log.Error(linesErr.Error())
                }</span>
        }
}

func decodeMetric(bytes []byte) (*Metric, error) <span class="cov0" title="0">{
        var metric *Metric
        err := json.Unmarshal(bytes, &amp;metric)
        return metric, err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

type Metric struct {
        Name      string
        Value     string
        Timestamp string
        Tags      map[string]string
}

func ParseMetric(line string) (*Metric, error) <span class="cov10" title="2">{
        g := &amp;MetricGrammar{Buffer: line}
        g.Init()
        if err := g.Parse(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="2">g.Execute()
        if g.Histogram </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">return &amp;Metric{
                Name:      g.Name,
                Value:     g.Value,
                Timestamp: g.Timestamp,
                Tags:      g.Tags,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

// Code generated by peg -switch -inline cmd/test-proxy/metric_grammar.peg DO NOT EDIT.

import (
        "fmt"
        "io"
        "os"
        "sort"
        "strconv"
        "strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
        ruleUnknown pegRule = iota
        ruleMetricGrammar
        ruleaggregationInterval
        rulehistogramValues
        rulehistogramValue
        ruletags
        ruletag
        ruletagName
        ruletagValue
        ruletimestamp
        rulemetricValue
        rulemetricName
        ruleALNUM
        ruleDIGIT
        ruleAction0
        ruleAction1
        rulePegText
        ruleAction2
        ruleAction3
        ruleAction4
        ruleAction5
        ruleAction6
)

var rul3s = [...]string{
        "Unknown",
        "MetricGrammar",
        "aggregationInterval",
        "histogramValues",
        "histogramValue",
        "tags",
        "tag",
        "tagName",
        "tagValue",
        "timestamp",
        "metricValue",
        "metricName",
        "ALNUM",
        "DIGIT",
        "Action0",
        "Action1",
        "PegText",
        "Action2",
        "Action3",
        "Action4",
        "Action5",
        "Action6",
}

type token32 struct {
        pegRule
        begin, end uint32
}

func (t *token32) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}</span>

type node32 struct {
        token32
        up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) <span class="cov0" title="0">{
        var print func(node *node32, depth int)
        print = func(node *node32, depth int) </span><span class="cov0" title="0">{
                for node != nil </span><span class="cov0" title="0">{
                        for c := 0; c &lt; depth; c++ </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, " ")
                        }</span>
                        <span class="cov0" title="0">rule := rul3s[node.pegRule]
                        quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
                        if !pretty </span><span class="cov0" title="0">{
                                fmt.Fprintf(w, "%v %v\n", rule, quote)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
                        }</span>
                        <span class="cov0" title="0">if node.up != nil </span><span class="cov0" title="0">{
                                print(node.up, depth+1)
                        }</span>
                        <span class="cov0" title="0">node = node.next</span>
                }
        }
        <span class="cov0" title="0">print(node, 0)</span>
}

func (node *node32) Print(w io.Writer, buffer string) <span class="cov0" title="0">{
        node.print(w, false, buffer)
}</span>

func (node *node32) PrettyPrint(w io.Writer, buffer string) <span class="cov0" title="0">{
        node.print(w, true, buffer)
}</span>

type tokens32 struct {
        tree []token32
}

func (t *tokens32) Trim(length uint32) <span class="cov2" title="2">{
        t.tree = t.tree[:length]
}</span>

func (t *tokens32) Print() <span class="cov0" title="0">{
        for _, token := range t.tree </span><span class="cov0" title="0">{
                fmt.Println(token.String())
        }</span>
}

func (t *tokens32) AST() *node32 <span class="cov0" title="0">{
        type element struct {
                node *node32
                down *element
        }
        tokens := t.Tokens()
        var stack *element
        for _, token := range tokens </span><span class="cov0" title="0">{
                if token.begin == token.end </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">node := &amp;node32{token32: token}
                for stack != nil &amp;&amp; stack.node.begin &gt;= token.begin &amp;&amp; stack.node.end &lt;= token.end </span><span class="cov0" title="0">{
                        stack.node.next = node.up
                        node.up = stack.node
                        stack = stack.down
                }</span>
                <span class="cov0" title="0">stack = &amp;element{node: node, down: stack}</span>
        }
        <span class="cov0" title="0">if stack != nil </span><span class="cov0" title="0">{
                return stack.node
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *tokens32) PrintSyntaxTree(buffer string) <span class="cov0" title="0">{
        t.AST().Print(os.Stdout, buffer)
}</span>

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) <span class="cov0" title="0">{
        t.AST().Print(w, buffer)
}</span>

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) <span class="cov0" title="0">{
        t.AST().PrettyPrint(os.Stdout, buffer)
}</span>

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) <span class="cov10" title="133">{
        tree, i := t.tree, int(index)
        if i &gt;= len(tree) </span><span class="cov10" title="133">{
                t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
                return
        }</span>
        <span class="cov0" title="0">tree[i] = token32{pegRule: rule, begin: begin, end: end}</span>
}

func (t *tokens32) Tokens() []token32 <span class="cov2" title="2">{
        return t.tree
}</span>

type MetricGrammar struct {
        Histogram  bool
        Name       string
        Value      string
        Timestamp  string
        Tags       map[string]string
        currentTag string

        Buffer string
        buffer []rune
        rules  [22]func() bool
        parse  func(rule ...int) error
        reset  func()
        Pretty bool
        tokens32
}

func (p *MetricGrammar) Parse(rule ...int) error <span class="cov2" title="2">{
        return p.parse(rule...)
}</span>

func (p *MetricGrammar) Reset() <span class="cov0" title="0">{
        p.reset()
}</span>

type textPosition struct {
        line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap <span class="cov0" title="0">{
        length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
        sort.Ints(positions)

search:
        for i, c := range buffer </span><span class="cov0" title="0">{
                if c == '\n' </span><span class="cov0" title="0">{
                        line, symbol = line+1, 0
                }</span> else<span class="cov0" title="0"> {
                        symbol++
                }</span>
                <span class="cov0" title="0">if i == positions[j] </span><span class="cov0" title="0">{
                        translations[positions[j]] = textPosition{line, symbol}
                        for j++; j &lt; length; j++ </span><span class="cov0" title="0">{
                                if i != positions[j] </span><span class="cov0" title="0">{
                                        continue search</span>
                                }
                        }
                        <span class="cov0" title="0">break search</span>
                }
        }

        <span class="cov0" title="0">return translations</span>
}

type parseError struct {
        p   *MetricGrammar
        max token32
}

func (e *parseError) Error() string <span class="cov0" title="0">{
        tokens, err := []token32{e.max}, "\n"
        positions, p := make([]int, 2*len(tokens)), 0
        for _, token := range tokens </span><span class="cov0" title="0">{
                positions[p], p = int(token.begin), p+1
                positions[p], p = int(token.end), p+1
        }</span>
        <span class="cov0" title="0">translations := translatePositions(e.p.buffer, positions)
        format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
        if e.p.Pretty </span><span class="cov0" title="0">{
                format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
        }</span>
        <span class="cov0" title="0">for _, token := range tokens </span><span class="cov0" title="0">{
                begin, end := int(token.begin), int(token.end)
                err += fmt.Sprintf(format,
                        rul3s[token.pegRule],
                        translations[begin].line, translations[begin].symbol,
                        translations[end].line, translations[end].symbol,
                        strconv.Quote(string(e.p.buffer[begin:end])))
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (p *MetricGrammar) PrintSyntaxTree() <span class="cov0" title="0">{
        if p.Pretty </span><span class="cov0" title="0">{
                p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
        }</span> else<span class="cov0" title="0"> {
                p.tokens32.PrintSyntaxTree(p.Buffer)
        }</span>
}

func (p *MetricGrammar) WriteSyntaxTree(w io.Writer) <span class="cov0" title="0">{
        p.tokens32.WriteSyntaxTree(w, p.Buffer)
}</span>

func (p *MetricGrammar) SprintSyntaxTree() string <span class="cov0" title="0">{
        var bldr strings.Builder
        p.WriteSyntaxTree(&amp;bldr)
        return bldr.String()
}</span>

func (p *MetricGrammar) Execute() <span class="cov2" title="2">{
        buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
        for _, token := range p.Tokens() </span><span class="cov10" title="133">{
                switch token.pegRule </span>{

                case rulePegText:<span class="cov5" title="13">
                        begin, end = int(token.begin), int(token.end)
                        text = string(_buffer[begin:end])</span>

                case ruleAction0:<span class="cov1" title="1">
                        p.Histogram = true</span>
                case ruleAction1:<span class="cov2" title="2">
                        p.Tags = map[string]string{}</span>
                case ruleAction2:<span class="cov3" title="3">
                        p.currentTag = text</span>
                case ruleAction3:<span class="cov3" title="3">
                        p.Tags[p.currentTag] = text</span>
                case ruleAction4:<span class="cov2" title="2">
                        p.Timestamp = text</span>
                case ruleAction5:<span class="cov3" title="3">
                        p.Value = text</span>
                case ruleAction6:<span class="cov2" title="2">
                        p.Name = text</span>

                }
        }
        <span class="cov2" title="2">_, _, _, _, _ = buffer, _buffer, text, begin, end</span>
}

func Pretty(pretty bool) func(*MetricGrammar) error <span class="cov0" title="0">{
        return func(p *MetricGrammar) error </span><span class="cov0" title="0">{
                p.Pretty = pretty
                return nil
        }</span>
}

func Size(size int) func(*MetricGrammar) error <span class="cov0" title="0">{
        return func(p *MetricGrammar) error </span><span class="cov0" title="0">{
                p.tokens32 = tokens32{tree: make([]token32, 0, size)}
                return nil
        }</span>
}
func (p *MetricGrammar) Init(options ...func(*MetricGrammar) error) error <span class="cov2" title="2">{
        var (
                max                  token32
                position, tokenIndex uint32
                buffer               []rune
        )
        for _, option := range options </span><span class="cov0" title="0">{
                err := option(p)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov2" title="2">p.reset = func() </span><span class="cov2" title="2">{
                max = token32{}
                position, tokenIndex = 0, 0

                p.buffer = []rune(p.Buffer)
                if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol </span><span class="cov2" title="2">{
                        p.buffer = append(p.buffer, endSymbol)
                }</span>
                <span class="cov2" title="2">buffer = p.buffer</span>
        }
        <span class="cov2" title="2">p.reset()

        _rules := p.rules
        tree := p.tokens32
        p.parse = func(rule ...int) error </span><span class="cov2" title="2">{
                r := 1
                if len(rule) &gt; 0 </span><span class="cov0" title="0">{
                        r = rule[0]
                }</span>
                <span class="cov2" title="2">matches := p.rules[r]()
                p.tokens32 = tree
                if matches </span><span class="cov2" title="2">{
                        p.Trim(tokenIndex)
                        return nil
                }</span>
                <span class="cov0" title="0">return &amp;parseError{p, max}</span>
        }

        <span class="cov2" title="2">add := func(rule pegRule, begin uint32) </span><span class="cov10" title="133">{
                tree.Add(rule, begin, position, tokenIndex)
                tokenIndex++
                if begin != position &amp;&amp; position &gt; max.end </span><span class="cov9" title="87">{
                        max = token32{rule, begin, position}
                }</span>
        }

        <span class="cov2" title="2">matchDot := func() bool </span><span class="cov7" title="38">{
                if buffer[position] != endSymbol </span><span class="cov7" title="36">{
                        position++
                        return true
                }</span>
                <span class="cov2" title="2">return false</span>
        }

        /*matchChar := func(c byte) bool {
                if buffer[position] == c {
                        position++
                        return true
                }
                return false
        }*/

        /*matchRange := func(lower byte, upper byte) bool {
                if c := buffer[position]; c &gt;= lower &amp;&amp; c &lt;= upper {
                        position++
                        return true
                }
                return false
        }*/

        <span class="cov2" title="2">_rules = [...]func() bool{
                nil,
                /* 0 MetricGrammar &lt;- &lt;((aggregationInterval (' ' timestamp)? ' ' histogramValues ' ' metricName ' ' tags !.) / (metricName ' ' metricValue (' ' timestamp)? ' ' tags !.))&gt; */
                func() bool </span><span class="cov2" title="2">{
                        position0, tokenIndex0 := position, tokenIndex
                        </span><span class="cov2" title="2">{
                                position1 := position
                                </span><span class="cov2" title="2">{
                                        position2, tokenIndex2 := position, tokenIndex
                                        </span><span class="cov2" title="2">{
                                                position4 := position
                                                if buffer[position] != rune('!') </span><span class="cov1" title="1">{
                                                        goto l3</span>
                                                }
                                                <span class="cov1" title="1">position++
                                                </span><span class="cov1" title="1">{
                                                        switch buffer[position] </span>{
                                                        case 'D':<span class="cov0" title="0">
                                                                if buffer[position] != rune('D') </span><span class="cov0" title="0">{
                                                                        goto l3</span>
                                                                }
                                                                <span class="cov0" title="0">position++</span>
                                                        case 'H':<span class="cov0" title="0">
                                                                if buffer[position] != rune('H') </span><span class="cov0" title="0">{
                                                                        goto l3</span>
                                                                }
                                                                <span class="cov0" title="0">position++</span>
                                                        default:<span class="cov1" title="1">
                                                                if buffer[position] != rune('M') </span><span class="cov0" title="0">{
                                                                        goto l3</span>
                                                                }
                                                                <span class="cov1" title="1">position++</span>
                                                        }
                                                }

                                                <span class="cov1" title="1">{
                                                        add(ruleAction0, position)
                                                }</span>
                                                <span class="cov1" title="1">add(ruleaggregationInterval, position4)</span>
                                        }
                                        <span class="cov1" title="1">{
                                                position7, tokenIndex7 := position, tokenIndex
                                                if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                        goto l7</span>
                                                }
                                                <span class="cov1" title="1">position++
                                                if !_rules[ruletimestamp]() </span><span class="cov0" title="0">{
                                                        goto l7</span>
                                                }
                                                <span class="cov1" title="1">goto l8</span>
                                        l7:
                                                <span class="cov0" title="0">position, tokenIndex = position7, tokenIndex7</span>
                                        }
                                l8:
                                        <span class="cov1" title="1">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                goto l3</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        </span><span class="cov1" title="1">{
                                                position9 := position
                                                if !_rules[rulehistogramValue]() </span><span class="cov0" title="0">{
                                                        goto l3</span>
                                                }
                                        l10:
                                                <span class="cov2" title="2">{
                                                        position11, tokenIndex11 := position, tokenIndex
                                                        if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                                goto l11</span>
                                                        }
                                                        <span class="cov2" title="2">position++
                                                        if !_rules[rulehistogramValue]() </span><span class="cov1" title="1">{
                                                                goto l11</span>
                                                        }
                                                        <span class="cov1" title="1">goto l10</span>
                                                l11:
                                                        <span class="cov1" title="1">position, tokenIndex = position11, tokenIndex11</span>
                                                }
                                                <span class="cov1" title="1">add(rulehistogramValues, position9)</span>
                                        }
                                        <span class="cov1" title="1">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                goto l3</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        if !_rules[rulemetricName]() </span><span class="cov0" title="0">{
                                                goto l3</span>
                                        }
                                        <span class="cov1" title="1">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                goto l3</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        if !_rules[ruletags]() </span><span class="cov0" title="0">{
                                                goto l3</span>
                                        }
                                        <span class="cov1" title="1">{
                                                position12, tokenIndex12 := position, tokenIndex
                                                if !matchDot() </span><span class="cov1" title="1">{
                                                        goto l12</span>
                                                }
                                                <span class="cov0" title="0">goto l3</span>
                                        l12:
                                                <span class="cov1" title="1">position, tokenIndex = position12, tokenIndex12</span>
                                        }
                                        <span class="cov1" title="1">goto l2</span>
                                l3:
                                        <span class="cov1" title="1">position, tokenIndex = position2, tokenIndex2
                                        if !_rules[rulemetricName]() </span><span class="cov0" title="0">{
                                                goto l0</span>
                                        }
                                        <span class="cov1" title="1">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                goto l0</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        if !_rules[rulemetricValue]() </span><span class="cov0" title="0">{
                                                goto l0</span>
                                        }
                                        <span class="cov1" title="1">{
                                                position13, tokenIndex13 := position, tokenIndex
                                                if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                        goto l13</span>
                                                }
                                                <span class="cov1" title="1">position++
                                                if !_rules[ruletimestamp]() </span><span class="cov0" title="0">{
                                                        goto l13</span>
                                                }
                                                <span class="cov1" title="1">goto l14</span>
                                        l13:
                                                <span class="cov0" title="0">position, tokenIndex = position13, tokenIndex13</span>
                                        }
                                l14:
                                        <span class="cov1" title="1">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                                goto l0</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        if !_rules[ruletags]() </span><span class="cov0" title="0">{
                                                goto l0</span>
                                        }
                                        <span class="cov1" title="1">{
                                                position15, tokenIndex15 := position, tokenIndex
                                                if !matchDot() </span><span class="cov1" title="1">{
                                                        goto l15</span>
                                                }
                                                <span class="cov0" title="0">goto l0</span>
                                        l15:
                                                <span class="cov1" title="1">position, tokenIndex = position15, tokenIndex15</span>
                                        }
                                }
                        l2:
                                <span class="cov2" title="2">add(ruleMetricGrammar, position1)</span>
                        }
                        <span class="cov2" title="2">return true
                </span>l0:
                        <span class="cov0" title="0">position, tokenIndex = position0, tokenIndex0
                        return false</span>
                },
                /* 1 aggregationInterval &lt;- &lt;('!' ((&amp;('D') 'D') | (&amp;('H') 'H') | (&amp;('M') 'M')) Action0)&gt; */
                nil,
                /* 2 histogramValues &lt;- &lt;(histogramValue (' ' histogramValue)*)&gt; */
                nil,
                /* 3 histogramValue &lt;- &lt;('#' DIGIT+ ' ' metricValue)&gt; */
                func() bool <span class="cov3" title="3">{
                        position18, tokenIndex18 := position, tokenIndex
                        </span><span class="cov3" title="3">{
                                position19 := position
                                if buffer[position] != rune('#') </span><span class="cov1" title="1">{
                                        goto l18</span>
                                }
                                <span class="cov2" title="2">position++
                                if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                        goto l18</span>
                                }
                        l20:
                                <span class="cov3" title="4">{
                                        position21, tokenIndex21 := position, tokenIndex
                                        if !_rules[ruleDIGIT]() </span><span class="cov2" title="2">{
                                                goto l21</span>
                                        }
                                        <span class="cov2" title="2">goto l20</span>
                                l21:
                                        <span class="cov2" title="2">position, tokenIndex = position21, tokenIndex21</span>
                                }
                                <span class="cov2" title="2">if buffer[position] != rune(' ') </span><span class="cov0" title="0">{
                                        goto l18</span>
                                }
                                <span class="cov2" title="2">position++
                                if !_rules[rulemetricValue]() </span><span class="cov0" title="0">{
                                        goto l18</span>
                                }
                                <span class="cov2" title="2">add(rulehistogramValue, position19)</span>
                        }
                        <span class="cov2" title="2">return true
                </span>l18:
                        <span class="cov1" title="1">position, tokenIndex = position18, tokenIndex18
                        return false</span>
                },
                /* 4 tags &lt;- &lt;(Action1 tag (' ' tag)*)&gt; */
                func() bool <span class="cov2" title="2">{
                        position22, tokenIndex22 := position, tokenIndex
                        </span><span class="cov2" title="2">{
                                position23 := position
                                </span><span class="cov2" title="2">{
                                        add(ruleAction1, position)
                                }</span>
                                <span class="cov2" title="2">if !_rules[ruletag]() </span><span class="cov0" title="0">{
                                        goto l22</span>
                                }
                        l25:
                                <span class="cov3" title="3">{
                                        position26, tokenIndex26 := position, tokenIndex
                                        if buffer[position] != rune(' ') </span><span class="cov2" title="2">{
                                                goto l26</span>
                                        }
                                        <span class="cov1" title="1">position++
                                        if !_rules[ruletag]() </span><span class="cov0" title="0">{
                                                goto l26</span>
                                        }
                                        <span class="cov1" title="1">goto l25</span>
                                l26:
                                        <span class="cov2" title="2">position, tokenIndex = position26, tokenIndex26</span>
                                }
                                <span class="cov2" title="2">add(ruletags, position23)</span>
                        }
                        <span class="cov2" title="2">return true
                </span>l22:
                        <span class="cov0" title="0">position, tokenIndex = position22, tokenIndex22
                        return false</span>
                },
                /* 5 tag &lt;- &lt;(tagName '=' tagValue)&gt; */
                func() bool <span class="cov3" title="3">{
                        position27, tokenIndex27 := position, tokenIndex
                        </span><span class="cov3" title="3">{
                                position28 := position
                                </span><span class="cov3" title="3">{
                                        position29 := position
                                        </span><span class="cov3" title="3">{
                                                position30, tokenIndex30 := position, tokenIndex
                                                if buffer[position] != rune('"') </span><span class="cov3" title="3">{
                                                        goto l31</span>
                                                }
                                                <span class="cov0" title="0">position++
                                                </span><span class="cov0" title="0">{
                                                        position32 := position
                                                        </span><span class="cov0" title="0">{
                                                                position35, tokenIndex35 := position, tokenIndex
                                                                if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                        goto l36</span>
                                                                }
                                                                <span class="cov0" title="0">goto l35</span>
                                                        l36:
                                                                <span class="cov0" title="0">position, tokenIndex = position35, tokenIndex35
                                                                </span><span class="cov0" title="0">{
                                                                        switch buffer[position] </span>{
                                                                        case '.':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                        goto l31</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '_':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                        goto l31</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '-':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                        goto l31</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        default:<span class="cov0" title="0">
                                                                                if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                        goto l31</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        }
                                                                }

                                                        }
                                                l35:
                                                l33:
                                                        <span class="cov0" title="0">{
                                                                position34, tokenIndex34 := position, tokenIndex
                                                                </span><span class="cov0" title="0">{
                                                                        position38, tokenIndex38 := position, tokenIndex
                                                                        if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                                goto l39</span>
                                                                        }
                                                                        <span class="cov0" title="0">goto l38</span>
                                                                l39:
                                                                        <span class="cov0" title="0">position, tokenIndex = position38, tokenIndex38
                                                                        </span><span class="cov0" title="0">{
                                                                                switch buffer[position] </span>{
                                                                                case '.':<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                                goto l34</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                case '_':<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                                goto l34</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                case '-':<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                                goto l34</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                default:<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                                goto l34</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                }
                                                                        }

                                                                }
                                                        l38:
                                                                <span class="cov0" title="0">goto l33</span>
                                                        l34:
                                                                <span class="cov0" title="0">position, tokenIndex = position34, tokenIndex34</span>
                                                        }
                                                        <span class="cov0" title="0">add(rulePegText, position32)</span>
                                                }
                                                <span class="cov0" title="0">if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                        goto l31</span>
                                                }
                                                <span class="cov0" title="0">position++
                                                goto l30</span>
                                        l31:
                                                <span class="cov3" title="3">position, tokenIndex = position30, tokenIndex30
                                                </span><span class="cov3" title="3">{
                                                        position41 := position
                                                        </span><span class="cov3" title="3">{
                                                                position44, tokenIndex44 := position, tokenIndex
                                                                if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                        goto l45</span>
                                                                }
                                                                <span class="cov3" title="3">goto l44</span>
                                                        l45:
                                                                <span class="cov0" title="0">position, tokenIndex = position44, tokenIndex44
                                                                </span><span class="cov0" title="0">{
                                                                        switch buffer[position] </span>{
                                                                        case '.':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                        goto l27</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '_':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                        goto l27</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        default:<span class="cov0" title="0">
                                                                                if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                        goto l27</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        }
                                                                }

                                                        }
                                                l44:
                                                l42:
                                                        <span class="cov6" title="18">{
                                                                position43, tokenIndex43 := position, tokenIndex
                                                                </span><span class="cov6" title="18">{
                                                                        position47, tokenIndex47 := position, tokenIndex
                                                                        if !_rules[ruleALNUM]() </span><span class="cov3" title="3">{
                                                                                goto l48</span>
                                                                        }
                                                                        <span class="cov5" title="15">goto l47</span>
                                                                l48:
                                                                        <span class="cov3" title="3">position, tokenIndex = position47, tokenIndex47
                                                                        </span><span class="cov3" title="3">{
                                                                                switch buffer[position] </span>{
                                                                                case '.':<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                                goto l43</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                case '_':<span class="cov0" title="0">
                                                                                        if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                                goto l43</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                default:<span class="cov3" title="3">
                                                                                        if buffer[position] != rune('-') </span><span class="cov3" title="3">{
                                                                                                goto l43</span>
                                                                                        }
                                                                                        <span class="cov0" title="0">position++</span>
                                                                                }
                                                                        }

                                                                }
                                                        l47:
                                                                <span class="cov5" title="15">goto l42</span>
                                                        l43:
                                                                <span class="cov3" title="3">position, tokenIndex = position43, tokenIndex43</span>
                                                        }
                                                        <span class="cov3" title="3">add(rulePegText, position41)</span>
                                                }
                                        }
                                l30:
                                        <span class="cov3" title="3">{
                                                add(ruleAction2, position)
                                        }</span>
                                        <span class="cov3" title="3">add(ruletagName, position29)</span>
                                }
                                <span class="cov3" title="3">if buffer[position] != rune('=') </span><span class="cov0" title="0">{
                                        goto l27</span>
                                }
                                <span class="cov3" title="3">position++
                                </span><span class="cov3" title="3">{
                                        position51 := position
                                        if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                goto l27</span>
                                        }
                                        <span class="cov3" title="3">position++
                                        </span><span class="cov3" title="3">{
                                                position52 := position
                                                </span><span class="cov3" title="3">{
                                                        position55, tokenIndex55 := position, tokenIndex
                                                        if buffer[position] != rune('\\') </span><span class="cov3" title="3">{
                                                                goto l56</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                                goto l56</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        goto l55</span>
                                                l56:
                                                        <span class="cov3" title="3">position, tokenIndex = position55, tokenIndex55
                                                        </span><span class="cov3" title="3">{
                                                                position57, tokenIndex57 := position, tokenIndex
                                                                if buffer[position] != rune('"') </span><span class="cov3" title="3">{
                                                                        goto l57</span>
                                                                }
                                                                <span class="cov0" title="0">position++
                                                                goto l27</span>
                                                        l57:
                                                                <span class="cov3" title="3">position, tokenIndex = position57, tokenIndex57</span>
                                                        }
                                                        <span class="cov3" title="3">if !matchDot() </span><span class="cov0" title="0">{
                                                                goto l27</span>
                                                        }
                                                }
                                        l55:
                                        l53:
                                                <span class="cov7" title="36">{
                                                        position54, tokenIndex54 := position, tokenIndex
                                                        </span><span class="cov7" title="36">{
                                                                position58, tokenIndex58 := position, tokenIndex
                                                                if buffer[position] != rune('\\') </span><span class="cov7" title="36">{
                                                                        goto l59</span>
                                                                }
                                                                <span class="cov0" title="0">position++
                                                                if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                                        goto l59</span>
                                                                }
                                                                <span class="cov0" title="0">position++
                                                                goto l58</span>
                                                        l59:
                                                                <span class="cov7" title="36">position, tokenIndex = position58, tokenIndex58
                                                                </span><span class="cov7" title="36">{
                                                                        position60, tokenIndex60 := position, tokenIndex
                                                                        if buffer[position] != rune('"') </span><span class="cov7" title="33">{
                                                                                goto l60</span>
                                                                        }
                                                                        <span class="cov3" title="3">position++
                                                                        goto l54</span>
                                                                l60:
                                                                        <span class="cov7" title="33">position, tokenIndex = position60, tokenIndex60</span>
                                                                }
                                                                <span class="cov7" title="33">if !matchDot() </span><span class="cov0" title="0">{
                                                                        goto l54</span>
                                                                }
                                                        }
                                                l58:
                                                        <span class="cov7" title="33">goto l53</span>
                                                l54:
                                                        <span class="cov3" title="3">position, tokenIndex = position54, tokenIndex54</span>
                                                }
                                                <span class="cov3" title="3">add(rulePegText, position52)</span>
                                        }
                                        <span class="cov3" title="3">if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                goto l27</span>
                                        }
                                        <span class="cov3" title="3">position++
                                        </span><span class="cov3" title="3">{
                                                add(ruleAction3, position)
                                        }</span>
                                        <span class="cov3" title="3">add(ruletagValue, position51)</span>
                                }
                                <span class="cov3" title="3">add(ruletag, position28)</span>
                        }
                        <span class="cov3" title="3">return true
                </span>l27:
                        <span class="cov0" title="0">position, tokenIndex = position27, tokenIndex27
                        return false</span>
                },
                /* 6 tagName &lt;- &lt;((('"' &lt;(ALNUM / ((&amp;('.') '.') | (&amp;('_') '_') | (&amp;('-') '-') | (&amp;('/') '/')))+&gt; '"') / &lt;(ALNUM / ((&amp;('.') '.') | (&amp;('_') '_') | (&amp;('-') '-')))+&gt;) Action2)&gt; */
                nil,
                /* 7 tagValue &lt;- &lt;('"' &lt;(('\\' '"') / (!'"' .))+&gt; '"' Action3)&gt; */
                nil,
                /* 8 timestamp &lt;- &lt;(&lt;(DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT (DIGIT DIGIT DIGIT)? (DIGIT DIGIT DIGIT)?)&gt; Action4)&gt; */
                func() bool <span class="cov2" title="2">{
                        position64, tokenIndex64 := position, tokenIndex
                        </span><span class="cov2" title="2">{
                                position65 := position
                                </span><span class="cov2" title="2">{
                                        position66 := position
                                        if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l64</span>
                                        }
                                        <span class="cov2" title="2">{
                                                position67, tokenIndex67 := position, tokenIndex
                                                if !_rules[ruleDIGIT]() </span><span class="cov2" title="2">{
                                                        goto l67</span>
                                                }
                                                <span class="cov0" title="0">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                        goto l67</span>
                                                }
                                                <span class="cov0" title="0">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                        goto l67</span>
                                                }
                                                <span class="cov0" title="0">goto l68</span>
                                        l67:
                                                <span class="cov2" title="2">position, tokenIndex = position67, tokenIndex67</span>
                                        }
                                l68:
                                        <span class="cov2" title="2">{
                                                position69, tokenIndex69 := position, tokenIndex
                                                if !_rules[ruleDIGIT]() </span><span class="cov2" title="2">{
                                                        goto l69</span>
                                                }
                                                <span class="cov0" title="0">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                        goto l69</span>
                                                }
                                                <span class="cov0" title="0">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                        goto l69</span>
                                                }
                                                <span class="cov0" title="0">goto l70</span>
                                        l69:
                                                <span class="cov2" title="2">position, tokenIndex = position69, tokenIndex69</span>
                                        }
                                l70:
                                        <span class="cov2" title="2">add(rulePegText, position66)</span>
                                }
                                <span class="cov2" title="2">{
                                        add(ruleAction4, position)
                                }</span>
                                <span class="cov2" title="2">add(ruletimestamp, position65)</span>
                        }
                        <span class="cov2" title="2">return true
                </span>l64:
                        <span class="cov0" title="0">position, tokenIndex = position64, tokenIndex64
                        return false</span>
                },
                /* 9 metricValue &lt;- &lt;(&lt;('-'? DIGIT+ ('.' DIGIT+)?)&gt; Action5)&gt; */
                func() bool <span class="cov3" title="3">{
                        position72, tokenIndex72 := position, tokenIndex
                        </span><span class="cov3" title="3">{
                                position73 := position
                                </span><span class="cov3" title="3">{
                                        position74 := position
                                        </span><span class="cov3" title="3">{
                                                position75, tokenIndex75 := position, tokenIndex
                                                if buffer[position] != rune('-') </span><span class="cov3" title="3">{
                                                        goto l75</span>
                                                }
                                                <span class="cov0" title="0">position++
                                                goto l76</span>
                                        l75:
                                                <span class="cov3" title="3">position, tokenIndex = position75, tokenIndex75</span>
                                        }
                                l76:
                                        <span class="cov3" title="3">if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                goto l72</span>
                                        }
                                l77:
                                        <span class="cov3" title="4">{
                                                position78, tokenIndex78 := position, tokenIndex
                                                if !_rules[ruleDIGIT]() </span><span class="cov3" title="3">{
                                                        goto l78</span>
                                                }
                                                <span class="cov1" title="1">goto l77</span>
                                        l78:
                                                <span class="cov3" title="3">position, tokenIndex = position78, tokenIndex78</span>
                                        }
                                        <span class="cov3" title="3">{
                                                position79, tokenIndex79 := position, tokenIndex
                                                if buffer[position] != rune('.') </span><span class="cov2" title="2">{
                                                        goto l79</span>
                                                }
                                                <span class="cov1" title="1">position++
                                                if !_rules[ruleDIGIT]() </span><span class="cov0" title="0">{
                                                        goto l79</span>
                                                }
                                        l81:
                                                <span class="cov2" title="2">{
                                                        position82, tokenIndex82 := position, tokenIndex
                                                        if !_rules[ruleDIGIT]() </span><span class="cov1" title="1">{
                                                                goto l82</span>
                                                        }
                                                        <span class="cov1" title="1">goto l81</span>
                                                l82:
                                                        <span class="cov1" title="1">position, tokenIndex = position82, tokenIndex82</span>
                                                }
                                                <span class="cov1" title="1">goto l80</span>
                                        l79:
                                                <span class="cov2" title="2">position, tokenIndex = position79, tokenIndex79</span>
                                        }
                                l80:
                                        <span class="cov3" title="3">add(rulePegText, position74)</span>
                                }
                                <span class="cov3" title="3">{
                                        add(ruleAction5, position)
                                }</span>
                                <span class="cov3" title="3">add(rulemetricValue, position73)</span>
                        }
                        <span class="cov3" title="3">return true
                </span>l72:
                        <span class="cov0" title="0">position, tokenIndex = position72, tokenIndex72
                        return false</span>
                },
                /* 10 metricName &lt;- &lt;((('"' &lt;('∆'? '~'? (ALNUM / ((&amp;(',') ',') | (&amp;('/') '/') | (&amp;('.') '.') | (&amp;('_') '_') | (&amp;('-') '-') | (&amp;('~') '~')))+)&gt; '"') / &lt;('∆'? '~'? (ALNUM / ((&amp;(',') ',') | (&amp;('/') '/') | (&amp;('.') '.') | (&amp;('_') '_') | (&amp;('-') '-') | (&amp;('~') '~')))+)&gt;) Action6)&gt; */
                func() bool <span class="cov2" title="2">{
                        position84, tokenIndex84 := position, tokenIndex
                        </span><span class="cov2" title="2">{
                                position85 := position
                                </span><span class="cov2" title="2">{
                                        position86, tokenIndex86 := position, tokenIndex
                                        if buffer[position] != rune('"') </span><span class="cov2" title="2">{
                                                goto l87</span>
                                        }
                                        <span class="cov0" title="0">position++
                                        </span><span class="cov0" title="0">{
                                                position88 := position
                                                </span><span class="cov0" title="0">{
                                                        position89, tokenIndex89 := position, tokenIndex
                                                        if buffer[position] != rune('∆') </span><span class="cov0" title="0">{
                                                                goto l89</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        goto l90</span>
                                                l89:
                                                        <span class="cov0" title="0">position, tokenIndex = position89, tokenIndex89</span>
                                                }
                                        l90:
                                                <span class="cov0" title="0">{
                                                        position91, tokenIndex91 := position, tokenIndex
                                                        if buffer[position] != rune('~') </span><span class="cov0" title="0">{
                                                                goto l91</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        goto l92</span>
                                                l91:
                                                        <span class="cov0" title="0">position, tokenIndex = position91, tokenIndex91</span>
                                                }
                                        l92:
                                                <span class="cov0" title="0">{
                                                        position95, tokenIndex95 := position, tokenIndex
                                                        if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                goto l96</span>
                                                        }
                                                        <span class="cov0" title="0">goto l95</span>
                                                l96:
                                                        <span class="cov0" title="0">position, tokenIndex = position95, tokenIndex95
                                                        </span><span class="cov0" title="0">{
                                                                switch buffer[position] </span>{
                                                                case ',':<span class="cov0" title="0">
                                                                        if buffer[position] != rune(',') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '/':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '.':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '_':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '-':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                default:<span class="cov0" title="0">
                                                                        if buffer[position] != rune('~') </span><span class="cov0" title="0">{
                                                                                goto l87</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                }
                                                        }

                                                }
                                        l95:
                                        l93:
                                                <span class="cov0" title="0">{
                                                        position94, tokenIndex94 := position, tokenIndex
                                                        </span><span class="cov0" title="0">{
                                                                position98, tokenIndex98 := position, tokenIndex
                                                                if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                        goto l99</span>
                                                                }
                                                                <span class="cov0" title="0">goto l98</span>
                                                        l99:
                                                                <span class="cov0" title="0">position, tokenIndex = position98, tokenIndex98
                                                                </span><span class="cov0" title="0">{
                                                                        switch buffer[position] </span>{
                                                                        case ',':<span class="cov0" title="0">
                                                                                if buffer[position] != rune(',') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '/':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '.':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '_':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '-':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        default:<span class="cov0" title="0">
                                                                                if buffer[position] != rune('~') </span><span class="cov0" title="0">{
                                                                                        goto l94</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        }
                                                                }

                                                        }
                                                l98:
                                                        <span class="cov0" title="0">goto l93</span>
                                                l94:
                                                        <span class="cov0" title="0">position, tokenIndex = position94, tokenIndex94</span>
                                                }
                                                <span class="cov0" title="0">add(rulePegText, position88)</span>
                                        }
                                        <span class="cov0" title="0">if buffer[position] != rune('"') </span><span class="cov0" title="0">{
                                                goto l87</span>
                                        }
                                        <span class="cov0" title="0">position++
                                        goto l86</span>
                                l87:
                                        <span class="cov2" title="2">position, tokenIndex = position86, tokenIndex86
                                        </span><span class="cov2" title="2">{
                                                position101 := position
                                                </span><span class="cov2" title="2">{
                                                        position102, tokenIndex102 := position, tokenIndex
                                                        if buffer[position] != rune('∆') </span><span class="cov2" title="2">{
                                                                goto l102</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        goto l103</span>
                                                l102:
                                                        <span class="cov2" title="2">position, tokenIndex = position102, tokenIndex102</span>
                                                }
                                        l103:
                                                <span class="cov2" title="2">{
                                                        position104, tokenIndex104 := position, tokenIndex
                                                        if buffer[position] != rune('~') </span><span class="cov2" title="2">{
                                                                goto l104</span>
                                                        }
                                                        <span class="cov0" title="0">position++
                                                        goto l105</span>
                                                l104:
                                                        <span class="cov2" title="2">position, tokenIndex = position104, tokenIndex104</span>
                                                }
                                        l105:
                                                <span class="cov2" title="2">{
                                                        position108, tokenIndex108 := position, tokenIndex
                                                        if !_rules[ruleALNUM]() </span><span class="cov0" title="0">{
                                                                goto l109</span>
                                                        }
                                                        <span class="cov2" title="2">goto l108</span>
                                                l109:
                                                        <span class="cov0" title="0">position, tokenIndex = position108, tokenIndex108
                                                        </span><span class="cov0" title="0">{
                                                                switch buffer[position] </span>{
                                                                case ',':<span class="cov0" title="0">
                                                                        if buffer[position] != rune(',') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '/':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '.':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '_':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                case '-':<span class="cov0" title="0">
                                                                        if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                default:<span class="cov0" title="0">
                                                                        if buffer[position] != rune('~') </span><span class="cov0" title="0">{
                                                                                goto l84</span>
                                                                        }
                                                                        <span class="cov0" title="0">position++</span>
                                                                }
                                                        }

                                                }
                                        l108:
                                        l106:
                                                <span class="cov7" title="36">{
                                                        position107, tokenIndex107 := position, tokenIndex
                                                        </span><span class="cov7" title="36">{
                                                                position111, tokenIndex111 := position, tokenIndex
                                                                if !_rules[ruleALNUM]() </span><span class="cov4" title="6">{
                                                                        goto l112</span>
                                                                }
                                                                <span class="cov7" title="30">goto l111</span>
                                                        l112:
                                                                <span class="cov4" title="6">position, tokenIndex = position111, tokenIndex111
                                                                </span><span class="cov4" title="6">{
                                                                        switch buffer[position] </span>{
                                                                        case ',':<span class="cov0" title="0">
                                                                                if buffer[position] != rune(',') </span><span class="cov0" title="0">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '/':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('/') </span><span class="cov0" title="0">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '.':<span class="cov3" title="4">
                                                                                if buffer[position] != rune('.') </span><span class="cov0" title="0">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov3" title="4">position++</span>
                                                                        case '_':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('_') </span><span class="cov0" title="0">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        case '-':<span class="cov0" title="0">
                                                                                if buffer[position] != rune('-') </span><span class="cov0" title="0">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        default:<span class="cov2" title="2">
                                                                                if buffer[position] != rune('~') </span><span class="cov2" title="2">{
                                                                                        goto l107</span>
                                                                                }
                                                                                <span class="cov0" title="0">position++</span>
                                                                        }
                                                                }

                                                        }
                                                l111:
                                                        <span class="cov7" title="34">goto l106</span>
                                                l107:
                                                        <span class="cov2" title="2">position, tokenIndex = position107, tokenIndex107</span>
                                                }
                                                <span class="cov2" title="2">add(rulePegText, position101)</span>
                                        }
                                }
                        l86:
                                <span class="cov2" title="2">{
                                        add(ruleAction6, position)
                                }</span>
                                <span class="cov2" title="2">add(rulemetricName, position85)</span>
                        }
                        <span class="cov2" title="2">return true
                </span>l84:
                        <span class="cov0" title="0">position, tokenIndex = position84, tokenIndex84
                        return false</span>
                },
                /* 11 ALNUM &lt;- &lt;((&amp;('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&amp;('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&amp;('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))&gt; */
                func() bool <span class="cov8" title="59">{
                        position115, tokenIndex115 := position, tokenIndex
                        </span><span class="cov8" title="59">{
                                position116 := position
                                </span><span class="cov8" title="59">{
                                        switch buffer[position] </span>{
                                        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':<span class="cov1" title="1">
                                                if c := buffer[position]; c &lt; rune('0') || c &gt; rune('9') </span><span class="cov0" title="0">{
                                                        goto l115</span>
                                                }
                                                <span class="cov1" title="1">position++</span>
                                        case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':<span class="cov0" title="0">
                                                if c := buffer[position]; c &lt; rune('A') || c &gt; rune('Z') </span><span class="cov0" title="0">{
                                                        goto l115</span>
                                                }
                                                <span class="cov0" title="0">position++</span>
                                        default:<span class="cov8" title="58">
                                                if c := buffer[position]; c &lt; rune('a') || c &gt; rune('z') </span><span class="cov5" title="9">{
                                                        goto l115</span>
                                                }
                                                <span class="cov8" title="49">position++</span>
                                        }
                                }

                                <span class="cov8" title="50">add(ruleALNUM, position116)</span>
                        }
                        <span class="cov8" title="50">return true
                </span>l115:
                        <span class="cov5" title="9">position, tokenIndex = position115, tokenIndex115
                        return false</span>
                },
                /* 12 DIGIT &lt;- &lt;[0-9]&gt; */
                func() bool <span class="cov7" title="40">{
                        position118, tokenIndex118 := position, tokenIndex
                        </span><span class="cov7" title="40">{
                                position119 := position
                                if c := buffer[position]; c &lt; rune('0') || c &gt; rune('9') </span><span class="cov5" title="10">{
                                        goto l118</span>
                                }
                                <span class="cov7" title="30">position++
                                add(ruleDIGIT, position119)</span>
                        }
                        <span class="cov7" title="30">return true
                </span>l118:
                        <span class="cov5" title="10">position, tokenIndex = position118, tokenIndex118
                        return false</span>
                },
                /* 14 Action0 &lt;- &lt;{ p.Histogram = true }&gt; */
                nil,
                /* 15 Action1 &lt;- &lt;{ p.Tags = map[string]string{} }&gt; */
                nil,
                nil,
                /* 17 Action2 &lt;- &lt;{ p.currentTag = text }&gt; */
                nil,
                /* 18 Action3 &lt;- &lt;{ p.Tags[p.currentTag] = text }&gt; */
                nil,
                /* 19 Action4 &lt;- &lt;{ p.Timestamp = text }&gt; */
                nil,
                /* 20 Action5 &lt;- &lt;{ p.Value = text }&gt; */
                nil,
                /* 21 Action6 &lt;- &lt;{ p.Name = text }&gt; */
                nil,
        }
        <span class="cov2" title="2">p.rules = _rules
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import "sync"

type MetricStore struct {
        metrics     []*Metric
        metricsMu   *sync.Mutex
        badMetrics  []string
        badMetricMu *sync.Mutex
}

func NewMetricStore() *MetricStore <span class="cov0" title="0">{
        return &amp;MetricStore{
                metrics:     make([]*Metric, 0, 1024),
                metricsMu:   &amp;sync.Mutex{},
                badMetrics:  make([]string, 0, 1024),
                badMetricMu: &amp;sync.Mutex{},
        }
}</span>

func (s *MetricStore) Metrics() []*Metric <span class="cov0" title="0">{
        s.metricsMu.Lock()
        defer s.metricsMu.Unlock()
        cpy := make([]*Metric, len(s.metrics))
        copy(cpy, s.metrics)
        return cpy
}</span>

func (s *MetricStore) BadMetrics() []string <span class="cov0" title="0">{
        s.badMetricMu.Lock()
        defer s.badMetricMu.Unlock()
        cpy := make([]string, len(s.badMetrics))
        copy(cpy, s.badMetrics)
        return cpy
}</span>

func (s *MetricStore) LogMetric(metric *Metric) <span class="cov0" title="0">{
        s.metricsMu.Lock()
        defer s.metricsMu.Unlock()
        s.metrics = append(s.metrics, metric)
}</span>

func (s *MetricStore) LogBadMetric(metric string) <span class="cov0" title="0">{
        s.badMetricMu.Lock()
        defer s.badMetricMu.Unlock()
        s.badMetrics = append(s.badMetrics, metric)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2018-2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package main

import (
        "fmt"
        "net/http"
        _ "net/http/pprof"
        "os"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/experimental"

        intdiscovery "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"

        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/agent"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        kube_config "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/kubernetes"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/options"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/events"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/manager"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/processors"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary"

        kube_client "k8s.io/client-go/kubernetes"
        v1listers "k8s.io/client-go/listers/core/v1"
)

var (
        version     string
        commit      string
        discWatcher util.FileWatcher
)

func main() <span class="cov1" title="1">{
        log.SetFormatter(&amp;log.TextFormatter{})
        log.SetLevel(log.InfoLevel)
        log.SetOutput(os.Stdout)

        opt := options.Parse()

        if opt.Version </span><span class="cov0" title="0">{
                fmt.Println(fmt.Sprintf("version: %s\ncommit: %s", version, commit))
                os.Exit(0)
        }</span>

        <span class="cov1" title="1">switch opt.LogLevel </span>{
        case "trace":<span class="cov0" title="0">
                log.SetLevel(log.TraceLevel)</span>
        case "debug":<span class="cov0" title="0">
                log.SetLevel(log.DebugLevel)</span>
        case "warn":<span class="cov0" title="0">
                log.SetLevel(log.WarnLevel)</span>
        }

        <span class="cov1" title="1">log.Infof(strings.Join(os.Args, " "))
        log.Infof("wavefront-collector version %v", version)
        enableProfiling(opt.EnableProfiling)
        enableForcedGC(opt.ForceGC)

        preRegister(opt)
        cfg := loadConfigOrDie(opt.ConfigFile)
        cfg = convertOrDie(opt, cfg)
        ag := createAgentOrDie(cfg)
        registerListeners(ag, opt)
        waitForStop()</span>
}

func preRegister(opt *options.CollectorRunOptions) <span class="cov1" title="1">{
        util.SetAgentType(opt.AgentType)
        if util.GetNodeName() == "" &amp;&amp; util.ScrapeOnlyOwnNode() </span><span class="cov0" title="0">{
                log.Fatalf("missing environment variable %s", util.NodeNameEnvVar)
        }</span>

        <span class="cov1" title="1">setMaxProcs(opt)
        registerVersion()</span>
}

func createAgentOrDie(cfg *configuration.Config) *agent.Agent <span class="cov1" title="1">{
        experimental.DisableAll()
        for _, feature := range cfg.Experimental </span><span class="cov0" title="0">{
                experimental.EnableFeature(feature)
        }</span>

        // backwards compat: used by prometheus sources to format histogram metric names
        <span class="cov1" title="1">setEnvVar("omitBucketSuffix", strconv.FormatBool(cfg.OmitBucketSuffix))

        clusterName := cfg.ClusterName

        kubeClient := createKubeClientOrDie(*cfg.Sources.SummaryConfig)
        if cfg.Sources.StateConfig != nil </span><span class="cov1" title="1">{
                cfg.Sources.StateConfig.KubeClient = kubeClient
        }</span>

        // create sources manager
        <span class="cov1" title="1">sourceManager := sources.Manager()
        sourceManager.SetDefaultCollectionInterval(cfg.DefaultCollectionInterval)
        err := sourceManager.BuildProviders(*cfg.Sources)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create source manager: %v", err)
        }</span>

        // create sink managers
        <span class="cov1" title="1">setInternalSinkProperties(cfg)
        sinkManager := createSinkManagerOrDie(cfg.Sinks, cfg.SinkExportDataTimeout)

        // Events
        var eventRouter *events.EventRouter
        if cfg.EnableEvents </span><span class="cov0" title="0">{
                events.Log.Info("Events collection enabled")
                eventRouter = events.NewEventRouter(kubeClient, cfg.EventsConfig, sinkManager, cfg.ScrapeCluster)
        }</span> else<span class="cov1" title="1"> {
                events.Log.Info("Events collection disabled")
        }</span>

        <span class="cov1" title="1">podLister := getPodListerOrDie(kubeClient)

        dm := createDiscoveryManagerOrDie(kubeClient, cfg, sourceManager, sourceManager, podLister)

        dataProcessors := createDataProcessorsOrDie(kubeClient, clusterName, podLister, cfg)
        man, err := manager.NewFlushManager(dataProcessors, sinkManager, cfg.FlushInterval)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create main manager: %v", err)
        }</span>

        // start leader-election
        <span class="cov1" title="1">if cfg.ScrapeCluster </span><span class="cov1" title="1">{
                _, err = leadership.Subscribe(kubeClient.CoreV1(), "agent")
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start leader election: %v", err)
        }</span>

        // create and start agent
        <span class="cov1" title="1">ag := agent.NewAgent(man, dm, eventRouter)
        ag.Start()
        return ag</span>
}

func loadConfigOrDie(file string) *configuration.Config <span class="cov1" title="1">{
        if file == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">log.Infof("loading config: %s", file)

        cfg, err := configuration.FromFile(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error parsing configuration: %v", err)
                return nil
        }</span>
        <span class="cov1" title="1">fillDefaults(cfg)

        if err := validateCfg(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("invalid configuration file: %v", err)
                return nil
        }</span>

        <span class="cov1" title="1">return cfg</span>
}

// use defaults if no values specified in config file
func fillDefaults(cfg *configuration.Config) <span class="cov1" title="1">{
        if cfg.FlushInterval == 0 </span><span class="cov0" title="0">{
                cfg.FlushInterval = 60 * time.Second
        }</span>
        <span class="cov1" title="1">if cfg.DefaultCollectionInterval == 0 </span><span class="cov0" title="0">{
                cfg.DefaultCollectionInterval = 60 * time.Second
        }</span>
        <span class="cov1" title="1">if cfg.SinkExportDataTimeout == 0 </span><span class="cov1" title="1">{
                cfg.SinkExportDataTimeout = 20 * time.Second
        }</span>
        <span class="cov1" title="1">if cfg.ClusterName == "" </span><span class="cov0" title="0">{
                cfg.ClusterName = "k8s-cluster"
        }</span>
        <span class="cov1" title="1">if cfg.DiscoveryConfig.DiscoveryInterval == 0 </span><span class="cov1" title="1">{
                cfg.DiscoveryConfig.DiscoveryInterval = 5 * time.Minute
        }</span>

        <span class="cov1" title="1">cfg.ScrapeCluster = util.ScrapeCluster()</span>
}

// converts flags to configuration for backwards compatibility support
func convertOrDie(opt *options.CollectorRunOptions, cfg *configuration.Config) *configuration.Config <span class="cov1" title="1">{
        // omit flags if config file is provided
        if cfg != nil </span><span class="cov1" title="1">{
                log.Info("using configuration file, omitting flags")
                return cfg
        }</span>
        <span class="cov0" title="0">optsCfg, err := opt.Convert()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error converting flags to config: %v", err)
        }</span>
        <span class="cov0" title="0">fillDefaults(optsCfg)
        return optsCfg</span>
}

func setInternalSinkProperties(cfg *configuration.Config) <span class="cov1" title="1">{
        log.Infof("using clusterName: %s", cfg.ClusterName)
        prefix := ""
        if cfg.Sources.StatsConfig != nil </span><span class="cov1" title="1">{
                prefix = configuration.GetStringValue(cfg.Sources.StatsConfig.Prefix, "kubernetes.")
        }</span>
        <span class="cov1" title="1">version := getVersion()
        for _, sink := range cfg.Sinks </span><span class="cov1" title="1">{
                sink.ClusterName = cfg.ClusterName
                sink.InternalStatsPrefix = prefix
                sink.Version = version
                sink.EventsEnabled = cfg.EnableEvents
        }</span>
}

func registerListeners(ag *agent.Agent, opt *options.CollectorRunOptions) <span class="cov1" title="1">{
        handler := &amp;reloader{ag: ag}
        if opt.ConfigFile != "" </span><span class="cov1" title="1">{
                listener := configuration.NewFileListener(handler)
                watcher := util.NewFileWatcher(opt.ConfigFile, listener, 30*time.Second)
                watcher.Watch()
        }</span>
}

func createDiscoveryManagerOrDie(
        client *kube_client.Clientset,
        cfg *configuration.Config,
        handler metrics.ProviderHandler,
        internalPluginConfigProvider intdiscovery.PluginProvider,
        podLister v1listers.PodLister,
) *discovery.Manager <span class="cov1" title="1">{
        if cfg.EnableDiscovery </span><span class="cov1" title="1">{
                serviceLister := getServiceListerOrDie(client)
                nodeLister := getNodeListerOrDie(client)

                return discovery.NewDiscoveryManager(discovery.RunConfig{
                        KubeClient:             client,
                        DiscoveryConfig:        cfg.DiscoveryConfig,
                        Handler:                handler,
                        InternalPluginProvider: internalPluginConfigProvider,
                        Lister:                 discovery.NewResourceLister(podLister, serviceLister, nodeLister),
                        ScrapeCluster:          cfg.ScrapeCluster,
                })
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func registerVersion() <span class="cov1" title="1">{
        version := getVersion()
        m := gm.GetOrRegisterGaugeFloat64("version", gm.DefaultRegistry)
        m.Update(version)
}</span>

func getVersion() float64 <span class="cov10" title="2">{
        parts := strings.Split(version, ".")
        friendly := fmt.Sprintf("%s.%s%s", parts[0], parts[1], parts[2])
        f, err := strconv.ParseFloat(friendly, 2)
        if err != nil </span><span class="cov0" title="0">{
                f = 0.0
        }</span>
        <span class="cov10" title="2">return f</span>
}

func createSinkManagerOrDie(cfgs []*configuration.WavefrontSinkConfig, sinkExportDataTimeout time.Duration) wavefront.WavefrontSink <span class="cov1" title="1">{
        sinksFactory := sinks.NewSinkFactory()
        sinkList := sinksFactory.BuildAll(cfgs)

        for _, sink := range sinkList </span><span class="cov1" title="1">{
                log.Infof("Starting with %s", sink.Name())
        }</span>
        <span class="cov1" title="1">sinkManager, err := sinks.NewSinkManager(sinkList, sinkExportDataTimeout, sinks.DefaultSinkStopTimeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create sink manager: %v", err)
        }</span>
        <span class="cov1" title="1">return sinkManager</span>
}

func getPodListerOrDie(kubeClient *kube_client.Clientset) v1listers.PodLister <span class="cov1" title="1">{
        podLister, err := util.GetPodLister(kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create podLister: %v", err)
        }</span>
        <span class="cov1" title="1">return podLister</span>
}

func createKubeClientOrDie(cfg configuration.SummarySourceConfig) *kube_client.Clientset <span class="cov1" title="1">{
        kubeConfig, err := kube_config.GetKubeClientConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get client config: %v", err)
        }</span>
        <span class="cov1" title="1">return kube_client.NewForConfigOrDie(kubeConfig)</span>
}

func createDataProcessorsOrDie(kubeClient *kube_client.Clientset, cluster string, podLister v1listers.PodLister, cfg *configuration.Config) []metrics.Processor <span class="cov1" title="1">{

        labelCopier, err := util.NewLabelCopier(",", []string{}, []string{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize label copier: %v", err)
        }</span>

        <span class="cov1" title="1">dataProcessors := []metrics.Processor{
                processors.NewRateCalculator(metrics.RateMetricsMapping),
                processors.NewDistributionRateCalculator(),
                processors.NewCumulativeDistributionConverter(),
        }

        collectionInterval := calculateCollectionInterval(cfg)
        podBasedEnricher := processors.NewPodBasedEnricher(podLister, labelCopier, collectionInterval)
        dataProcessors = append(dataProcessors, podBasedEnricher)

        namespaceBasedEnricher, err := processors.NewNamespaceBasedEnricher(kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create NamespaceBasedEnricher: %v", err)
        }</span>
        <span class="cov1" title="1">dataProcessors = append(dataProcessors, namespaceBasedEnricher)

        metricsToAggregate := []string{
                metrics.MetricCpuUsageRate.Name,
                metrics.MetricMemoryUsage.Name,
                metrics.MetricCpuRequest.Name,
                metrics.MetricCpuLimit.Name,
                metrics.MetricMemoryRequest.Name,
                metrics.MetricMemoryLimit.Name,
        }

        metricsToAggregateForNode := []string{
                metrics.MetricCpuRequest.Name,
                metrics.MetricCpuLimit.Name,
                metrics.MetricMemoryRequest.Name,
                metrics.MetricMemoryLimit.Name,
                metrics.MetricEphemeralStorageRequest.Name,
                metrics.MetricEphemeralStorageLimit.Name,
        }

        dataProcessors = append(dataProcessors,
                processors.NewPodAggregator(),
                processors.NewNamespaceAggregator(metricsToAggregate),
                processors.NewNodeAggregator(metricsToAggregateForNode),
                processors.NewClusterAggregator(metricsToAggregate),
        )

        nodeAutoscalingEnricher, err := processors.NewNodeAutoscalingEnricher(kubeClient, labelCopier)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create NodeAutoscalingEnricher: %v", err)
        }</span>
        <span class="cov1" title="1">dataProcessors = append(dataProcessors, nodeAutoscalingEnricher)

        // this always needs to be the last processor
        wavefrontCoverter, err := summary.NewPointConverter(*cfg.Sources.SummaryConfig, cluster)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WavefrontPointConverter: %v", err)
        }</span>
        <span class="cov1" title="1">dataProcessors = append(dataProcessors, wavefrontCoverter)

        return dataProcessors</span>
}

func calculateCollectionInterval(cfg *configuration.Config) time.Duration <span class="cov1" title="1">{
        collectionInterval := cfg.DefaultCollectionInterval
        if cfg.Sources.SummaryConfig.Collection.Interval &gt; 0 </span><span class="cov0" title="0">{
                collectionInterval = cfg.Sources.SummaryConfig.Collection.Interval
        }</span>
        <span class="cov1" title="1">return collectionInterval</span>
}

func getServiceListerOrDie(kubeClient *kube_client.Clientset) v1listers.ServiceLister <span class="cov1" title="1">{
        serviceLister, err := util.GetServiceLister(kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create serviceLister: %v", err)
        }</span>
        <span class="cov1" title="1">return serviceLister</span>
}

func getNodeListerOrDie(kubeClient *kube_client.Clientset) v1listers.NodeLister <span class="cov1" title="1">{
        nodeLister, _, err := util.GetNodeLister(kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create nodeLister: %v", err)
        }</span>
        <span class="cov1" title="1">return nodeLister</span>
}

func validateCfg(cfg *configuration.Config) error <span class="cov1" title="1">{
        if cfg.FlushInterval &lt; 5*time.Second </span><span class="cov0" title="0">{
                return fmt.Errorf("metric resolution should not be less than 5 seconds: %d", cfg.FlushInterval)
        }</span>
        <span class="cov1" title="1">if cfg.Sources == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing sources")
        }</span>
        <span class="cov1" title="1">if cfg.Sources.SummaryConfig == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubernetes_source is missing")
        }</span>
        <span class="cov1" title="1">if len(cfg.Sinks) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing sink")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func setMaxProcs(opt *options.CollectorRunOptions) <span class="cov1" title="1">{
        // Allow as many threads as we have cores unless the user specified a value.
        var numProcs int
        if opt.MaxProcs &lt; 1 </span><span class="cov1" title="1">{
                numProcs = runtime.NumCPU()
                if numProcs == 1 </span><span class="cov0" title="0">{
                        // default to 2
                        numProcs = 2
                }</span>
        } else<span class="cov0" title="0"> {
                numProcs = opt.MaxProcs
        }</span>
        <span class="cov1" title="1">runtime.GOMAXPROCS(numProcs)

        // Check if the setting was successful.
        actualNumProcs := runtime.GOMAXPROCS(0)
        if actualNumProcs != numProcs </span><span class="cov0" title="0">{
                log.Warningf("Specified max procs of %d but using %d", numProcs, actualNumProcs)
        }</span>
}

func enableProfiling(enable bool) <span class="cov1" title="1">{
        if enable </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        log.Info("Starting pprof server at: http://localhost:9090/debug/pprof")
                        if err := http.ListenAndServe("localhost:9090", nil); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("E! %v", err)
                        }</span>
                }()
        }
}

func enableForcedGC(enable bool) <span class="cov1" title="1">{
        if enable </span><span class="cov0" title="0">{
                log.Info("enabling forced garbage collection")
                setEnvVar(util.ForceGC, "true")
        }</span>
}

func setEnvVar(key, val string) <span class="cov1" title="1">{
        err := os.Setenv(key, val)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error setting environment variable %s: %v", key, err)
        }</span>
}

func waitForStop() <span class="cov1" title="1">{
        select </span>{}
}

type reloader struct {
        mtx sync.Mutex
        ag  *agent.Agent
        opt *options.CollectorRunOptions
}

// Handles changes to collector or discovery configuration
func (r *reloader) Handle(cfg interface{}) <span class="cov0" title="0">{
        r.mtx.Lock()
        defer r.mtx.Unlock()

        switch cfg.(type) </span>{
        case *configuration.Config:<span class="cov0" title="0">
                r.handleCollectorCfg(cfg.(*configuration.Config))</span>
        }
}

func (r *reloader) handleCollectorCfg(cfg *configuration.Config) <span class="cov0" title="0">{
        log.Infof("collector configuration changed")

        fillDefaults(cfg)

        // stop the previous agent and start a new agent
        r.ag.Stop()
        r.ag = createAgentOrDie(cfg)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package agent

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/events"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/manager"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources"
)

type Agent struct {
        pm manager.FlushManager
        dm *discovery.Manager
        er *events.EventRouter
}

func NewAgent(pm manager.FlushManager, dm *discovery.Manager, er *events.EventRouter) *Agent <span class="cov8" title="1">{
        return &amp;Agent{
                pm: pm,
                dm: dm,
                er: er,
        }
}</span>

func (a *Agent) Start() <span class="cov8" title="1">{
        log.Infof("Starting agent")
        a.pm.Start()
        if a.dm != nil </span><span class="cov8" title="1">{
                a.dm.Start()
        }</span>

        <span class="cov8" title="1">if a.er != nil </span><span class="cov0" title="0">{
                log.Infof("Starting Events collector")
                a.er.Start()
                log.Infof("Done Starting Events collector")
        }</span>
}

func (a *Agent) Stop() <span class="cov0" title="0">{
        log.Infof("Stopping agent")
        a.pm.Stop()
        if a.dm != nil </span><span class="cov0" title="0">{
                a.dm.Stop()
        }</span>

        <span class="cov0" title="0">if a.er != nil </span><span class="cov0" title="0">{
                log.Infof("Stopping Events collector")
                a.er.Stop()
                log.Infof("Done Stopping Events collector")
        }</span>

        <span class="cov0" title="0">sources.Manager().StopProviders()
        log.Infof("Agent stopped")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package configuration

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
)

type listener struct {
        handler util.ConfigHandler
}

func NewFileListener(handler util.ConfigHandler) util.FileListener <span class="cov8" title="1">{
        return &amp;listener{handler: handler}
}</span>

func (l *listener) Changed(file string) <span class="cov0" title="0">{
        cfg, err := FromFile(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error loading configuration: %v", err)
        }</span> else<span class="cov0" title="0"> {
                l.handler.Handle(cfg)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package configuration

import (
        "fmt"
        "io/ioutil"

        "gopkg.in/yaml.v2"
)

// FromFile loads the configuration from a given file
func FromFile(filename string) (*Config, error) <span class="cov8" title="1">{
        contents, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to load configuration file: %v", err)
        }</span>
        <span class="cov8" title="1">return FromYAML(contents)</span>
}

// FromYAML loads the configuration from a blob of YAML.
func FromYAML(contents []byte) (*Config, error) <span class="cov8" title="1">{
        var cfg Config
        if err := yaml.UnmarshalStrict(contents, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse configuration: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package configuration

import "time"

func GetStringValue(value, defaultValue string) string <span class="cov9" title="8">{
        if value != "" </span><span class="cov10" title="9">{
                return value
        }</span>
        <span class="cov8" title="7">return defaultValue</span>
}

func GetDurationValue(value, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value != 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019-2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "fmt"
        "strings"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"

        gm "github.com/rcrowley/go-metrics"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"
)

type ProviderInfo struct {
        Handler metrics.ProviderHandler
        Factory metrics.ProviderFactory
        Encoder Encoder
}

type defaultEndpointHandler struct {
        providers map[string]ProviderInfo
        counts    map[string]gm.Counter
}

func NewEndpointHandler(providers map[string]ProviderInfo) EndpointHandler <span class="cov1" title="1">{
        counts := make(map[string]gm.Counter, len(providers))
        for k := range providers </span><span class="cov3" title="2">{
                key := reporting.EncodeKey("discovery.targets.registered", map[string]string{"type": k})
                counts[k] = gm.GetOrRegisterCounter(key, gm.DefaultRegistry)
        }</span>
        <span class="cov1" title="1">return &amp;defaultEndpointHandler{
                providers: providers,
                counts:    counts,
        }</span>
}

func (d *defaultEndpointHandler) Add(ep *Endpoint) <span class="cov10" title="9">{
        if delegate, ok := d.providers[ep.PluginType]; ok </span><span class="cov10" title="9">{
                provider, err := delegate.Factory.Build(ep.Config)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                        return
                }</span>
                <span class="cov10" title="9">delegate.Handler.AddProvider(provider)
                d.counts[ep.PluginType].Inc(1)</span>
        } else<span class="cov0" title="0"> {
                log.WithFields(log.Fields{
                        "endpoint": ep.Name,
                        "type":     ep.PluginType,
                }).Error("failed to add endpoint")
        }</span>
}

func (d *defaultEndpointHandler) Delete(ep *Endpoint) <span class="cov0" title="0">{
        log.WithFields(log.Fields{
                "endpoint": ep.Name,
                "type":     ep.PluginType,
        }).Debug("deleting endpoint")

        if delegate, ok := d.providers[ep.PluginType]; ok </span><span class="cov0" title="0">{
                name := fmt.Sprintf("%s: %s", delegate.Factory.Name(), ep.Name)
                delegate.Handler.DeleteProvider(name)
                d.counts[ep.PluginType].Dec(1)
        }</span> else<span class="cov0" title="0"> {
                log.WithFields(log.Fields{
                        "endpoint": ep.Name,
                        "type":     ep.PluginType,
                }).Error("failed to delete endpoint")
        }</span>
}

func pluginType(plugin PluginConfig) string <span class="cov0" title="0">{
        if strings.Contains(plugin.Type, "prometheus") </span><span class="cov0" title="0">{
                return "prometheus"
        }</span> else<span class="cov0" title="0"> if strings.Contains(plugin.Type, "telegraf") </span><span class="cov0" title="0">{
                return "telegraf"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func FakeService(name, namespace, ip string) *v1.Service <span class="cov0" title="0">{
        service := v1.Service{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Spec: v1.ServiceSpec{
                        ClusterIP: ip,
                },
        }
        return &amp;service
}</span>

func FakePod(name, namespace, ip string) *v1.Pod <span class="cov0" title="0">{
        pod := v1.Pod{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Status: v1.PodStatus{
                        PodIP: ip,
                },
        }
        return &amp;pod
}</span>

type FakeDiscoverer struct{}

func (f *FakeDiscoverer) Discover(resource Resource) {<span class="cov0" title="0">}</span>
func (f *FakeDiscoverer) Delete(resource Resource)   {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        log "github.com/sirupsen/logrus"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func ResourceName(kind string, meta metav1.ObjectMeta) string <span class="cov10" title="4">{
        if meta.Namespace != "" </span><span class="cov10" title="4">{
                return meta.Namespace + "-" + kind + "-" + meta.Name
        }</span>
        <span class="cov8" title="3">return kind + "-" + meta.Name</span>
}

// converts deprecated prometheus configs to plugin configs
func ConvertPromToPlugin(cfg *Config) <span class="cov0" title="0">{
        // convert PrometheusConfigs to PluginConfigs
        if len(cfg.PromConfigs) &gt; 0 </span><span class="cov0" title="0">{
                log.Warningf("Warning: PrometheusConfig has been deprecated. Use PluginConfig.")
                toAppend := make([]PluginConfig, len(cfg.PromConfigs))
                for i, promCfg := range cfg.PromConfigs </span><span class="cov0" title="0">{
                        toAppend[i] = PluginConfig{
                                Name:          promCfg.Name,
                                Type:          "prometheus",
                                Port:          promCfg.Port,
                                Scheme:        promCfg.Scheme,
                                Path:          promCfg.Path,
                                Source:        promCfg.Source,
                                Prefix:        promCfg.Prefix,
                                Tags:          promCfg.Tags,
                                IncludeLabels: promCfg.IncludeLabels,
                                Filters:       promCfg.Filters,
                                Selectors: Selectors{
                                        ResourceType: promCfg.ResourceType,
                                },
                        }

                        if len(promCfg.Namespace) &gt; 0 </span><span class="cov0" title="0">{
                                toAppend[i].Selectors.Namespaces = []string{promCfg.Namespace}
                        }</span>

                        <span class="cov0" title="0">if len(promCfg.Labels) &gt; 0 </span><span class="cov0" title="0">{
                                labels := map[string][]string{}
                                for k, v := range promCfg.Labels </span><span class="cov0" title="0">{
                                        labels[k] = []string{v}
                                }</span>
                                <span class="cov0" title="0">toAppend[i].Selectors.Labels = labels</span>
                        }
                }
                <span class="cov0" title="0">cfg.PluginConfigs = append(cfg.PluginConfigs, toAppend...)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
)

type listener struct {
        handler util.ConfigHandler
}

func NewFileListener(handler util.ConfigHandler) util.FileListener <span class="cov0" title="0">{
        return &amp;listener{handler: handler}
}</span>

func (l *listener) Changed(file string) <span class="cov0" title="0">{
        cfg, err := FromFile(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error loading discovery config: %v", err)
        }</span> else<span class="cov0" title="0"> {
                l.handler.Handle(cfg)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "fmt"
        "io/ioutil"
        "os"

        "gopkg.in/yaml.v2"
)

func FromFile(filename string) (*Config, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        defer file.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to load discovery config file: %v", err)
        }</span>
        <span class="cov0" title="0">contents, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to load discovery config file: %v", err)
        }</span>
        <span class="cov0" title="0">return FromYAML(contents)</span>
}

// FromYAML loads the configuration from a blob of YAML.
func FromYAML(contents []byte) (*Config, error) <span class="cov10" title="3">{
        var cfg Config
        if err := yaml.UnmarshalStrict(contents, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to parse discovery config: %v", err)
        }</span>
        <span class="cov10" title="3">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "fmt"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        PrefixAnnotation = "wavefront.com/prefix"
        LabelsAnnotation = "wavefront.com/includeLabels"
)

type ResourceType int

const (
        PodType     ResourceType = 1
        ServiceType ResourceType = 2
        NodeType    ResourceType = 3
)

func (resType ResourceType) String() string <span class="cov5" title="6">{
        switch resType </span>{
        case PodType:<span class="cov10" title="28">
                return "pod"</span>
        case ServiceType:<span class="cov5" title="5">
                return "service"</span>
        case NodeType:<span class="cov6" title="9">
                return "node"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%d", int(resType))</span>
        }
}

// Resource encapsulates metadata about a Kubernetes resource
type Resource struct {
        Kind   string
        IP     string
        Meta   metav1.ObjectMeta
        Status string

        // list of containers for a pod resource
        Containers []v1.Container
}

// Discoverer discovers endpoints from resources based on rules or annotations
type Discoverer interface {
        Discover(resource Resource)
        Delete(resource Resource)
        DeleteAll()
        Stop()
}

// Encoder generates a configuration to collect data from a given resource based on the given rules
type Encoder interface {
        Encode(ip, kind string, meta metav1.ObjectMeta, rule interface{}) (string, interface{}, bool)
}

// ResourceLister lists kubernetes resources based on custom criteria
type ResourceLister interface {
        ListPods(ns string, labels map[string]string) ([]*v1.Pod, error)
        ListServices(ns string, labels map[string]string) ([]*v1.Service, error)
        ListNodes() ([]*v1.Node, error)
}

// Endpoint captures the data around a specific endpoint to collect data from
type Endpoint struct {
        Name       string
        PluginType string
        Config     interface{}
}

// EndpointHandler handles the configuration of a source to collect data from discovered endpoints
type EndpointHandler interface {
        Add(ep *Endpoint)
        Delete(ep *Endpoint)
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package utils

import (
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func EncodeTags(destTags map[string]string, prefix string, tags map[string]string) <span class="cov5" title="6">{
        if len(tags) == 0 </span><span class="cov5" title="9">{
                return
        }</span>
        <span class="cov5" title="9">for k, v := range tags </span><span class="cov8" title="27">{
                if k != "pod-template-hash" &amp;&amp; len(k) &gt; 0 &amp;&amp; len(v) &gt; 0 </span><span class="cov7" title="22">{
                        key := fmt.Sprintf("%s%s", prefix, k)
                        destTags[key] = v
                }</span>
        }
}

func EncodeMeta(tags map[string]string, kind string, meta metav1.ObjectMeta) <span class="cov5" title="9">{
        tags[kind] = meta.Name
        if meta.Namespace != "" </span><span class="cov5" title="9">{
                tags["namespace"] = meta.Namespace
        }</span>
}

func Param(meta metav1.ObjectMeta, annotation, cfgVal, defaultVal string) string <span class="cov9" title="39">{
        value := ""
        // give precedence to annotation
        if annotation != "" </span><span class="cov9" title="39">{
                value = meta.GetAnnotations()[annotation]
        }</span>
        <span class="cov9" title="39">if value == "" </span><span class="cov8" title="30">{
                // then config
                value = cfgVal
        }</span>
        <span class="cov9" title="39">if value == "" </span><span class="cov10" title="56">{
                // then default
                value = defaultVal
        }</span>
        <span class="cov9" title="39">return value</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package experimental

import (
        "sync"
)

const HistogramConversion = "histogram-conversion"

var (
        mu      sync.RWMutex
        enabled = map[string]bool{}
)

func IsEnabled(name string) bool <span class="cov10" title="4">{
        mu.RLock()
        isEnabled := enabled[name]
        mu.RUnlock()
        return isEnabled
}</span>

func EnableFeature(name string) <span class="cov5" title="2">{
        mu.Lock()
        enabled[name] = true
        mu.Unlock()
}</span>

func DisableFeature(name string) <span class="cov5" title="2">{
        mu.Lock()
        delete(enabled, name)
        mu.Unlock()
}</span>

func DisableAll() <span class="cov1" title="1">{
        mu.Lock()
        enabled = map[string]bool{}
        mu.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package filter

const (
        MetricWhitelist    = "metricWhitelist"
        MetricBlacklist    = "metricBlacklist"
        MetricTagWhitelist = "metricTagWhitelist"
        MetricTagBlacklist = "metricTagBlacklist"
        TagInclude         = "tagInclude"
        TagExclude         = "tagExclude"
)

// Configuration for filtering metrics.
// All the filtering options are applied at the end after specified prefixes etc are applied.
type Config struct {
        // List of glob pattern strings. Only metrics with names matching this list are reported.
        MetricAllowList []string `yaml:"metricAllowList"`

        // List of glob pattern strings. Metrics with names matching this list are dropped.
        MetricDenyList []string `yaml:"metricDenyList"`

        // List of glob pattern strings. Only metrics containing tag keys matching the list will be reported.
        MetricTagAllowList map[string][]string `yaml:"metricTagAllowList"`

        // List of glob pattern strings. Metrics containing these tag keys will be dropped.
        MetricTagDenyList map[string][]string `yaml:"metricTagDenyList"`

        // List of glob pattern strings. Tags with matching keys will be included. All other tags will be excluded.
        TagInclude []string `yaml:"tagInclude"`

        // List of glob pattern strings. Tags with matching keys will be excluded.
        TagExclude []string `yaml:"tagExclude"`

        // Deprecated: use MetricAllowList instead
        MetricWhitelist []string `yaml:"metricWhitelist"`

        // Deprecated: use MetricDenyList instead
        MetricBlacklist []string `yaml:"metricBlacklist"`

        // Deprecated: use MetricTagAllowList instead
        MetricTagWhitelist map[string][]string `yaml:"metricTagWhitelist"`

        // Deprecated: use MetricTagDenyList instead
        MetricTagBlacklist map[string][]string `yaml:"metricTagBlacklist"`
}

func (cfg Config) Empty() bool <span class="cov10" title="6">{
        return len(cfg.MetricWhitelist) == 0 &amp;&amp; len(cfg.MetricAllowList) == 0 &amp;&amp;
                len(cfg.MetricBlacklist) == 0 &amp;&amp; len(cfg.MetricDenyList) == 0 &amp;&amp;
                len(cfg.MetricTagWhitelist) == 0 &amp;&amp; len(cfg.MetricTagAllowList) == 0 &amp;&amp;
                len(cfg.MetricTagBlacklist) == 0 &amp;&amp; len(cfg.MetricTagDenyList) == 0 &amp;&amp;
                len(cfg.TagInclude) == 0 &amp;&amp; len(cfg.TagExclude) == 0
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package filter

import (
        "strings"

        "github.com/gobwas/glob"
)

type Filter interface {
        MatchMetric(name string, tags map[string]string) bool
        MatchTag(tagName string) bool
}

type globFilter struct {
        metricAllowList    glob.Glob
        metricDenyList     glob.Glob
        metricTagAllowList map[string]glob.Glob
        metricTagDenyList  map[string]glob.Glob
        tagInclude         glob.Glob
        tagExclude         glob.Glob
}

func NewGlobFilter(cfg Config) Filter <span class="cov2" title="7">{
        return &amp;globFilter{
                metricAllowList:    Compile(cfg.MetricAllowList),
                metricDenyList:     Compile(cfg.MetricDenyList),
                metricTagAllowList: MultiCompile(cfg.MetricTagAllowList),
                metricTagDenyList:  MultiCompile(cfg.MetricTagDenyList),
                tagInclude:         Compile(cfg.TagInclude),
                tagExclude:         Compile(cfg.TagExclude),
        }
}</span>

func Compile(filters []string) glob.Glob <span class="cov4" title="98">{
        if len(filters) == 0 </span><span class="cov2" title="8">{
                return nil
        }</span>
        <span class="cov2" title="9">if len(filters) == 1 </span><span class="cov2" title="9">{
                g, _ := glob.Compile(filters[0])
                return g
        }</span>
        <span class="cov2" title="9">g, _ := glob.Compile("{" + strings.Join(filters, ",") + "}")
        return g</span>
}

func MultiCompile(filters map[string][]string) map[string]glob.Glob <span class="cov2" title="8">{
        if len(filters) == 0 </span><span class="cov2" title="9">{
                return nil
        }</span>
        <span class="cov2" title="9">globs := make(map[string]glob.Glob, len(filters))
        for k, v := range filters </span><span class="cov1" title="4">{
                g := Compile(v)
                if g != nil </span><span class="cov1" title="4">{
                        globs[k] = g
                }</span>
        }
        <span class="cov2" title="9">return globs</span>
}

func MultiSetCompile(filters []map[string][]string) []map[string]glob.Glob <span class="cov2" title="16">{
        if len(filters) == 0 </span><span class="cov2" title="12">{
                return nil
        }</span>
        <span class="cov1" title="4">globs := make([]map[string]glob.Glob, len(filters))
        for i, f := range filters </span><span class="cov1" title="4">{
                globs[i] = MultiCompile(f)
        }</span>
        <span class="cov1" title="4">return globs</span>
}

func (gf *globFilter) MatchMetric(name string, tags map[string]string) bool <span class="cov2" title="9">{
        if gf.metricAllowList != nil &amp;&amp; !gf.metricAllowList.Match(name) </span><span class="cov2" title="7">{
                return false
        }</span>
        <span class="cov2" title="8">if gf.metricDenyList != nil &amp;&amp; gf.metricDenyList.Match(name) </span><span class="cov3" title="82">{
                return false
        }</span>

        <span class="cov2" title="8">if gf.metricTagAllowList != nil &amp;&amp; !MatchesTags(gf.metricTagAllowList, tags) </span><span class="cov2" title="7">{
                return false
        }</span>
        <span class="cov2" title="8">if gf.metricTagDenyList != nil &amp;&amp; MatchesTags(gf.metricTagDenyList, tags) </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov2" title="8">return true</span>
}

func (gf *globFilter) MatchTag(tagName string) bool <span class="cov3" title="80">{
        matches := true
        if gf.tagInclude != nil </span><span class="cov2" title="8">{
                matches = matches &amp;&amp; gf.tagInclude.Match(tagName)
        }</span>
        <span class="cov3" title="80">if gf.tagExclude != nil </span><span class="cov10" title="923376">{
                matches = matches &amp;&amp; !gf.tagExclude.Match(tagName)
        }</span>
        <span class="cov3" title="80">return matches</span>
}

func MatchesTags(matchers map[string]glob.Glob, tags map[string]string) bool <span class="cov2" title="9">{
        for k, matcher := range matchers </span><span class="cov2" title="8">{
                if val, ok := tags[k]; ok </span><span class="cov2" title="8">{
                        if matcher.Match(val) </span><span class="cov6" title="7430">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="54990">return false</span>
}

func MatchesAllTags(matchers map[string]glob.Glob, tags map[string]string) bool <span class="cov2" title="8">{
        for k, matcher := range matchers </span><span class="cov2" title="5">{
                if val, ok := tags[k]; ok </span><span class="cov1" title="4">{
                        if !matcher.Match(val) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov1" title="4"> {
                        return false
                }</span>
        }
        <span class="cov1" title="4">return true</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package filter

import (
        "fmt"
        "strings"
)

func FromQuery(vals map[string][]string) Config <span class="cov7" title="8">{
        if len(vals) == 0 </span><span class="cov1" title="1">{
                return Config{}
        }</span>

        // this is legacy code retained for backwards compat when using CLI flags (instead of config file)
        // newer terminology (allow/deny) has not been back ported for now. This function and associated calls
        // can just be deleted once we choose to stop supporting the older CLI flags method for good.

        <span class="cov7" title="8">metricWhitelist := vals[MetricWhitelist]
        metricBlacklist := vals[MetricBlacklist]
        metricTagWhitelist := parseFilters(vals[MetricTagWhitelist])
        metricTagBlacklist := parseFilters(vals[MetricTagBlacklist])
        tagInclude := vals[TagInclude]
        tagExclude := vals[TagExclude]

        if len(metricWhitelist) == 0 &amp;&amp; len(metricBlacklist) == 0 &amp;&amp; len(metricTagWhitelist) == 0 &amp;&amp;
                len(metricTagBlacklist) == 0 &amp;&amp; len(tagInclude) == 0 &amp;&amp; len(tagExclude) == 0 </span><span class="cov7" title="7">{
                return Config{}
        }</span>

        <span class="cov1" title="1">return Config{
                MetricWhitelist:    metricWhitelist,
                MetricBlacklist:    metricBlacklist,
                MetricTagWhitelist: metricTagWhitelist,
                MetricTagBlacklist: metricTagBlacklist,
                TagInclude:         tagInclude,
                TagExclude:         tagExclude,
        }</span>
}

func FromConfig(cfg Config) Filter <span class="cov6" title="6">{
        if cfg.Empty() </span><span class="cov6" title="6">{
                return nil
        }</span>

        <span class="cov6" title="6">metricAllowList := cfg.MetricWhitelist
        if len(cfg.MetricAllowList) &gt; 0 </span><span class="cov6" title="6">{
                metricAllowList = cfg.MetricAllowList
        }</span>
        <span class="cov6" title="6">metricDenyList := cfg.MetricBlacklist
        if len(cfg.MetricDenyList) &gt; 0 </span><span class="cov1" title="1">{
                metricDenyList = cfg.MetricDenyList
        }</span>
        <span class="cov6" title="6">metricTagAllowList := cfg.MetricTagWhitelist
        if len(cfg.MetricTagAllowList) &gt; 0 </span><span class="cov4" title="3">{
                metricTagAllowList = cfg.MetricTagAllowList
        }</span>
        <span class="cov6" title="6">metricTagDenyList := cfg.MetricTagBlacklist
        if len(cfg.MetricTagDenyList) &gt; 0 </span><span class="cov1" title="1">{
                metricTagDenyList = cfg.MetricTagDenyList
        }</span>
        <span class="cov6" title="6">tagInclude := cfg.TagInclude
        tagExclude := cfg.TagExclude

        if len(metricAllowList) == 0 &amp;&amp; len(metricDenyList) == 0 &amp;&amp; len(metricTagAllowList) == 0 &amp;&amp;
                len(metricTagDenyList) == 0 &amp;&amp; len(tagInclude) == 0 &amp;&amp; len(tagExclude) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="6">return NewGlobFilter(Config{
                MetricAllowList:    metricAllowList,
                MetricDenyList:     metricDenyList,
                MetricTagAllowList: metricTagAllowList,
                MetricTagDenyList:  metricTagDenyList,
                TagInclude:         tagInclude,
                TagExclude:         tagExclude,
        })</span>
}

func parseFilters(slice []string) map[string][]string <span class="cov4" title="3">{
        if len(slice) == 0 </span><span class="cov10" title="16">{
                return nil
        }</span>
        <span class="cov4" title="3">out := make(map[string][]string)

        // each string in the slice is of the form: "tagK:[glob1, glob2, ...]"
        for _, tag := range slice </span><span class="cov6" title="5">{
                s := strings.Split(tag, ":")
                if len(s) == 2 </span><span class="cov6" title="5">{
                        k, v := s[0], s[1]
                        patterns, err := parseValue(v)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Print(err)
                        }</span> else<span class="cov6" title="5"> {
                                out[k] = patterns
                        }</span>
                }
        }
        <span class="cov4" title="3">return out</span>
}

// Gets a string slice from a string of the form "[foo*, bar*, ...]"
func parseValue(val string) ([]string, error) <span class="cov6" title="6">{
        if !strings.HasPrefix(val, "[") || !strings.HasSuffix(val, "]") </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid metric tag filter: %s", val)
        }</span>
        <span class="cov6" title="6">tagValue := val[1 : len(val)-1]
        return strings.Split(tagValue, ","), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package flags

import (
        "bytes"
        "fmt"
        "net/url"
        "os"
        "strings"
)

type Uri struct {
        Key string
        Val url.URL
}

func (u *Uri) String() string <span class="cov5" title="5">{
        val := u.Val.String()
        if val == "" </span><span class="cov4" title="3">{
                return fmt.Sprintf("%s", u.Key)
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf("%s:%s", u.Key, val)</span>
}

func (u *Uri) Set(value string) error <span class="cov8" title="13">{
        s := strings.SplitN(value, ":", 2)
        if s[0] == "" </span><span class="cov5" title="5">{
                return fmt.Errorf("missing uri key in '%s'", value)
        }</span>
        <span class="cov7" title="8">u.Key = s[0]
        if len(s) &gt; 1 &amp;&amp; s[1] != "" </span><span class="cov5" title="4">{
                e := os.ExpandEnv(s[1])
                uri, err := url.Parse(e)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov4" title="3">u.Val = *uri</span>
        }
        <span class="cov6" title="7">return nil</span>
}

type Uris []Uri

func (us *Uris) String() string <span class="cov10" title="20">{
        var b bytes.Buffer
        b.WriteString("[")
        for i, u := range *us </span><span class="cov4" title="3">{
                if i &gt; 0 </span><span class="cov1" title="1">{
                        b.WriteString(" ")
                }</span>
                <span class="cov4" title="3">b.WriteString(u.String())</span>
        }
        <span class="cov10" title="20">b.WriteString("]")
        return b.String()</span>
}

func (us *Uris) Set(value string) error <span class="cov5" title="5">{
        var u Uri
        if err := u.Set(value); err != nil </span><span class="cov3" title="2">{
                return err
        }</span>
        <span class="cov4" title="3">*us = append(*us, u)
        return nil</span>
}

func (us *Uris) Type() string <span class="cov0" title="0">{
        return fmt.Sprintf("%T", us)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package flags

import (
        "net/url"
        "strconv"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

// Decodes tags of the form "tag=key:value"
func DecodeTags(vals map[string][]string) map[string]string <span class="cov6" title="8">{
        if vals == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov6" title="8">var tags map[string]string
        if len(vals["tag"]) &gt; 0 </span><span class="cov5" title="6">{
                tags = make(map[string]string)
                tagList := vals["tag"]
                for _, tag := range tagList </span><span class="cov7" title="12">{
                        s := strings.Split(tag, ":")
                        if len(s) == 2 </span><span class="cov7" title="12">{
                                k, v := s[0], s[1]
                                tags[k] = v
                        }</span> else<span class="cov0" title="0"> {
                                log.Warning("invalid tag ", tag)
                        }</span>
                }
        }
        <span class="cov6" title="8">return tags</span>
}

func DecodeValue(vals map[string][]string, name string) string <span class="cov10" title="33">{
        value := ""
        if len(vals[name]) &gt; 0 </span><span class="cov8" title="21">{
                value = vals[name][0]
        }</span>
        <span class="cov10" title="33">return value</span>
}

func DecodeBoolean(vals map[string][]string, name string) bool <span class="cov0" title="0">{
        value := false
        if len(vals[name]) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                value, err = strconv.ParseBool(vals[name][0])
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return value</span>
}

func ParseDuration(vals url.Values, prop string, def time.Duration) time.Duration <span class="cov0" title="0">{
        if len(vals[prop]) &gt; 0 </span><span class="cov0" title="0">{
                res, err := time.ParseDuration(vals[prop][0])
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error parsing '%s' propertie: %v", prop, err)
                }</span> else<span class="cov0" title="0"> {
                        return res
                }</span>
        }
        <span class="cov0" title="0">return def</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package httputil

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "io/ioutil"
        "net/http"
        "strings"
        "time"
)

// Returns a new HTTP client based on the given configuration.
func NewClient(cfg ClientConfig) (*http.Client, error) <span class="cov5" title="6">{
        rt, err := NewRoundTripper(cfg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="6">return &amp;http.Client{Transport: rt}, nil</span>
}

// Returns a new HTTP RoundTripper based on the given configuration.
func NewRoundTripper(cfg ClientConfig) (http.RoundTripper, error) <span class="cov5" title="6">{
        tlsConfig, err := NewTLSConfig(&amp;cfg.TLSConfig)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov5" title="6">var rt http.RoundTripper = &amp;http.Transport{
                Proxy:               http.ProxyURL(cfg.ProxyURL.URL),
                MaxIdleConns:        20000,
                MaxIdleConnsPerHost: 1000, // see https://github.com/golang/go/issues/13801
                DisableKeepAlives:   false,
                TLSClientConfig:     tlsConfig,
                DisableCompression:  true,
                // dictates keepalive for connections.
                // 5 minutes is above the typical scrape interval for targets.
                IdleConnTimeout: 5 * time.Minute,
        }

        // create a round tripper that will set the Authz header if bearer token is provided
        if len(cfg.BearerToken) &gt; 0 </span><span class="cov7" title="12">{
                rt = NewBearerTokenRoundTripper(cfg.BearerToken, rt)
        }</span> else<span class="cov6" title="7"> if len(cfg.BearerTokenFile) &gt; 0 </span><span class="cov0" title="0">{
                rt = NewBearerTokenFileRoundTripper(cfg.BearerTokenFile, rt)
        }</span>
        <span class="cov5" title="6">return rt, nil</span>
}

type bearerTokenRoundTripper struct {
        token string
        rt    http.RoundTripper
}

// Returns a new HTTP RoundTripper that adds the given bearer token to a request header
func NewBearerTokenRoundTripper(token string, rt http.RoundTripper) http.RoundTripper <span class="cov7" title="12">{
        return &amp;bearerTokenRoundTripper{token, rt}
}</span>

func (rt *bearerTokenRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov10" title="30">{
        if len(req.Header.Get("Authorization")) == 0 </span><span class="cov10" title="30">{
                req = cloneRequest(req)
                req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", string(rt.token)))
        }</span>
        <span class="cov10" title="30">return rt.rt.RoundTrip(req)</span>
}

type bearerTokenFileRoundTripper struct {
        bearerFile string
        rt         http.RoundTripper
}

// Returns a new HTTP RoundTripper that adds the bearer token from the given file to a request header
func NewBearerTokenFileRoundTripper(bearerFile string, rt http.RoundTripper) http.RoundTripper <span class="cov0" title="0">{
        return &amp;bearerTokenFileRoundTripper{bearerFile, rt}
}</span>

func (rt *bearerTokenFileRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        if len(req.Header.Get("Authorization")) == 0 </span><span class="cov0" title="0">{
                b, err := ioutil.ReadFile(rt.bearerFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to read bearer token file %s: %s", rt.bearerFile, err)
                }</span>
                <span class="cov0" title="0">bearerToken := strings.TrimSpace(string(b))

                req = cloneRequest(req)
                req.Header.Set("Authorization", "Bearer "+bearerToken)</span>
        }
        <span class="cov0" title="0">return rt.rt.RoundTrip(req)</span>
}

// cloneRequest returns a clone of the provided *http.Request.
func cloneRequest(r *http.Request) *http.Request <span class="cov10" title="30">{
        // Shallow copy of the struct.
        r2 := new(http.Request)
        *r2 = *r
        // Deep copy of the Header.
        r2.Header = make(http.Header)
        for k, s := range r.Header </span><span class="cov0" title="0">{
                r2.Header[k] = s
        }</span>
        <span class="cov10" title="30">return r2</span>
}

// Returns a new tls.Config from the given configuration.
func NewTLSConfig(cfg *TLSConfig) (*tls.Config, error) <span class="cov5" title="6">{
        tlsConfig := &amp;tls.Config{InsecureSkipVerify: cfg.InsecureSkipVerify}

        // If a CA cert is provided then let's read it in so we can validate the certificate.
        if len(cfg.CAFile) &gt; 0 </span><span class="cov0" title="0">{
                caCertPool := x509.NewCertPool()
                // Load CA cert.
                caCert, err := ioutil.ReadFile(cfg.CAFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to use specified CA cert %s: %s", cfg.CAFile, err)
                }</span>
                <span class="cov0" title="0">caCertPool.AppendCertsFromPEM(caCert)
                tlsConfig.RootCAs = caCertPool</span>
        }

        <span class="cov5" title="6">if len(cfg.ServerName) &gt; 0 </span><span class="cov0" title="0">{
                tlsConfig.ServerName = cfg.ServerName
        }</span>
        // If a client cert &amp; key is provided then configure TLS config accordingly.
        <span class="cov5" title="6">if len(cfg.CertFile) &gt; 0 &amp;&amp; len(cfg.KeyFile) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("client cert file %q specified without client key file", cfg.CertFile)
        }</span> else<span class="cov5" title="6"> if len(cfg.KeyFile) &gt; 0 &amp;&amp; len(cfg.CertFile) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("client key file %q specified without client cert file", cfg.KeyFile)
        }</span> else<span class="cov5" title="6"> if len(cfg.CertFile) &gt; 0 &amp;&amp; len(cfg.KeyFile) &gt; 0 </span><span class="cov0" title="0">{
                cert, err := tls.LoadX509KeyPair(cfg.CertFile, cfg.KeyFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to use specified client cert (%s) &amp; key (%s): %s", cfg.CertFile, cfg.KeyFile, err)
                }</span>
                <span class="cov0" title="0">tlsConfig.Certificates = []tls.Certificate{cert}</span>
        }
        <span class="cov5" title="6">tlsConfig.BuildNameToCertificate()

        return tlsConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package httputil

import (
        "fmt"

        "gopkg.in/yaml.v2"
)

// FromYAML loads the configuration from a blob of YAML.
func FromYAML(contents []byte) (ClientConfig, error) <span class="cov8" title="1">{
        var cfg ClientConfig
        if err := yaml.UnmarshalStrict(contents, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return ClientConfig{}, fmt.Errorf("unable to parse http configuration: %v", err)
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/common/kubernetes/configs.go
// Diff against master for changes to the original code.

// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kubernetes

import (
        "fmt"
        "io/ioutil"
        "net/url"
        "strconv"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"

        "k8s.io/apimachinery/pkg/runtime/schema"
        kube_rest "k8s.io/client-go/rest"
        kubeClientCmd "k8s.io/client-go/tools/clientcmd"
        kubeClientCmdApi "k8s.io/client-go/tools/clientcmd/api"
)

const (
        APIVersion        = "v1"
        DefaultAPIService = "kubernetes.default.svc.cluster.local"

        defaultKubeletPort        = 10255
        defaultKubeletHttps       = false
        defaultUseServiceAccount  = false
        defaultServiceAccountFile = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        defaultInClusterConfig    = true
)

func getConfigOverrides(uri *url.URL) (*kubeClientCmd.ConfigOverrides, error) <span class="cov0" title="0">{
        kubeConfigOverride := kubeClientCmd.ConfigOverrides{
                ClusterInfo: kubeClientCmdApi.Cluster{},
        }
        if len(uri.Scheme) != 0 &amp;&amp; len(uri.Host) != 0 </span><span class="cov0" title="0">{
                kubeConfigOverride.ClusterInfo.Server = fmt.Sprintf("%s://%s", uri.Scheme, uri.Host)
        }</span>

        <span class="cov0" title="0">opts := uri.Query()

        if len(opts["insecure"]) &gt; 0 </span><span class="cov0" title="0">{
                insecure, err := strconv.ParseBool(opts["insecure"][0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">kubeConfigOverride.ClusterInfo.InsecureSkipTLSVerify = insecure</span>
        }

        <span class="cov0" title="0">return &amp;kubeConfigOverride, nil</span>
}

func getConfigOverridesFromConfig(cfg configuration.SummarySourceConfig) (*kubeClientCmd.ConfigOverrides, error) <span class="cov10" title="4">{
        kubeConfigOverride := kubeClientCmd.ConfigOverrides{
                ClusterInfo: kubeClientCmdApi.Cluster{},
        }

        if cfg.URL != "" </span><span class="cov10" title="4">{
                uri, err := url.Parse(cfg.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="4">if len(uri.Scheme) != 0 &amp;&amp; len(uri.Host) != 0 </span><span class="cov10" title="4">{
                        kubeConfigOverride.ClusterInfo.Server = fmt.Sprintf("%s://%s", uri.Scheme, uri.Host)
                }</span>
        }

        <span class="cov10" title="4">if len(cfg.Insecure) &gt; 0 </span><span class="cov10" title="4">{
                insecure, err := strconv.ParseBool(cfg.Insecure)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="4">kubeConfigOverride.ClusterInfo.InsecureSkipTLSVerify = insecure</span>
        }
        <span class="cov10" title="4">return &amp;kubeConfigOverride, nil</span>
}

func GetKubeClientConfig(cfg configuration.SummarySourceConfig) (*kube_rest.Config, error) <span class="cov10" title="4">{
        var (
                kubeConfig *kube_rest.Config
                err        error
        )

        configOverrides, err := getConfigOverridesFromConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="4">inClusterConfig := defaultInClusterConfig
        if len(cfg.InClusterConfig) &gt; 0 </span><span class="cov8" title="3">{
                inClusterConfig, err = strconv.ParseBool(cfg.InClusterConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov10" title="4">if inClusterConfig </span><span class="cov10" title="4">{
                kubeConfig, err = kube_rest.InClusterConfig()
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov10" title="4">if configOverrides.ClusterInfo.Server != "" </span><span class="cov10" title="4">{
                        kubeConfig.Host = configOverrides.ClusterInfo.Server
                }</span>
                <span class="cov10" title="4">kubeConfig.GroupVersion = &amp;schema.GroupVersion{Version: APIVersion}
                kubeConfig.Insecure = configOverrides.ClusterInfo.InsecureSkipTLSVerify
                if configOverrides.ClusterInfo.InsecureSkipTLSVerify </span><span class="cov10" title="4">{
                        kubeConfig.TLSClientConfig.CAFile = ""
                }</span>
        } else<span class="cov8" title="3"> {
                authFile := ""
                if len(cfg.Auth) &gt; 0 </span><span class="cov0" title="0">{
                        authFile = cfg.Auth
                }</span>

                <span class="cov8" title="3">if authFile != "" </span><span class="cov0" title="0">{
                        // Load structured kubeconfig data from the given path.
                        loader := &amp;kubeClientCmd.ClientConfigLoadingRules{ExplicitPath: authFile}
                        loadedConfig, err := loader.Load()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Flatten the loaded data to a particular restclient.Config based on the current context.
                        <span class="cov0" title="0">if kubeConfig, err = kubeClientCmd.NewNonInteractiveClientConfig(
                                *loadedConfig,
                                loadedConfig.CurrentContext,
                                &amp;kubeClientCmd.ConfigOverrides{},
                                loader).ClientConfig(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="3"> {
                        kubeConfig = &amp;kube_rest.Config{
                                Host: configOverrides.ClusterInfo.Server,
                                TLSClientConfig: kube_rest.TLSClientConfig{
                                        Insecure: configOverrides.ClusterInfo.InsecureSkipTLSVerify,
                                },
                        }
                        kubeConfig.GroupVersion = &amp;schema.GroupVersion{Version: APIVersion}
                }</span>
        }
        <span class="cov10" title="4">if len(kubeConfig.Host) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid kubernetes master url specified")
        }</span>

        <span class="cov10" title="4">useServiceAccount := defaultUseServiceAccount
        if len(cfg.UseServiceAccount) &gt;= 1 </span><span class="cov10" title="4">{
                useServiceAccount, err = strconv.ParseBool(cfg.UseServiceAccount)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov10" title="4">if useServiceAccount </span><span class="cov10" title="4">{
                // If a readable service account token exists, then use it
                if contents, err := ioutil.ReadFile(defaultServiceAccountFile); err == nil </span><span class="cov10" title="4">{
                        kubeConfig.BearerToken = string(contents)
                }</span>
        }
        <span class="cov10" title="4">kubeConfig.ContentType = "application/vnd.kubernetes.protobuf"

        return kubeConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package kubernetes

import (
        "io/ioutil"

        log "github.com/sirupsen/logrus"
)

var testMode = false
var TerminationMessage string

func UseTerminateTestMode() <span class="cov0" title="0">{
        testMode = true
}</span>

func Terminate(message string) <span class="cov0" title="0">{
        if testMode </span><span class="cov0" title="0">{
                TerminationMessage = message
        }</span> else<span class="cov0" title="0"> {
                err := ioutil.WriteFile("/dev/termination-log", []byte(message), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err)
                }</span>
                <span class="cov0" title="0">log.Fatal(message)</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package leadership

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"

        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/tools/leaderelection"
        "k8s.io/client-go/tools/leaderelection/resourcelock"
        "k8s.io/client-go/tools/record"
)

var (
        // internal metrics
        electionError metrics.Counter
        leadingGauge  metrics.Gauge

        // leadership state
        subscribers map[string]chan&lt;- bool
        lock        sync.RWMutex
        started     bool
        isLeader    bool
        leaderId    string
)

func init() <span class="cov1" title="1">{
        electionError = metrics.GetOrRegisterCounter("leaderelection.error", metrics.DefaultRegistry)
        leadingGauge = metrics.GetOrRegisterGauge("leaderelection.leading", metrics.DefaultRegistry)
}</span>

// Subscribe starts the leader election process if not already started
// and returns a channel subscriber can listen on for election results
func Subscribe(client v1.CoreV1Interface, name string) (&lt;-chan bool, error) <span class="cov5" title="3">{
        lock.Lock()
        defer lock.Unlock()

        if err := startLeaderElection(client); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="3">ch := make(chan bool, 1)
        // inform if we are currently the leader
        if isLeader </span><span class="cov1" title="1">{
                ch &lt;- true
        }</span>
        <span class="cov5" title="3">if subscribers == nil </span><span class="cov1" title="1">{
                subscribers = make(map[string]chan&lt;- bool)
        }</span>
        // add to subscribers map to notify of election results
        <span class="cov5" title="3">subscribers[name] = ch
        return ch, nil</span>
}

func Unsubscribe(name string) <span class="cov0" title="0">{
        lock.Lock()
        defer lock.Unlock()

        delete(subscribers, name)
        log.Infof("unsubscribed %s from leader-election: %d", name, len(subscribers))
}</span>

// startLeaderElection starts the election process if not already started
// this will only be done once per collector instance
func startLeaderElection(client v1.CoreV1Interface) error <span class="cov5" title="3">{
        if !started </span><span class="cov1" title="1">{
                le, err := getLeaderElector(client)
                if err != nil </span><span class="cov0" title="0">{
                        electionError.Inc(1)
                        return err
                }</span>
                <span class="cov1" title="1">go func() </span><span class="cov1" title="1">{
                        for </span><span class="cov1" title="1">{
                                le.Run(context.Background())
                        }</span>
                }()
                <span class="cov1" title="1">started = true</span>
        }
        <span class="cov5" title="3">return nil</span>
}

// getLeaderElector returns a leader elector
func getLeaderElector(client v1.CoreV1Interface) (*leaderelection.LeaderElector, error) <span class="cov1" title="1">{
        nodeName := util.GetNodeName()
        if nodeName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s envvar is not defined", util.NodeNameEnvVar)
        }</span>
        <span class="cov1" title="1">ns := util.GetNamespaceName()
        if ns == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s envvar is not defined", util.NamespaceNameEnvVar)
        }</span>

        <span class="cov1" title="1">resourceLock, err := getResourceLock(ns, "wf-collector-leader", client, nodeName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">le, err := leaderelection.NewLeaderElector(leaderelection.LeaderElectionConfig{
                Lock:          resourceLock,
                LeaseDuration: 60 * time.Second,
                RenewDeadline: 45 * time.Second,
                RetryPeriod:   30 * time.Second,
                Callbacks: leaderelection.LeaderCallbacks{
                        OnStartedLeading: func(ctx context.Context) </span>{<span class="cov1" title="1">}</span>,
                        OnStoppedLeading: func() {<span class="cov0" title="0">}</span>,
                        OnNewLeader: func(identity string) <span class="cov1" title="1">{
                                lock.Lock()
                                defer lock.Unlock()

                                if identity == nodeName </span><span class="cov1" title="1">{
                                        leadingGauge.Update(1)
                                }</span> else<span class="cov0" title="0"> {
                                        leadingGauge.Update(0)
                                }</span>

                                <span class="cov1" title="1">log.Infof("node: %s elected leader", identity)
                                leaderId = identity
                                if identity == nodeName &amp;&amp; !isLeader </span><span class="cov1" title="1">{
                                        for i := range subscribers </span><span class="cov4" title="2">{
                                                subscribers[i] &lt;- true
                                        }</span>
                                        <span class="cov1" title="1">isLeader = true</span>
                                } else<span class="cov0" title="0"> if identity != nodeName &amp;&amp; isLeader </span><span class="cov0" title="0">{
                                        for i := range subscribers </span><span class="cov0" title="0">{
                                                subscribers[i] &lt;- false
                                        }</span>
                                }
                        },
                },
        })
        <span class="cov1" title="1">return le, err</span>
}

// getResourceLock returns a config map based resource lock for leader election
func getResourceLock(ns string, name string, client v1.CoreV1Interface, resourceLockID string) (resourcelock.Interface, error) <span class="cov1" title="1">{
        return resourcelock.New(
                resourcelock.ConfigMapsResourceLock,
                ns,
                name,
                client,
                nil,
                resourcelock.ResourceLockConfig{
                        Identity:      resourceLockID,
                        EventRecorder: &amp;record.FakeRecorder{},
                },
        )
}</span>

func Leader() string <span class="cov5" title="3">{
        lock.RLock()
        defer lock.RUnlock()
        return leaderId
}</span>

func SetLeading(leading bool) <span class="cov4" title="2">{
        isLeader = leading
}</span>

func Leading() bool <span class="cov10" title="8">{
        lock.RLock()
        defer lock.RUnlock()
        return util.ScrapeCluster() &amp;&amp; isLeader
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package leadership

import (
        log "github.com/sirupsen/logrus"

        "k8s.io/client-go/kubernetes"
)

type Resumer interface {
        Resume()
        Pause()
}

// Manager manages the pausing and resumption of a given system based on changes in leadership
type Manager struct {
        system     Resumer
        name       string
        stop       chan struct{}
        kubeClient kubernetes.Interface
}

// NewManager creates a new leadership manager for a given system
func NewManager(system Resumer, name string, kubeClient kubernetes.Interface) *Manager <span class="cov5" title="2">{
        return &amp;Manager{
                stop:       make(chan struct{}),
                system:     system,
                name:       name,
                kubeClient: kubeClient,
        }
}</span>

func (lm *Manager) Start() <span class="cov5" title="2">{
        ch, err := Subscribe(lm.kubeClient.CoreV1(), lm.name)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("%s: leader election error: %q", lm.name, err)
        }</span> else<span class="cov5" title="2"> {
                go func() </span><span class="cov5" title="2">{
                        lm.run(ch)
                }</span>()
        }
}

func (lm *Manager) Stop() <span class="cov0" title="0">{
        close(lm.stop)
        Unsubscribe(lm.name)
}</span>

func (lm *Manager) run(ch &lt;-chan bool) <span class="cov5" title="2">{
        for </span><span class="cov10" title="4">{
                select </span>{
                case isLeader := &lt;-ch:<span class="cov5" title="2">
                        if isLeader </span><span class="cov5" title="2">{
                                log.Infof("resuming %s: node %s elected leader", lm.name, Leader())
                                go func() </span><span class="cov5" title="2">{ lm.system.Resume() }</span>()
                        } else<span class="cov0" title="0"> {
                                log.Infof("pausing %s: demoted from leadership. new leader: %s", lm.name, Leader())
                                lm.system.Pause()
                        }</span>
                case &lt;-lm.stop:<span class="cov0" title="0">
                        log.Infof("%s: stopping leadership manager", lm.name)
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package metrics

import (
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
)

// Batch contains sets of metrics tied to specific k8s resources and other more general wavefront points
type Batch struct {
        Timestamp time.Time
        Sets      map[ResourceKey]*Set
        Metrics   []wf.Metric
}

func (b *Batch) Points() int <span class="cov10" title="6">{
        total := 0
        for _, set := range b.Sets </span><span class="cov7" title="4">{
                total += set.Points()
        }</span>
        <span class="cov10" title="6">for _, metric := range b.Metrics </span><span class="cov7" title="4">{
                total += metric.Points()
        }</span>
        <span class="cov10" title="6">return total</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package metrics

type errorSourceDecorator struct {
        src     Source
        errFunc func(err error) error
}

func (c *errorSourceDecorator) Name() string <span class="cov10" title="20">{
        return c.src.Name()
}</span>

func (c *errorSourceDecorator) AutoDiscovered() bool <span class="cov0" title="0">{
        return c.src.AutoDiscovered()
}</span>

func (c *errorSourceDecorator) Scrape() (*Batch, error) <span class="cov3" title="2">{
        dataBatch, err := c.src.Scrape()
        return dataBatch, c.errFunc(err)
}</span>

func (c *errorSourceDecorator) Cleanup() <span class="cov1" title="1">{
        c.src.Cleanup()
}</span>

// NewErrorDecorator creates a MetricSource that transforms Scrape errors
func NewErrorDecorator(src Source, errFunc func(err error) error) Source <span class="cov5" title="4">{
        return &amp;errorSourceDecorator{src: src, errFunc: errFunc}
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package metrics

import (
        "fmt"
        "time"
)

type AggregationType string

var (
        AggregationTypeAverage      AggregationType = "average"
        AggregationTypeMaximum      AggregationType = "max"
        AggregationTypeMinimum      AggregationType = "min"
        AggregationTypeMedian       AggregationType = "median"
        AggregationTypeCount        AggregationType = "count"
        AggregationTypePercentile50 AggregationType = "50-perc"
        AggregationTypePercentile95 AggregationType = "95-perc"
        AggregationTypePercentile99 AggregationType = "99-perc"
)

// MultiTypedAggregations is the list of aggregations that can be either float or int
var MultiTypedAggregations = []AggregationType{
        AggregationTypeAverage,
        AggregationTypeMaximum,
        AggregationTypeMinimum,
        AggregationTypeMedian,
        AggregationTypePercentile50,
        AggregationTypePercentile95,
        AggregationTypePercentile99,
}

// AllAggregations is the set of all supported aggregations
var AllAggregations = map[AggregationType]bool{
        AggregationTypeAverage:      true,
        AggregationTypeMaximum:      true,
        AggregationTypeMinimum:      true,
        AggregationTypeMedian:       true,
        AggregationTypePercentile50: true,
        AggregationTypePercentile95: true,
        AggregationTypePercentile99: true,
        AggregationTypeCount:        true,
}

// TimestampedMetricValue is a metric value with an associated timestamp
type TimestampedMetricValue struct {
        Value
        Timestamp time.Time
}

// AggregationValue is a description of aggregated Values over time
type AggregationValue struct {
        Count *uint64

        Aggregations map[AggregationType]Value
}

// TimestampedAggregationValue is an aggregation value with an associated timestamp
// and bucket size
type TimestampedAggregationValue struct {
        // Timestamp is the start time of the bucket
        Timestamp time.Time

        // BucketSize is the duration of the bucket
        BucketSize time.Duration

        AggregationValue
}

// HistoricalKey is an identifier pointing to a particular object.
// Is is composed of an object type (pod, namespace, container, etc) as well
// as a series of fields which identify that object.
type HistoricalKey struct {
        // ObjectType specifies which type of object this is for (pod, namespace, etc)
        // It should be one of the MetricSetType* labels.
        ObjectType string

        // NodeName is used for node and system-container metrics
        NodeName string
        // NamespaceName is used for namespace, pod, and pod-container metrics
        NamespaceName string
        // PodName is used for pod and pod-container metrics
        PodName string
        // ContainerName is used for system-container and pod-container metrics
        ContainerName string
        // PodId may be used in place of the combination of PodName and NamespaceName for pod and pod-container metrics
        PodId string
}

func (key *HistoricalKey) String() string <span class="cov0" title="0">{
        prefix := fmt.Sprintf("(%s)", key.ObjectType)

        var path string = "[unknown type]"
        switch key.ObjectType </span>{
        case MetricSetTypeSystemContainer:<span class="cov0" title="0">
                path = fmt.Sprintf("node:%s/container:%s", key.NodeName, key.ContainerName)</span>
        case MetricSetTypePodContainer:<span class="cov0" title="0">
                if key.PodId != "" </span><span class="cov0" title="0">{
                        path = fmt.Sprintf("poduid:%s/container:%s", key.PodId, key.ContainerName)
                }</span> else<span class="cov0" title="0"> {
                        path = fmt.Sprintf("ns:%s/pod:%s/container:%s", key.NamespaceName, key.PodName, key.ContainerName)
                }</span>
        case MetricSetTypePod:<span class="cov0" title="0">
                if key.PodId != "" </span><span class="cov0" title="0">{
                        path = fmt.Sprintf("poduid:%s", key.PodId)
                }</span> else<span class="cov0" title="0"> {
                        path = fmt.Sprintf("ns:%s/pod:%s", key.NamespaceName, key.PodName)
                }</span>
        case MetricSetTypeNamespace:<span class="cov0" title="0">
                path = fmt.Sprintf("ns:%s", key.NamespaceName)</span>
        case MetricSetTypeNode:<span class="cov0" title="0">
                path = fmt.Sprintf("node:%s", key.NodeName)</span>
        case MetricSetTypeCluster:<span class="cov0" title="0">
                path = "[cluster]"</span>
        }

        <span class="cov0" title="0">return prefix + path</span>
}

// HistoricalSource allows for retrieval of historical metrics and aggregations from sinks
type HistoricalSource interface {
        // GetMetric retrieves the given metric for one or more objects (specified by metricKeys) of
        // the same type, within the given time interval.  A start time of zero indicates no starting bound,
        // while an end time of zero indicates no ending bound.
        GetMetric(metricName string, metricKeys []HistoricalKey, start, end time.Time) (map[HistoricalKey][]TimestampedMetricValue, error)

        // GetLabeledMetric retrieves the given labeled metric.  Otherwise, it functions identically to GetMetric.
        GetLabeledMetric(metricName string, labels map[string]string, metricKeys []HistoricalKey, start, end time.Time) (map[HistoricalKey][]TimestampedMetricValue, error)

        // GetAggregation fetches the given aggregations for one or more objects (specified by metricKeys) of
        // the same type, within the given time interval, calculated over a series of buckets.  The start time,
        // end time, and bucket size may be zero.  A start time of zero indicates no starting bound, while and
        // end time of zero indicates no ending bound (effectively meaning up to the latest metrics, but not metrics
        // from the future).  A bucket size of zero indicates that only a single bucket spanning the entire specified
        // time range should be returned.
        GetAggregation(metricName string, aggregations []AggregationType, metricKeys []HistoricalKey, start, end time.Time, bucketSize time.Duration) (map[HistoricalKey][]TimestampedAggregationValue, error)

        // GetLabeledAggregation fetches a the given aggregations for a labeled metric instead of a normal metric.
        // Otherwise, it functions identically to GetAggregation.
        GetLabeledAggregation(metricName string, labels map[string]string, aggregations []AggregationType, metricKeys []HistoricalKey, start, end time.Time, bucketSize time.Duration) (map[HistoricalKey][]TimestampedAggregationValue, error)

        // GetMetricNames retrieves the available metric names for the given object
        GetMetricNames(metricKey HistoricalKey) ([]string, error)

        // GetNodes retrieves the list of nodes in the cluster
        GetNodes() ([]string, error)
        // GetNamespaces retrieves the list of namespaces in the cluster
        GetNamespaces() ([]string, error)
        // GetPodsFromNamespace retrieves the list of pods in a given namespace
        GetPodsFromNamespace(namespace string) ([]string, error)
        // GetSystemContainersFromNode retrieves the list of free containers for a given node
        GetSystemContainersFromNode(node string) ([]string, error)
}

// AsHistoricalSource represents sinks which support a historical access interface
type AsHistoricalSource interface {
        // Historical returns the historical data access interface for this sink
        Historical() HistoricalSource
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package metrics

// Definition of labels supported in Set.

var (
        LabelMetricSetType = LabelDescriptor{
                Key:         "type",
                Description: "Type of the metrics set (container, pod, namespace, node, cluster)",
        }
        MetricSetTypeSystemContainer = "sys_container"
        MetricSetTypePodContainer    = "pod_container"
        MetricSetTypePod             = "pod"
        MetricSetTypeNamespace       = "ns"
        MetricSetTypeNode            = "node"
        MetricSetTypeCluster         = "cluster"

        LabelCluster = LabelDescriptor{
                Key:         "cluster",
                Description: "The name of the kubernetes cluster",
        }
        LabelPodId = LabelDescriptor{
                Key:         "pod_id",
                Description: "The unique ID of the pod",
        }
        LabelPodName = LabelDescriptor{
                Key:         "pod_name",
                Description: "The name of the pod",
        }
        LabelNamespaceName = LabelDescriptor{
                Key:         "namespace_name",
                Description: "The name of the namespace",
        }
        LabelPodNamespaceUID = LabelDescriptor{
                Key:         "namespace_id",
                Description: "The UID of namespace of the pod",
        }
        LabelContainerName = LabelDescriptor{
                Key:         "container_name",
                Description: "User-provided name of the container or full container name for system containers",
        }
        LabelLabels = LabelDescriptor{
                Key:         "labels",
                Description: "Comma-separated list of user-provided labels",
        }
        LabelNodename = LabelDescriptor{
                Key:         "nodename",
                Description: "nodename where the container ran",
        }
        LabelNodeRole = LabelDescriptor{
                Key:         "node_role",
                Description: "Node role worker or control-plane",
        }
        LabelHostname = LabelDescriptor{
                Key:         "hostname",
                Description: "Hostname where the container ran",
        }
        LabelResourceID = LabelDescriptor{
                Key:         "resource_id",
                Description: "Identifier(s) specific to a metric",
        }
        LabelHostID = LabelDescriptor{
                Key:         "host_id",
                Description: "Identifier specific to a host. Set by cloud provider or user",
        }
        LabelContainerBaseImage = LabelDescriptor{
                Key:         "container_base_image",
                Description: "User-defined image name that is run inside the container",
        }
        // The label is populated only for GCM
        LabelCustomMetricName = LabelDescriptor{
                Key:         "custom_metric_name",
                Description: "User-defined name of the exported custom metric",
        }
        LabelGCEResourceID = LabelDescriptor{
                Key:         "resource_id",
                Description: "Resource id for nodes specific for GCE.",
        }
        LabelGCEResourceType = LabelDescriptor{
                Key:         "resource_type",
                Description: "Resource types for nodes specific for GCE.",
        }
        LabelNodeSchedulable = LabelDescriptor{
                Key:         "schedulable",
                Description: "Node schedulable status.",
        }
        LabelVolumeName = LabelDescriptor{
                Key:         "volume_name",
                Description: "The name of the volume.",
        }
        LabelAcceleratorMake = LabelDescriptor{
                Key:         "make",
                Description: "Make of the accelerator (nvidia, amd, google etc.)",
        }
        LabelAcceleratorModel = LabelDescriptor{
                Key:         "model",
                Description: "Model of the accelerator (tesla-p100, tesla-k80 etc.)",
        }
        LabelAcceleratorID = LabelDescriptor{
                Key:         "accelerator_id",
                Description: "ID of the accelerator",
        }
)

type LabelDescriptor struct {
        // Key to use for the label.
        Key string `json:"key,omitempty"`

        // Description of the label.
        Description string `json:"description,omitempty"`
}

var commonLabels = []LabelDescriptor{
        LabelNodename,
        LabelHostname,
        LabelHostID,
}

var containerLabels = []LabelDescriptor{
        LabelContainerName,
        LabelContainerBaseImage,
}

var podLabels = []LabelDescriptor{
        LabelPodName,
        LabelPodId,
        LabelPodNamespaceUID,
        LabelLabels,
}

var metricLabels = []LabelDescriptor{
        LabelResourceID,
}

var customMetricLabels = []LabelDescriptor{
        LabelCustomMetricName,
}

var acceleratorLabels = []LabelDescriptor{
        LabelAcceleratorMake,
        LabelAcceleratorModel,
        LabelAcceleratorID,
}

// Labels exported to GCM. The number of labels that can be exported to GCM is limited by 10.
var gcmLabels = []LabelDescriptor{
        LabelMetricSetType,
        LabelPodName,
        LabelNamespaceName,
        LabelHostname,
        LabelHostID,
        LabelContainerName,
        LabelContainerBaseImage,
        LabelCustomMetricName,
        LabelResourceID,
}

var gcmNodeAutoscalingLabels = []LabelDescriptor{
        LabelGCEResourceID,
        LabelGCEResourceType,
        LabelHostname,
}

func CommonLabels() []LabelDescriptor <span class="cov0" title="0">{
        result := make([]LabelDescriptor, len(commonLabels))
        copy(result, commonLabels)
        return result
}</span>

func ContainerLabels() []LabelDescriptor <span class="cov0" title="0">{
        result := make([]LabelDescriptor, len(containerLabels))
        copy(result, containerLabels)
        return result
}</span>

func PodLabels() []LabelDescriptor <span class="cov0" title="0">{
        result := make([]LabelDescriptor, len(podLabels))
        copy(result, podLabels)
        return result
}</span>

func MetricLabels() []LabelDescriptor <span class="cov0" title="0">{
        result := make([]LabelDescriptor, len(metricLabels)+len(customMetricLabels))
        copy(result, metricLabels)
        copy(result, customMetricLabels)
        return result
}</span>

func SupportedLabels() []LabelDescriptor <span class="cov0" title="0">{
        result := CommonLabels()
        result = append(result, PodLabels()...)
        return append(result, MetricLabels()...)
}</span>

func GcmLabels() map[string]LabelDescriptor <span class="cov0" title="0">{
        result := make(map[string]LabelDescriptor, len(gcmLabels))
        for _, l := range gcmLabels </span><span class="cov0" title="0">{
                result[l.Key] = l
        }</span>
        <span class="cov0" title="0">return result</span>
}
func GcmNodeAutoscalingLabels() map[string]LabelDescriptor <span class="cov0" title="0">{
        result := make(map[string]LabelDescriptor, len(gcmNodeAutoscalingLabels))
        for _, l := range gcmNodeAutoscalingLabels </span><span class="cov0" title="0">{
                result[l.Key] = l
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package metrics

import (
        "fmt"
        "time"

        cadvisor "github.com/google/cadvisor/info/v1"
        kube_api "k8s.io/api/core/v1"
)

const (
        CustomMetricPrefix = "custom/"
)

// Provided by Kubelet/cadvisor.
var StandardMetrics = []Metric{
        MetricUptime,
        MetricCpuUsage,
        MetricCpuLoad,
        MetricEphemeralStorageUsage,
        MetricMemoryUsage,
        MetricMemoryRSS,
        MetricMemoryCache,
        MetricMemoryWorkingSet,
        MetricMemoryPageFaults,
        MetricMemoryMajorPageFaults,
        MetricNetworkRx,
        MetricNetworkRxErrors,
        MetricNetworkTx,
        MetricNetworkTxErrors}

// Metrics computed based on cluster state using Kubernetes API.
var AdditionalMetrics = []Metric{
        MetricCpuRequest,
        MetricCpuLimit,
        MetricMemoryRequest,
        MetricMemoryLimit,
        MetricEphemeralStorageRequest,
        MetricEphemeralStorageLimit}

// Computed based on corresponding StandardMetrics.
var RateMetrics = []Metric{
        MetricCpuUsageRate,
        MetricMemoryPageFaultsRate,
        MetricMemoryMajorPageFaultsRate,
        MetricNetworkRxRate,
        MetricNetworkRxErrorsRate,
        MetricNetworkTxRate,
        MetricNetworkTxErrorsRate,
        MetricDiskIOReadRate,
        MetricDiskIOWriteRate}

var RateMetricsMapping = map[string]Metric{
        MetricCpuUsage.MetricDescriptor.Name:              MetricCpuUsageRate,
        MetricMemoryPageFaults.MetricDescriptor.Name:      MetricMemoryPageFaultsRate,
        MetricMemoryMajorPageFaults.MetricDescriptor.Name: MetricMemoryMajorPageFaultsRate,
        MetricNetworkRx.MetricDescriptor.Name:             MetricNetworkRxRate,
        MetricNetworkRxErrors.MetricDescriptor.Name:       MetricNetworkRxErrorsRate,
        MetricNetworkTx.MetricDescriptor.Name:             MetricNetworkTxRate,
        MetricNetworkTxErrors.MetricDescriptor.Name:       MetricNetworkTxErrorsRate,
        MetricDiskIORead.MetricDescriptor.Name:            MetricDiskIOReadRate,
        MetricDiskIOWrite.MetricDescriptor.Name:           MetricDiskIOWriteRate}

var LabeledMetrics = []Metric{
        MetricDiskIORead,
        MetricDiskIOReadRate,
        MetricDiskIOWrite,
        MetricDiskIOWriteRate,
        MetricFilesystemUsage,
        MetricFilesystemLimit,
        MetricFilesystemAvailable,
        MetricFilesystemInodes,
        MetricFilesystemInodesFree,
        MetricAcceleratorMemoryTotal,
        MetricAcceleratorMemoryUsed,
        MetricAcceleratorDutyCycle,
}

var NodeAutoscalingMetrics = []Metric{
        MetricNodeCpuCapacity,
        MetricNodeMemoryCapacity,
        MetricNodeEphemeralStorageCapacity,
        MetricNodeCpuAllocatable,
        MetricNodeMemoryAllocatable,
        MetricNodeEphemeralStorageAllocatable,
        MetricNodeCpuUtilization,
        MetricNodeMemoryUtilization,
        MetricNodeEphemeralStorageUtilization,
        MetricNodeCpuReservation,
        MetricNodeMemoryReservation,
        MetricNodeEphemeralStorageReservation,
}

var CpuMetrics = []Metric{
        MetricCpuLimit,
        MetricCpuRequest,
        MetricCpuUsage,
        MetricCpuLoad,
        MetricCpuUsageRate,
        MetricNodeCpuAllocatable,
        MetricNodeCpuCapacity,
        MetricNodeCpuReservation,
        MetricNodeCpuUtilization,
}
var FilesystemMetrics = []Metric{
        MetricFilesystemAvailable,
        MetricFilesystemLimit,
        MetricFilesystemUsage,
        MetricFilesystemInodes,
        MetricFilesystemInodesFree,
}
var MemoryMetrics = []Metric{
        MetricMemoryLimit,
        MetricMemoryMajorPageFaults,
        MetricMemoryMajorPageFaultsRate,
        MetricMemoryPageFaults,
        MetricMemoryPageFaultsRate,
        MetricMemoryRequest,
        MetricMemoryUsage,
        MetricMemoryRSS,
        MetricMemoryCache,
        MetricMemoryWorkingSet,
        MetricNodeMemoryAllocatable,
        MetricNodeMemoryCapacity,
        MetricNodeMemoryUtilization,
        MetricNodeMemoryReservation,
}
var NetworkMetrics = []Metric{
        MetricNetworkRx,
        MetricNetworkRxErrors,
        MetricNetworkRxErrorsRate,
        MetricNetworkRxRate,
        MetricNetworkTx,
        MetricNetworkTxErrors,
        MetricNetworkTxErrorsRate,
        MetricNetworkTxRate,
}

// Maps from resource name to the metric that tracks container resource request
// on that resource. The name of the metric is ResourceName/request where ResourceName
// is the name of the resource requested in container resource requests.
var ResourceRequestMetrics = map[kube_api.ResourceName]Metric{
        kube_api.ResourceCPU:              MetricCpuRequest,
        kube_api.ResourceMemory:           MetricMemoryRequest,
        kube_api.ResourceEphemeralStorage: MetricEphemeralStorageRequest,
}

type MetricFamily string

const (
        MetricFamilyCpu        MetricFamily = "cpu"
        MetricFamilyFilesystem              = "filesystem"
        MetricFamilyMemory                  = "memory"
        MetricFamilyNetwork                 = "network"
        MetricFamilyGeneral                 = "general"
)

var MetricFamilies = map[MetricFamily][]Metric{
        MetricFamilyCpu:        CpuMetrics,
        MetricFamilyFilesystem: FilesystemMetrics,
        MetricFamilyMemory:     MemoryMetrics,
        MetricFamilyNetwork:    NetworkMetrics,
}

func MetricFamilyForName(metricName string) MetricFamily <span class="cov0" title="0">{
        for family, metrics := range MetricFamilies </span><span class="cov0" title="0">{
                for _, metric := range metrics </span><span class="cov0" title="0">{
                        if metricName == metric.Name </span><span class="cov0" title="0">{
                                return family
                        }</span>
                }
        }
        <span class="cov0" title="0">return MetricFamilyGeneral</span>
}

var AllMetrics = append(append(append(append(StandardMetrics, AdditionalMetrics...), RateMetrics...), LabeledMetrics...),
        NodeAutoscalingMetrics...)

// Definition of Standard Metrics.
var MetricUptime = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "uptime",
                Description: "Number of milliseconds since the container was started",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Milliseconds,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return !spec.CreationTime.IsZero()
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  time.Since(spec.CreationTime).Nanoseconds() / time.Millisecond.Nanoseconds()}
        }</span>,
}

var MetricRestartCount = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "restart_count",
                Description: "Number of container restarts",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricCpuLoad = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/load",
                Description: "CPU load",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasCpu
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Cpu.LoadAverage)}
        }</span>,
}

var MetricCpuUsage = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/usage",
                Description: "Cumulative CPU usage on all cores",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Nanoseconds,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasCpu
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Cpu.Usage.Total)}
        }</span>,
}

var MetricCpuUsageCores = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/usage_millicores",
                Description: "Cumulative CPU usage on all cores averaged over time window",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Millicores,
        },
}

var MetricEphemeralStorageUsage = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/usage",
                Description: "Ephemeral storage usage",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
}
var MetricMemoryUsage = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/usage",
                Description: "Total memory usage",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.Usage)}
        }</span>,
}

var MetricMemoryCache = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/cache",
                Description: "Cache memory",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.Cache)}
        }</span>,
}

var MetricMemoryRSS = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/rss",
                Description: "RSS memory",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.RSS)}
        }</span>,
}

var MetricMemoryWorkingSet = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/working_set",
                Description: "Total working set usage. Working set is the memory being used and not easily dropped by the kernel",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.WorkingSet)}
        }</span>,
}

var MetricMemoryPageFaults = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/page_faults",
                Description: "Number of page faults",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.ContainerData.Pgfault)}
        }</span>,
}

var MetricMemoryMajorPageFaults = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/major_page_faults",
                Description: "Number of major page faults",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasMemory
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(stat.Memory.ContainerData.Pgmajfault)}
        }</span>,
}

var MetricNetworkRx = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/rx",
                Description: "Cumulative number of bytes received over the network",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasNetwork
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                var rxBytes uint64 = 0
                for _, interfaceStat := range stat.Network.Interfaces </span><span class="cov0" title="0">{
                        rxBytes += interfaceStat.RxBytes
                }</span>
                <span class="cov0" title="0">return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(rxBytes),
                }</span>
        },
}

var MetricNetworkRxErrors = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/rx_errors",
                Description: "Cumulative number of errors while receiving over the network",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasNetwork
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                var rxErrors uint64 = 0
                for _, interfaceStat := range stat.Network.Interfaces </span><span class="cov0" title="0">{
                        rxErrors += interfaceStat.RxErrors
                }</span>
                <span class="cov0" title="0">return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(rxErrors),
                }</span>
        },
}

var MetricNetworkTx = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/tx",
                Description: "Cumulative number of bytes sent over the network",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasNetwork
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                var txBytes uint64 = 0
                for _, interfaceStat := range stat.Network.Interfaces </span><span class="cov0" title="0">{
                        txBytes += interfaceStat.TxBytes
                }</span>
                <span class="cov0" title="0">return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(txBytes),
                }</span>
        },
}

var MetricNetworkTxErrors = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/tx_errors",
                Description: "Cumulative number of errors while sending over the network",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasValue: func(spec *cadvisor.ContainerSpec) bool <span class="cov0" title="0">{
                return spec.HasNetwork
        }</span>,
        GetValue: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) Value <span class="cov0" title="0">{
                var txErrors uint64 = 0
                for _, interfaceStat := range stat.Network.Interfaces </span><span class="cov0" title="0">{
                        txErrors += interfaceStat.TxErrors
                }</span>
                <span class="cov0" title="0">return Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(txErrors),
                }</span>
        },
}

// Definition of Additional Metrics.
var MetricCpuRequest = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/request",
                Description: "CPU request (the guaranteed amount of resources) in millicores. This metric is Kubernetes specific.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricCpuLimit = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/limit",
                Description: "CPU hard limit in millicores.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricMemoryRequest = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/request",
                Description: "Memory request (the guaranteed amount of resources) in bytes. This metric is Kubernetes specific.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
}

var MetricMemoryLimit = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/limit",
                Description: "Memory hard limit in bytes.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
}

var MetricEphemeralStorageRequest = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/request",
                Description: "ephemeral storage request (the guaranteed amount of resources) in bytes. This metric is Kubernetes specific.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
}

var MetricEphemeralStorageLimit = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/limit",
                Description: "ephemeral storage hard limit in bytes.",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
}

// Definition of Rate Metrics.
var MetricCpuUsageRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/usage_rate",
                Description: "CPU usage on all cores in millicores",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricMemoryPageFaultsRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/page_faults_rate",
                Description: "Rate of page faults in counts per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricMemoryMajorPageFaultsRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/major_page_faults_rate",
                Description: "Rate of major page faults in counts per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNetworkRxRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/rx_rate",
                Description: "Rate of bytes received over the network in bytes per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNetworkRxErrorsRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/rx_errors_rate",
                Description: "Rate of errors sending over the network in errors per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNetworkTxRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/tx_rate",
                Description: "Rate of bytes transmitted over the network in bytes per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNetworkTxErrorsRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "network/tx_errors_rate",
                Description: "Rate of errors transmitting over the network in errors per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeCpuCapacity = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/node_capacity",
                Description: "Cpu capacity of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeMemoryCapacity = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/node_capacity",
                Description: "Memory capacity of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeEphemeralStorageCapacity = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/node_capacity",
                Description: "Ephemeral storage capacity of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeCpuAllocatable = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/node_allocatable",
                Description: "Cpu allocatable of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeMemoryAllocatable = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/node_allocatable",
                Description: "Memory allocatable of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeEphemeralStorageAllocatable = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/node_allocatable",
                Description: "Ephemeral storage allocatable of a node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeCpuUtilization = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/node_utilization",
                Description: "Cpu utilization as a share of node capacity",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeMemoryUtilization = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/node_utilization",
                Description: "Memory utilization as a share of memory capacity",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeEphemeralStorageUtilization = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/node_utilization",
                Description: "Ephemeral storage utilization as a share of storage capacity",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeCpuReservation = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "cpu/node_reservation",
                Description: "Share of cpu that is reserved on the node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeMemoryReservation = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "memory/node_reservation",
                Description: "Share of memory that is reserved on the node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeEphemeralStorageReservation = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "ephemeral_storage/node_reservation",
                Description: "Share of ephemeral storage that is reserved on the node",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
        },
}

var MetricNodeCondition = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "status/condition",
                Description: "Node conditions",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricPodPhase = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "status/phase",
                Description: "Phase of pods",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricContainerStatus = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "status",
                Description: "Container status",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

// Aggregated count metrics
var MetricPodCount = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "pod/count",
                Description: "Count of pods",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

var MetricPodContainerCount = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "pod_container/count",
                Description: "Count of pod containers",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
}

// LabeledValue metrics

var MetricFilesystemUsage = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "filesystem/usage",
                Description: "Total number of bytes consumed on a filesystem",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasFilesystem
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Filesystem))
                for _, fs := range stat.Filesystem </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "filesystem/usage",
                                Labels: map[string]string{
                                        LabelResourceID.Key: fs.Device,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(fs.Usage),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricFilesystemLimit = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "filesystem/limit",
                Description: "The total size of filesystem in bytes",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasFilesystem
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Filesystem))
                for _, fs := range stat.Filesystem </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "filesystem/limit",
                                Labels: map[string]string{
                                        LabelResourceID.Key: fs.Device,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(fs.Limit),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricFilesystemAvailable = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "filesystem/available",
                Description: "The number of available bytes remaining in a the filesystem",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasFilesystem
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Filesystem))
                for _, fs := range stat.Filesystem </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "filesystem/available",
                                Labels: map[string]string{
                                        LabelResourceID.Key: fs.Device,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(fs.Available),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricFilesystemInodes = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "filesystem/inodes",
                Description: "Total number of inodes on a filesystem",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasFilesystem
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := []LabeledValue{}
                for _, fs := range stat.Filesystem </span><span class="cov0" title="0">{
                        if fs.HasInodes </span><span class="cov0" title="0">{
                                result = append(result, LabeledValue{
                                        Name: "filesystem/inodes",
                                        Labels: map[string]string{
                                                LabelResourceID.Key: fs.Device,
                                        },
                                        Value: Value{
                                                ValueType: ValueInt64,
                                                IntValue:  int64(fs.Inodes),
                                        },
                                })
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        },
}

var MetricFilesystemInodesFree = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "filesystem/inodes_free",
                Description: "Free number of inodes on a filesystem",
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasFilesystem
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := []LabeledValue{}
                for _, fs := range stat.Filesystem </span><span class="cov0" title="0">{
                        if fs.HasInodes </span><span class="cov0" title="0">{
                                result = append(result, LabeledValue{
                                        Name: "filesystem/inodes_free",
                                        Labels: map[string]string{
                                                LabelResourceID.Key: fs.Device,
                                        },
                                        Value: Value{
                                                ValueType: ValueInt64,
                                                IntValue:  int64(fs.InodesFree),
                                        },
                                })
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        },
}

var MetricAcceleratorMemoryTotal = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "accelerator/memory_total",
                Description: "Total accelerator memory (in bytes)",
                Labels:      acceleratorLabels,
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                if len(stat.Accelerators) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return true</span>
        },
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Accelerators))
                for _, ac := range stat.Accelerators </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "accelerator/memory_total",
                                Labels: map[string]string{
                                        LabelAcceleratorMake.Key:  ac.Make,
                                        LabelAcceleratorModel.Key: ac.Model,
                                        LabelAcceleratorID.Key:    ac.ID,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(ac.MemoryTotal),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricAcceleratorMemoryUsed = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "accelerator/memory_used",
                Description: "Total accelerator memory allocated (in bytes)",
                Labels:      acceleratorLabels,
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Bytes,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                if len(stat.Accelerators) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return true</span>
        },
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Accelerators))
                for _, ac := range stat.Accelerators </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "accelerator/memory_used",
                                Labels: map[string]string{
                                        LabelAcceleratorMake.Key:  ac.Make,
                                        LabelAcceleratorModel.Key: ac.Model,
                                        LabelAcceleratorID.Key:    ac.ID,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(ac.MemoryUsed),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricAcceleratorDutyCycle = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "accelerator/duty_cycle",
                Description: "Percent of time over the past sample period (10s) during which the accelerator was actively processing",
                Labels:      acceleratorLabels,
                Type:        Gauge,
                ValueType:   ValueInt64,
                Units:       Count,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                if len(stat.Accelerators) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return true</span>
        },
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.Accelerators))
                for _, ac := range stat.Accelerators </span><span class="cov0" title="0">{
                        result = append(result, LabeledValue{
                                Name: "accelerator/duty_cycle",
                                Labels: map[string]string{
                                        LabelAcceleratorMake.Key:  ac.Make,
                                        LabelAcceleratorModel.Key: ac.Model,
                                        LabelAcceleratorID.Key:    ac.ID,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(ac.DutyCycle),
                                },
                        })
                }</span>
                <span class="cov0" title="0">return result</span>
        },
}

var MetricDiskIORead = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "disk/io_read_bytes",
                Description: "Cumulative number of bytes read over disk",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasDiskIo
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.DiskIo.IoServiceBytes))
                for _, ioServiceBytesPerPartition := range stat.DiskIo.IoServiceBytes </span><span class="cov0" title="0">{
                        resourceIDKey := ioServiceBytesPerPartition.Device
                        if resourceIDKey == "" </span><span class="cov0" title="0">{
                                resourceIDKey = fmt.Sprintf("%d:%d", ioServiceBytesPerPartition.Major, ioServiceBytesPerPartition.Minor)
                        }</span>

                        <span class="cov0" title="0">var value uint64
                        if v, exists := ioServiceBytesPerPartition.Stats["Read"]; exists </span><span class="cov0" title="0">{
                                value = v
                        }</span>

                        <span class="cov0" title="0">result = append(result, LabeledValue{
                                Name: "disk/io_read_bytes",
                                Labels: map[string]string{
                                        LabelResourceID.Key: resourceIDKey,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(value),
                                },
                        })</span>
                }
                <span class="cov0" title="0">return result</span>
        },
}

var MetricDiskIOWrite = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "disk/io_write_bytes",
                Description: "Cumulative number of bytes write over disk",
                Type:        Cumulative,
                ValueType:   ValueInt64,
                Units:       Bytes,
                Labels:      metricLabels,
        },
        HasLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) bool <span class="cov0" title="0">{
                return spec.HasDiskIo
        }</span>,
        GetLabeledMetric: func(spec *cadvisor.ContainerSpec, stat *cadvisor.ContainerStats) []LabeledValue <span class="cov0" title="0">{
                result := make([]LabeledValue, 0, len(stat.DiskIo.IoServiceBytes))
                for _, ioServiceBytesPerPartition := range stat.DiskIo.IoServiceBytes </span><span class="cov0" title="0">{
                        resourceIDKey := ioServiceBytesPerPartition.Device
                        if resourceIDKey == "" </span><span class="cov0" title="0">{
                                resourceIDKey = fmt.Sprintf("%d:%d", ioServiceBytesPerPartition.Major, ioServiceBytesPerPartition.Minor)
                        }</span>

                        <span class="cov0" title="0">var value uint64
                        if v, exists := ioServiceBytesPerPartition.Stats["Write"]; exists </span><span class="cov0" title="0">{
                                value = v
                        }</span>

                        <span class="cov0" title="0">result = append(result, LabeledValue{
                                Name: "disk/io_write_bytes",
                                Labels: map[string]string{
                                        LabelResourceID.Key: resourceIDKey,
                                },
                                Value: Value{
                                        ValueType: ValueInt64,
                                        IntValue:  int64(value),
                                },
                        })</span>
                }
                <span class="cov0" title="0">return result</span>
        },
}

var MetricDiskIOReadRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "disk/io_read_bytes_rate",
                Description: "Rate of bytes read over disk in bytes per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
                Labels:      metricLabels,
        },
}

var MetricDiskIOWriteRate = Metric{
        MetricDescriptor: MetricDescriptor{
                Name:        "disk/io_write_bytes_rate",
                Description: "Rate of bytes written over disk in bytes per second",
                Type:        Gauge,
                ValueType:   ValueFloat,
                Units:       Count,
                Labels:      metricLabels,
        },
}

func IsNodeAutoscalingMetric(name string) bool <span class="cov0" title="0">{
        for _, autoscalingMetric := range NodeAutoscalingMetrics </span><span class="cov0" title="0">{
                if autoscalingMetric.MetricDescriptor.Name == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

type MetricDescriptor struct {
        // The unique name of the metric.
        Name string `json:"name,omitempty"`

        // Description of the metric.
        Description string `json:"description,omitempty"`

        // Descriptor of the labels specific to this metric.
        Labels []LabelDescriptor `json:"labels,omitempty"`

        // Type and value of metric data.
        Type      Type      `json:"type,omitempty"`
        ValueType ValueType `json:"value_type,omitempty"`
        Units     Unit      `json:"units,omitempty"`
}

// Metric represents a resource usage stat metric.
type Metric struct {
        MetricDescriptor

        // Returns whether this metric is present.
        HasValue func(*cadvisor.ContainerSpec) bool

        // Returns a slice of internal point objects that contain metric values and associated labels.
        GetValue func(*cadvisor.ContainerSpec, *cadvisor.ContainerStats) Value

        // Returns whether this metric is present.
        HasLabeledMetric func(*cadvisor.ContainerSpec, *cadvisor.ContainerStats) bool

        // Returns a slice of internal point objects that contain metric values and associated labels.
        GetLabeledMetric func(*cadvisor.ContainerSpec, *cadvisor.ContainerStats) []LabeledValue
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package metrics

import (
        "fmt"
)

// ResourceKey is used to group metric sets by a specific k8s resource.
// A ResourceKey should be treated as an opaque identifier.
// A ResourceKey should not be serialized as its format is not public.
type ResourceKey string

func (s ResourceKey) String() string <span class="cov10" title="909">{
        return string(s)
}</span>

func (s ResourceKey) Append(t ResourceKey) ResourceKey <span class="cov3" title="8">{
        return ResourceKey(s.String() + t.String())
}</span>

func PodContainerKey(namespace, podName, containerName string) ResourceKey <span class="cov6" title="47">{
        return ResourceKey(fmt.Sprintf("namespace:%s/pod:%s/container:%s", namespace, podName, containerName))
}</span>

func PodKey(namespace, podName string) ResourceKey <span class="cov6" title="47">{
        return ResourceKey(fmt.Sprintf("namespace:%s/pod:%s", namespace, podName))
}</span>

func NamespaceKey(namespace string) ResourceKey <span class="cov3" title="5">{
        return ResourceKey(fmt.Sprintf("namespace:%s", namespace))
}</span>

func NodeKey(node string) ResourceKey <span class="cov2" title="4">{
        return ResourceKey(fmt.Sprintf("node:%s", node))
}</span>

func NodeContainerKey(node, container string) ResourceKey <span class="cov3" title="6">{
        return ResourceKey(fmt.Sprintf("node:%s/container:%s", node, container))
}</span>

func ClusterKey() ResourceKey <span class="cov3" title="9">{
        return "cluster"
}</span>

type ResourceKeys []ResourceKey

func (s ResourceKeys) Len() int <span class="cov2" title="4">{
        return len(s)
}</span>

func (s ResourceKeys) Less(i, j int) bool <span class="cov9" title="687">{
        return string(s[i]) &lt; string(s[j])
}</span>

func (s ResourceKeys) Swap(i, j int) <span class="cov8" title="297">{
        s[i], s[j] = s[j], s[i]
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package metrics

import "time"

// Set is a collection of metrics tied to a specific resource
type Set struct {
        // CollectionStartTime is a time since when the metrics are collected for this entity.
        // It is affected by events like entity (e.g. pod) creation, entity restart (e.g. for container),
        // Kubelet restart.
        CollectionStartTime time.Time
        // EntityCreateTime is a time of entity creation and persists through entity restarts and
        // Kubelet restarts.
        EntityCreateTime time.Time
        ScrapeTime       time.Time
        Values           map[string]Value
        Labels           map[string]string
        LabeledValues    []LabeledValue
}

// FindLabels returns the labels for a given metric name
func (s *Set) FindLabels(name string) (map[string]string, bool) <span class="cov3" title="8">{
        _, found := s.Values[name]
        if found </span><span class="cov0" title="0">{
                return s.Labels, true
        }</span>
        <span class="cov3" title="8">for _, labeledValue := range s.LabeledValues </span><span class="cov3" title="7">{
                if labeledValue.Name == name </span><span class="cov3" title="7">{
                        labels := make(map[string]string, len(s.Labels)+len(labeledValue.Labels))
                        copyLabels(labels, labeledValue.Labels)
                        copyLabels(labels, s.Labels)
                        return labels, true
                }</span>
        }
        <span class="cov1" title="1">return map[string]string{}, false</span>
}

func (s *Set) Points() int <span class="cov2" title="4">{
        return len(s.Values) + len(s.LabeledValues)
}</span>

func copyLabels(dst, src map[string]string) <span class="cov8" title="512">{
        for k, v := range src </span><span class="cov10" title="2816">{
                dst[k] = v
        }</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/metrics/core/types.go
// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package metrics

import (
        "time"
)

type Type int8

const (
        Cumulative Type = iota
        Gauge
        Delta
)

func (t *Type) String() string <span class="cov0" title="0">{
        switch *t </span>{
        case Cumulative:<span class="cov0" title="0">
                return "cumulative"</span>
        case Gauge:<span class="cov0" title="0">
                return "gauge"</span>
        case Delta:<span class="cov0" title="0">
                return "delta"</span>
        }
        <span class="cov0" title="0">return ""</span>
}

type Unit int8

const (
        Count Unit = iota
        Bytes
        Milliseconds
        Nanoseconds
        Millicores
)

func (u Unit) String() string <span class="cov0" title="0">{
        switch u </span>{
        case Bytes:<span class="cov0" title="0">
                return "bytes"</span>
        case Milliseconds:<span class="cov0" title="0">
                return "ms"</span>
        case Nanoseconds:<span class="cov0" title="0">
                return "ns"</span>
        case Millicores:<span class="cov0" title="0">
                return "millicores"</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// ValueType is used to discriminate whether a Value is an int64 or a float64
type ValueType int8

const (
        ValueInt64 ValueType = iota
        ValueFloat
)

func (valueType *ValueType) String() string <span class="cov0" title="0">{
        switch *valueType </span>{
        case ValueInt64:<span class="cov0" title="0">
                return "int64"</span>
        case ValueFloat:<span class="cov0" title="0">
                return "double"</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Value represents a metric value that is either a float64 or an int64
type Value struct {
        IntValue   int64
        FloatValue float64
        ValueType  ValueType
}

func (v *Value) GetValue() interface{} <span class="cov0" title="0">{
        if ValueInt64 == v.ValueType </span><span class="cov0" title="0">{
                return v.IntValue
        }</span> else<span class="cov0" title="0"> if ValueFloat == v.ValueType </span><span class="cov0" title="0">{
                return v.FloatValue
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

// LabeledValue is a metric value that is either a float64 or an int64 and that has it's own name and values
type LabeledValue struct {
        Name   string
        Labels map[string]string
        Value
}

func (l *LabeledValue) GetValue() interface{} <span class="cov0" title="0">{
        if ValueInt64 == l.ValueType </span><span class="cov0" title="0">{
                return l.IntValue
        }</span> else<span class="cov0" title="0"> if ValueFloat == l.ValueType </span><span class="cov0" title="0">{
                return l.FloatValue
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

// Source produces metric batches
type Source interface {
        AutoDiscovered() bool
        Name() string
        Scrape() (*Batch, error)
        Cleanup()
}

// SourceProvider produces metric sources
type SourceProvider interface {
        GetMetricsSources() []Source
        Name() string
        CollectionInterval() time.Duration
        Timeout() time.Duration
}

// Sink exports metric batches
type Sink interface {
        // Export data to the external storage. The function should be synchronous/blocking and finish only
        // after the given Batch was written. This will allow sink manager to push data only to these
        // sinks that finished writing the previous data.
        Export(*Batch)
}

// Processor should not store any references to anything in *Batch because it is assumed that Processor does not own that memory.
// Other components are free to mutably update *Batch after Process is run.
type Processor interface {
        Name() string
        Process(*Batch) (*Batch, error)
}

// ProviderHandler is an interface for dynamically adding and removing MetricSourceProviders
type ProviderHandler interface {
        AddProvider(provider SourceProvider)
        DeleteProvider(name string)
}

type ProviderFactory interface {
        Name() string
        Build(cfg interface{}) (SourceProvider, error)
}

type ConfigurableSourceProvider interface {
        Configure(interval, timeout time.Duration)
}

//DefaultSourceProvider handle the common providers configuration
type DefaultSourceProvider struct {
        collectionInterval time.Duration
        timeout            time.Duration
}

// CollectionInterval return the provider collection interval configuration
func (sp *DefaultSourceProvider) CollectionInterval() time.Duration <span class="cov6" title="6">{
        return sp.collectionInterval
}</span>

// Timeout return the provider timeout configuration
func (sp *DefaultSourceProvider) Timeout() time.Duration <span class="cov4" title="3">{
        return sp.timeout
}</span>

// Configure the 'collectionInterval' and 'timeout' values
func (sp *DefaultSourceProvider) Configure(interval, timeout time.Duration) <span class="cov10" title="16">{
        sp.collectionInterval = interval // forces default collection interval if zero
        sp.timeout = timeout
        if sp.timeout == 0 </span><span class="cov9" title="14">{
                sp.timeout = 30 * time.Second
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package options

import (
        "fmt"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/flags"
)

// Convert converts options into a configuration instance for backwards compatibility
func (opts *CollectorRunOptions) Convert() (*configuration.Config, error) <span class="cov1" title="1">{
        cfg := &amp;configuration.Config{}
        cfg.DefaultCollectionInterval = opts.MetricResolution
        cfg.FlushInterval = opts.MetricResolution
        cfg.SinkExportDataTimeout = opts.SinkExportDataTimeout
        cfg.EnableDiscovery = opts.EnableDiscovery
        cfg.ScrapeCluster = opts.AgentType.ScrapeCluster()

        if len(opts.Sources) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing sources")
        }</span>
        <span class="cov1" title="1">if len(opts.Sinks) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing sink")
        }</span>

        <span class="cov1" title="1">addSources(cfg, opts.Sources)
        addSinks(cfg, opts.Sinks)
        addInternalStatsSource(cfg, opts.InternalStatsPrefix)
        extractSinkProperties(cfg)

        if opts.EnableDiscovery </span><span class="cov1" title="1">{
                cfg.DiscoveryConfig.EnableRuntimePlugins = opts.EnableRuntimeConfigs
                if cfg.DiscoveryConfig.DiscoveryInterval == 0 </span><span class="cov1" title="1">{
                        cfg.DiscoveryConfig.DiscoveryInterval = 5 * time.Minute
                }</span>
                <span class="cov1" title="1">if opts.DiscoveryConfigFile != "" </span><span class="cov0" title="0">{
                        cfg.DiscoveryConfig.PluginConfigs = loadDiscoveryFileOrDie(opts.DiscoveryConfigFile)
                }</span>
        }
        <span class="cov1" title="1">return cfg, nil</span>
}

// backwards compatibility: discovery config used to be a separate file. Now part of main config file.
func loadDiscoveryFileOrDie(file string) []discovery.PluginConfig <span class="cov0" title="0">{
        cfg, err := discovery.FromFile(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error loading discovery configuration: %v", err)
        }</span>
        <span class="cov0" title="0">discovery.ConvertPromToPlugin(cfg)
        return cfg.PluginConfigs</span>
}

// backwards compatibility:
// 1. Sink level prefix used to only apply towards kubernetes.summary_api metrics
// this is now set on the kubernetes source. sink level prefixes now apply globally.
// 2. clusterName used to be specified on the sink. Now a top level property.
func extractSinkProperties(cfg *configuration.Config) <span class="cov1" title="1">{
        if len(cfg.Sinks) == 0 </span><span class="cov0" title="0">{
                log.Fatalf("no sink configured")
        }</span>
        <span class="cov1" title="1">sink := cfg.Sinks[0]
        prefix := sink.Prefix
        if prefix != "" </span><span class="cov1" title="1">{
                // remove it from the sink
                sink.Prefix = ""

                // set it on the kubernetes source
                cfg.Sources.SummaryConfig.Prefix = prefix
        }</span>
        <span class="cov1" title="1">cfg.ClusterName = sink.ClusterName</span>
}

func addSources(cfg *configuration.Config, sources flags.Uris) <span class="cov1" title="1">{
        cfg.Sources = &amp;configuration.SourceConfig{}
        for _, src := range sources </span><span class="cov1" title="1">{
                switch src.Key </span>{
                case "kubernetes.summary_api":<span class="cov1" title="1">
                        addSummarySource(cfg, src)</span>
                case "kubernetes.state":<span class="cov0" title="0">
                        addStateSource(cfg, src)</span>
                case "prometheus":<span class="cov0" title="0">
                        addPrometheusSource(cfg, src)</span>
                case "kubernetes.cadvisor":<span class="cov0" title="0">
                        addCadvisorSource(cfg, src)</span>
                case "telegraf":<span class="cov0" title="0">
                        addTelegrafSource(cfg, src)</span>
                case "systemd":<span class="cov0" title="0">
                        addSystemdSource(cfg, src)</span>
                default:<span class="cov0" title="0">
                        log.Errorf("invalid source: %s", src.Key)
                        return</span>
                }
        }
}

func addSummarySource(cfg *configuration.Config, uri flags.Uri) <span class="cov4" title="2">{
        vals := uri.Val.Query()
        summary := &amp;configuration.SummarySourceConfig{
                KubeletPort:       flags.DecodeValue(vals, "kubeletPort"),
                KubeletHttps:      flags.DecodeValue(vals, "kubeletHttps"),
                InClusterConfig:   flags.DecodeValue(vals, "inClusterConfig"),
                UseServiceAccount: flags.DecodeValue(vals, "useServiceAccount"),
                Insecure:          flags.DecodeValue(vals, "insecure"),
                Auth:              flags.DecodeValue(vals, "auth"),
                Transforms:        getTransforms(vals),
        }
        if uri.Val.Scheme != "" </span><span class="cov4" title="2">{
                u := uri.Val
                summary.URL = fmt.Sprintf("%s://%s%s", u.Scheme, u.Host, u.Path)
        }</span>
        <span class="cov4" title="2">cfg.Sources.SummaryConfig = summary</span>
}

func addStateSource(cfg *configuration.Config, uri flags.Uri) <span class="cov4" title="2">{
        vals := uri.Val.Query()
        state := &amp;configuration.KubernetesStateSourceConfig{
                Transforms: getTransforms(vals),
        }
        cfg.Sources.StateConfig = state
}</span>

func addPrometheusSource(cfg *configuration.Config, uri flags.Uri) <span class="cov1" title="1">{
        vals := uri.Val.Query()
        prom := &amp;configuration.PrometheusSourceConfig{
                URL:        flags.DecodeValue(vals, "url"),
                Transforms: getTransforms(vals),
        }
        cfg.Sources.PrometheusConfigs = append(cfg.Sources.PrometheusConfigs, prom)
}</span>

func addCadvisorSource(cfg *configuration.Config, uri flags.Uri) <span class="cov1" title="1">{
        vals := uri.Val.Query()
        cadvisor := &amp;configuration.CadvisorSourceConfig{
                Transforms: getTransforms(vals),
        }
        cfg.Sources.CadvisorConfig = cadvisor
}</span>

func addTelegrafSource(cfg *configuration.Config, uri flags.Uri) <span class="cov0" title="0">{
        vals := uri.Val.Query()
        tel := &amp;configuration.TelegrafSourceConfig{
                Transforms: getTransforms(vals),
        }
        plugins := flags.DecodeValue(vals, "plugins")
        if len(plugins) &gt; 0 </span><span class="cov0" title="0">{
                tel.Plugins = strings.Split(plugins, ",")
        }</span>
        <span class="cov0" title="0">cfg.Sources.TelegrafConfigs = append(cfg.Sources.TelegrafConfigs, tel)</span>
}

func addSystemdSource(cfg *configuration.Config, uri flags.Uri) <span class="cov0" title="0">{
        vals := uri.Val.Query()
        systemd := &amp;configuration.SystemdSourceConfig{
                IncludeTaskMetrics:      flags.DecodeBoolean(vals, "taskMetrics"),
                IncludeRestartMetrics:   flags.DecodeBoolean(vals, "restartMetrics"),
                IncludeStartTimeMetrics: flags.DecodeBoolean(vals, "startTimeMetrics"),
                UnitAllowList:           vals["unitWhitelist"],
                UnitDenyList:            vals["unitBlacklist"],
                Transforms:              getTransforms(vals),
        }
        cfg.Sources.SystemdConfig = systemd
}</span>

func addInternalStatsSource(cfg *configuration.Config, prefix string) <span class="cov1" title="1">{
        cfg.Sources.StatsConfig = &amp;configuration.StatsSourceConfig{
                Transforms: configuration.Transforms{
                        Prefix: prefix,
                },
        }
}</span>

func addSinks(cfg *configuration.Config, sinks flags.Uris) <span class="cov1" title="1">{
        for _, sink := range sinks </span><span class="cov1" title="1">{
                switch sink.Key </span>{
                case "wavefront":<span class="cov1" title="1">
                        addWavefrontSink(cfg, sink)</span>
                default:<span class="cov0" title="0">
                        return</span>
                }
        }
}

func addWavefrontSink(cfg *configuration.Config, uri flags.Uri) <span class="cov1" title="1">{
        sink := &amp;configuration.WavefrontSinkConfig{}
        vals := uri.Val.Query()

        sink.Server = flags.DecodeValue(vals, "server")
        sink.Token = flags.DecodeValue(vals, "token")
        sink.ProxyAddress = flags.DecodeValue(vals, "proxyAddress")
        sink.ClusterName = flags.DecodeValue(vals, "clusterName")
        sink.Transforms = getTransforms(vals)

        cfg.Sinks = append(cfg.Sinks, sink)
}</span>

func getTransforms(vals map[string][]string) configuration.Transforms <span class="cov10" title="8">{
        return configuration.Transforms{
                Prefix:  flags.DecodeValue(vals, "prefix"),
                Source:  flags.DecodeValue(vals, "source"),
                Tags:    flags.DecodeTags(vals),
                Filters: filter.FromQuery(vals),
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package options

import "errors"

type AgentType string

const (
        AllAgentType     AgentType = "all"
        ClusterAgentType AgentType = "cluster"
        NodeAgentType    AgentType = "node"
        LegacyAgentType  AgentType = "legacy"
)

var InvalidAgentTypeErr = errors.New("--agent can only be node, cluster, all or legacy")

func NewAgentType(value string) (AgentType, error) <span class="cov8" title="7">{
        switch value </span>{
        case "all":<span class="cov1" title="1">
                return AllAgentType, nil</span>
        case "cluster":<span class="cov3" title="2">
                return ClusterAgentType, nil</span>
        case "node":<span class="cov3" title="2">
                return NodeAgentType, nil</span>
        case "legacy":<span class="cov3" title="2">
                return LegacyAgentType, nil</span>
        }
        <span class="cov1" title="1">return "", InvalidAgentTypeErr</span>
}

func (a AgentType) String() string <span class="cov10" title="10">{
        return string(a)
}</span>

func (a *AgentType) Set(value string) error <span class="cov8" title="7">{
        var err error
        *a, err = NewAgentType(value)
        return err
}</span>

func (a AgentType) Type() string <span class="cov0" title="0">{
        return "string"
}</span>

func (a AgentType) ScrapeCluster() bool <span class="cov9" title="8">{
        return a == AllAgentType || a == LegacyAgentType || a == ClusterAgentType
}</span>

func (a AgentType) ScrapeNodes() string <span class="cov0" title="0">{
        switch a </span>{
        case AllAgentType:<span class="cov0" title="0">
                return "all"</span>

        case LegacyAgentType:<span class="cov0" title="0">
                fallthrough</span>
        case NodeAgentType:<span class="cov0" title="0">
                return "own"</span>

        case ClusterAgentType:<span class="cov0" title="0">
                fallthrough</span>
        default:<span class="cov0" title="0">
                return "none"</span>
        }
}

func (a AgentType) ScrapeAnyNodes() bool <span class="cov6" title="4">{
        return a != ClusterAgentType
}</span>

func (a AgentType) ScrapeOnlyOwnNode() bool <span class="cov6" title="4">{
        return a == LegacyAgentType || a == NodeAgentType
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package options

import (
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/spf13/pflag"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/flags"
)

var DaemonAndAgentErr = errors.New("cannot set --daemon with --agent")

type CollectorRunOptions struct {
        // supported flags
        Version         bool
        EnableProfiling bool
        daemon          bool
        AgentType       AgentType
        ConfigFile      string
        LogLevel        string
        MaxProcs        int

        // An experimental flag for forcing a garbage collection and releasing memory.
        // See https://utcc.utoronto.ca/~cks/space/blog/programming/GoNoMemoryFreeing for reference.
        // Basically Go holds on to more memory than is necessary resulting in larger heap usage.
        // Enabling this flag causes the collector to call debug.FreeOSMemory after every sink.send() call.
        // Go 1.13 showed a 30% lower memory usage vs Go 1.12. Enabling this flag was observed to result in a further ~30%
        // reduction in memory usage but the impact of forcing a GC run so frequently has not been thoroughly tested.
        ForceGC bool

        // deprecated flags
        MetricResolution      time.Duration
        Sources               flags.Uris
        Sinks                 flags.Uris
        SinkExportDataTimeout time.Duration
        EnableDiscovery       bool
        EnableRuntimeConfigs  bool
        DiscoveryConfigFile   string
        InternalStatsPrefix   string
        ScrapeTimeout         time.Duration
        logLevel              int
}

func NewCollectorRunOptions() *CollectorRunOptions <span class="cov9" title="9">{
        return &amp;CollectorRunOptions{
                AgentType: AllAgentType,
        }
}</span>

func (opts *CollectorRunOptions) Parse(fs *pflag.FlagSet, args []string) error <span class="cov10" title="10">{
        // supported flags
        fs.BoolVar(&amp;opts.Version, "version", false, "print version info and exit")
        fs.BoolVar(&amp;opts.EnableProfiling, "profile", false, "enable pprof")
        fs.BoolVar(&amp;opts.daemon, "daemon", false, "enable daemon mode")
        fs.Var(&amp;opts.AgentType, "agent", "the agent type (node, cluster, all, legacy)")
        fs.StringVar(&amp;opts.ConfigFile, "config-file", "", "required configuration file")
        fs.StringVar(&amp;opts.LogLevel, "log-level", "info", "one of info, debug or trace")
        fs.IntVar(&amp;opts.MaxProcs, "max-procs", 0, "max number of CPUs that can be used simultaneously. Less than 1 for default (number of cores)")
        fs.BoolVar(&amp;opts.ForceGC, "force-gc", false, "experimental flag that periodically forces the release of unused memory")

        // deprecated flags
        fs.DurationVar(&amp;opts.MetricResolution, "metric-resolution", 60*time.Second, "The resolution at which the collector will collect metrics")
        fs.MarkDeprecated("metric-resolution", "set defaultCollectionInterval in configuration file")
        fs.Var(&amp;opts.Sources, "source", "source(s) to watch")
        fs.MarkDeprecated("source", "set sources in configuration file")
        fs.Var(&amp;opts.Sinks, "sink", "external sink(s) that receive data")
        fs.MarkDeprecated("sink", "set sinks in configuration file")
        fs.DurationVar(&amp;opts.SinkExportDataTimeout, "sink-export-data-timeout", 20*time.Second, "Timeout for exporting data to a sink")
        fs.MarkDeprecated("sink-export-data-timeout", "set sinkExportDataTimeout in configuration file")
        fs.BoolVar(&amp;opts.EnableDiscovery, "enable-discovery", true, "enable auto discovery")
        fs.MarkDeprecated("enable-discovery", "set enableDiscovery in configuration file")
        fs.BoolVar(&amp;opts.EnableRuntimeConfigs, "enable-runtime-configs", false, "enable runtime configs")
        fs.MarkDeprecated("enable-runtime-configs", "set enable-runtime-configs in configuration file")
        fs.StringVar(&amp;opts.DiscoveryConfigFile, "discovery-config", "", "optional discovery configuration file")
        fs.MarkDeprecated("discovery-config", "set discovery_configs in configuration file")
        fs.StringVar(&amp;opts.InternalStatsPrefix, "internal-stats-prefix", "kubernetes.", "optional prefix for internal collector stats")
        fs.MarkDeprecated("internal-stats-prefix", "set internal_stats_source in configuration file")
        fs.DurationVar(&amp;opts.ScrapeTimeout, "scrape-timeout", 20*time.Second, "The per-source scrape timeout")
        fs.MarkDeprecated("scrape-timeout", "set in configuration file")
        fs.IntVar(&amp;opts.logLevel, "v", 2, "log level for V logs")
        fs.MarkDeprecated("v", "use log-level instead")

        if err := fs.Parse(args); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="9">if err := opts.handleDaemonFlag(fs); err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov8" title="7">return nil</span>
}

func (opts *CollectorRunOptions) handleDaemonFlag(fs *pflag.FlagSet) error <span class="cov9" title="9">{
        if fs.Changed("daemon") &amp;&amp; fs.Changed("agent") </span><span class="cov3" title="2">{
                return DaemonAndAgentErr
        }</span>

        <span class="cov8" title="7">if fs.Changed("daemon") </span><span class="cov3" title="2">{
                if opts.daemon </span><span class="cov1" title="1">{
                        opts.AgentType = LegacyAgentType
                }</span> else<span class="cov1" title="1"> {
                        opts.AgentType = AllAgentType
                }</span>
        }

        <span class="cov8" title="7">return nil</span>
}

func Parse() *CollectorRunOptions <span class="cov1" title="1">{
        opts := NewCollectorRunOptions()
        fs := pflag.NewFlagSet(os.Args[0], pflag.ContinueOnError)
        if err := opts.Parse(fs, os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(2)
        }</span>
        <span class="cov1" title="1">return opts</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package util

import (
        "errors"
        "strings"
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/events"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

type DummySink struct {
        name        string
        mutex       sync.Mutex
        exportCount int
        stopped     bool
        latency     time.Duration
}

func (dummy *DummySink) Name() string <span class="cov10" title="42">{
        return dummy.name
}</span>
func (dummy *DummySink) Export(*metrics.Batch) <span class="cov4" title="5">{
        dummy.mutex.Lock()
        dummy.exportCount++
        dummy.mutex.Unlock()

        time.Sleep(dummy.latency)
}</span>

func (dummy *DummySink) ExportEvent(*events.Event) {<span class="cov0" title="0">
}</span>

func (dummy *DummySink) Stop() <span class="cov2" title="2">{
        dummy.mutex.Lock()
        dummy.stopped = true
        dummy.mutex.Unlock()

        time.Sleep(dummy.latency)
}</span>

func (dummy *DummySink) IsStopped() bool <span class="cov2" title="2">{
        dummy.mutex.Lock()
        defer dummy.mutex.Unlock()
        return dummy.stopped
}</span>

func (dummy *DummySink) GetExportCount() int <span class="cov5" title="6">{
        dummy.mutex.Lock()
        defer dummy.mutex.Unlock()
        return dummy.exportCount
}</span>

func NewDummySink(name string, latency time.Duration) *DummySink <span class="cov6" title="8">{
        return &amp;DummySink{
                name:        name,
                latency:     latency,
                exportCount: 0,
                stopped:     false,
        }
}</span>

type DummyMetricsSource struct {
        latency          time.Duration
        metricSet        metrics.Set
        name             string
        autoDiscovered   bool
        raiseScrapeError bool
}

func (dummy *DummyMetricsSource) AutoDiscovered() bool <span class="cov2" title="2">{
        return dummy.autoDiscovered
}</span>

func (dummy *DummyMetricsSource) Name() string <span class="cov8" title="25">{
        return dummy.name
}</span>

func (src *DummyMetricsSource) Cleanup() {<span class="cov4" title="4">}</span>

func (dummy *DummyMetricsSource) Scrape() (*metrics.Batch, error) <span class="cov6" title="8">{
        time.Sleep(dummy.latency)

        if dummy.raiseScrapeError </span><span class="cov2" title="2">{
                return nil, errors.New("scrape error")
        }</span>

        <span class="cov4" title="5">point := wf.NewPoint(
                strings.Replace(dummy.Name(), " ", ".", -1),
                1,
                time.Now().UnixNano()/1000,
                dummy.Name(),
                map[string]string{"tag": "tag"},
        )

        res := &amp;metrics.Batch{
                Timestamp: time.Now(),
        }
        res.Metrics = append(res.Metrics, point)
        return res, nil</span>
}

func newDummyMetricSet(name string) metrics.Set <span class="cov6" title="8">{
        return metrics.Set{
                Values: map[string]metrics.Value{},
                Labels: map[string]string{
                        "name": name,
                },
        }
}</span>

func NewDummyMetricsSource(name string, latency time.Duration) *DummyMetricsSource <span class="cov5" title="6">{
        return &amp;DummyMetricsSource{
                latency:          latency,
                metricSet:        newDummyMetricSet(name),
                name:             name,
                autoDiscovered:   false,
                raiseScrapeError: false,
        }
}</span>

func NewDummyMetricsSourceWithError(name string, latency time.Duration, autoDiscovered bool) *DummyMetricsSource <span class="cov2" title="2">{
        return &amp;DummyMetricsSource{
                latency:          latency,
                metricSet:        newDummyMetricSet(name),
                name:             name,
                autoDiscovered:   autoDiscovered,
                raiseScrapeError: true,
        }
}</span>

type DummyMetricsSourceProvider struct {
        sources           []metrics.Source
        collectionIterval time.Duration
        timeout           time.Duration
        name              string
}

func (dummy *DummyMetricsSourceProvider) GetMetricsSources() []metrics.Source <span class="cov5" title="7">{
        return dummy.sources
}</span>

func (dummy *DummyMetricsSourceProvider) Name() string <span class="cov2" title="2">{
        return dummy.name
}</span>

func (dummy *DummyMetricsSourceProvider) CollectionInterval() time.Duration <span class="cov5" title="6">{
        return dummy.collectionIterval
}</span>

func (dummy *DummyMetricsSourceProvider) Timeout() time.Duration <span class="cov5" title="6">{
        return dummy.timeout
}</span>

func NewDummyMetricsSourceProvider(name string, collectionIterval, timeout time.Duration, sources ...metrics.Source) metrics.SourceProvider <span class="cov4" title="4">{
        return &amp;DummyMetricsSourceProvider{
                sources:           sources,
                collectionIterval: collectionIterval,
                timeout:           timeout,
                name:              name,
        }
}</span>

type DummyDataProcessor struct {
        latency time.Duration
}

func (dummy *DummyDataProcessor) Name() string <span class="cov0" title="0">{
        return "dummy"
}</span>

func (dummy *DummyDataProcessor) Process(data *metrics.Batch) (*metrics.Batch, error) <span class="cov4" title="5">{
        time.Sleep(dummy.latency)
        return data, nil
}</span>

func NewDummyDataProcessor(latency time.Duration) *DummyDataProcessor <span class="cov1" title="1">{
        return &amp;DummyDataProcessor{
                latency: latency,
        }
}</span>

func NewDummyProviderHandler(count int) *DummyProviderHandler <span class="cov4" title="5">{
        return &amp;DummyProviderHandler{
                count: count,
        }
}</span>

type DummyProviderHandler struct {
        count int
}

func (d *DummyProviderHandler) AddProvider(provider metrics.SourceProvider) <span class="cov0" title="0">{
        d.count += 1
}</span>

func (d *DummyProviderHandler) DeleteProvider(name string) <span class="cov0" title="0">{
        d.count -= 1
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package util

import (
        "fmt"
        "sort"
        "strings"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

// LabelCopier maps kubernetes objects' labels to metrics
type LabelCopier struct {
        // labelSeparator contains separator used to join labels into "labels" label
        labelSeparator string
        // storedLabels maps source label names to their destination names used in metrics
        storedLabels map[string]string
        // ignoredLabels contains labels to be skipped during concatenation
        ignoredLabels map[string]string
}

// Copy copies the given set of pod labels into a set of metric labels, using the following logic:
// - all labels, unless found in ignoredLabels, are concatenated into a Separator-separated key:value pairs and stored under metrics.LabelLabels.Key
// - labels found in storedLabels are additionally stored under key provided
func (copier *LabelCopier) Copy(in map[string]string, out map[string]string) <span class="cov3" title="5">{
        labels := make([]string, 0, len(in))

        for key, value := range in </span><span class="cov10" title="396">{
                if mappedKey, exists := copier.storedLabels[key]; exists </span><span class="cov4" title="8">{
                        out[mappedKey] = value
                }</span>

                <span class="cov10" title="396">if _, exists := copier.ignoredLabels[key]; !exists </span><span class="cov10" title="396">{
                        labels = append(labels, fmt.Sprintf("%s:%s", key, value))
                }</span>
        }

        <span class="cov3" title="5">sort.Strings(labels)
        out[metrics.LabelLabels.Key] = strings.Join(labels, copier.labelSeparator)</span>
}

// makeStoredLabels converts labels into a map for quicker retrieval.
// Incoming labels, if desired, may contain mappings in format "newName=oldName"
func makeStoredLabels(labels []string) map[string]string <span class="cov3" title="5">{
        storedLabels := make(map[string]string)
        for _, s := range labels </span><span class="cov4" title="10">{
                split := strings.SplitN(s, "=", 2)
                if len(split) == 1 </span><span class="cov4" title="8">{
                        storedLabels[split[0]] = split[0]
                }</span> else<span class="cov2" title="2"> {
                        storedLabels[split[1]] = split[0]
                }</span>
        }
        <span class="cov3" title="5">return storedLabels</span>
}

// makeIgnoredLabels converts label slice into a map for later use.
func makeIgnoredLabels(labels []string) map[string]string <span class="cov3" title="5">{
        ignoredLabels := make(map[string]string)
        for _, s := range labels </span><span class="cov3" title="7">{
                ignoredLabels[s] = ""
        }</span>
        <span class="cov3" title="5">return ignoredLabels</span>
}

// NewLabelCopier creates a new instance of LabelCopier type
func NewLabelCopier(separator string, storedLabels, ignoredLabels []string) (*LabelCopier, error) <span class="cov3" title="5">{
        return &amp;LabelCopier{
                labelSeparator: separator,
                storedLabels:   makeStoredLabels(storedLabels),
                ignoredLabels:  makeIgnoredLabels(ignoredLabels),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package util

// What is an interner? Is that a thing? Good question, here's a good description
// https://en.wikipedia.org/wiki/String_interning
type StringInterner map[string]*string

func NewStringInterner() StringInterner <span class="cov1" title="3">{
        return make(map[string]*string)
}</span>

func (interner StringInterner) Intern(s string) *string <span class="cov10" title="5706470">{
        if interned, ok := interner[s]; ok </span><span class="cov9" title="5696860">{
                return interned
        }</span>
        <span class="cov1" title="4">interner[s] = &amp;s
        return &amp;s</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package util

import (
        "fmt"
        "net"
        "os"
        "strings"
        "sync"
        "time"

        log "github.com/sirupsen/logrus"

        kube_api "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/kubernetes"
        v1listers "k8s.io/client-go/listers/core/v1"
        "k8s.io/client-go/tools/cache"
)

const (
        NodeNameEnvVar           = "POD_NODE_NAME"
        NamespaceNameEnvVar      = "POD_NAMESPACE_NAME"
        InstallationMethodEnvVar = "INSTALLATION_METHOD"
        ForceGC                  = "FORCE_GC"
        KubernetesVersionEnvVar  = "KUBERNETES_VERSION"
        KubernetesProviderEnvVar = "KUBERNETES_PROVIDER"
)

const (
        POD_PHASE_PENDING = iota + 1
        POD_PHASE_RUNNING
        POD_PHASE_SUCCEEDED
        POD_PHASE_FAILED
        POD_PHASE_UNKNOWN
)

const (
        CONTAINER_STATE_RUNNING = iota + 1
        CONTAINER_STATE_WAITING
        CONTAINER_STATE_TERMINATED
)

var (
        lock       sync.Mutex
        nodeLister v1listers.NodeLister
        reflector  *cache.Reflector
        podLister  v1listers.PodLister
        nsStore    cache.Store
        agentType  AgentType
)

type AgentType interface {
        ScrapeCluster() bool
        ScrapeAnyNodes() bool
        ScrapeOnlyOwnNode() bool
}

func GetNodeLister(kubeClient kubernetes.Interface) (v1listers.NodeLister, *cache.Reflector, error) <span class="cov3" title="3">{
        lock.Lock()
        defer lock.Unlock()

        // init just one instance per collector agent
        if nodeLister != nil </span><span class="cov2" title="2">{
                return nodeLister, reflector, nil
        }</span>

        <span class="cov1" title="1">fieldSelector := GetFieldSelector("nodes")
        lw := cache.NewListWatchFromClient(kubeClient.CoreV1().RESTClient(), "nodes", kube_api.NamespaceAll, fieldSelector)
        store := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
        nodeLister = v1listers.NewNodeLister(store)
        reflector = cache.NewReflector(lw, &amp;kube_api.Node{}, store, time.Hour)
        go reflector.Run(NeverStop)
        return nodeLister, reflector, nil</span>
}

func GetPodLister(kubeClient kubernetes.Interface) (v1listers.PodLister, error) <span class="cov1" title="1">{
        lock.Lock()
        defer lock.Unlock()

        // init just one instance per collector agent
        if podLister != nil </span><span class="cov0" title="0">{
                return podLister, nil
        }</span>

        <span class="cov1" title="1">fieldSelector := GetFieldSelector("pods")
        lw := cache.NewListWatchFromClient(kubeClient.CoreV1().RESTClient(), "pods", kube_api.NamespaceAll, fieldSelector)
        store := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
        podLister = v1listers.NewPodLister(store)
        reflector := cache.NewReflector(lw, &amp;kube_api.Pod{}, store, time.Hour)
        go reflector.Run(NeverStop)
        return podLister, nil</span>
}

func GetServiceLister(kubeClient kubernetes.Interface) (v1listers.ServiceLister, error) <span class="cov1" title="1">{
        lw := cache.NewListWatchFromClient(kubeClient.CoreV1().RESTClient(), "services", kube_api.NamespaceAll, fields.Everything())
        store := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})
        serviceLister := v1listers.NewServiceLister(store)
        reflector := cache.NewReflector(lw, &amp;kube_api.Service{}, store, time.Hour)
        go reflector.Run(NeverStop)
        return serviceLister, nil
}</span>

func GetNamespaceStore(kubeClient kubernetes.Interface) cache.Store <span class="cov1" title="1">{
        lock.Lock()
        defer lock.Unlock()

        // init just once per collector agent
        if nsStore != nil </span><span class="cov0" title="0">{
                return nsStore
        }</span>

        <span class="cov1" title="1">lw := cache.NewListWatchFromClient(kubeClient.CoreV1().RESTClient(), "namespaces", kube_api.NamespaceAll, fields.Everything())
        nsStore = cache.NewStore(cache.MetaNamespaceKeyFunc)
        reflector := cache.NewReflector(lw, &amp;kube_api.Namespace{}, nsStore, time.Hour)
        go reflector.Run(NeverStop)
        return nsStore</span>
}

func GetFieldSelector(resourceType string) fields.Selector <span class="cov3" title="3">{
        fieldSelector := fields.Everything()
        nodeName := GetNodeName()
        if ScrapeOnlyOwnNode() &amp;&amp; nodeName != "" </span><span class="cov3" title="3">{
                switch resourceType </span>{
                case "pods":<span class="cov2" title="2">
                        fieldSelector = fields.ParseSelectorOrDie("spec.nodeName=" + nodeName)</span>
                case "nodes":<span class="cov1" title="1">
                        fieldSelector = fields.OneTermEqualSelector("metadata.name", nodeName)</span>
                default:<span class="cov0" title="0">
                        log.Infof("invalid resource type: %s", resourceType)</span>
                }
        }
        <span class="cov3" title="3">log.Debugf("using fieldSelector: %q for resourceType: %s", fieldSelector, resourceType)
        return fieldSelector</span>
}

func ScrapeCluster() bool <span class="cov5" title="8">{
        return agentType.ScrapeCluster()
}</span>

func SetAgentType(value AgentType) <span class="cov4" title="7">{
        agentType = value
}</span>

func ScrapeAnyNodes() bool <span class="cov8" title="37">{
        return agentType.ScrapeAnyNodes()
}</span>

func ScrapeOnlyOwnNode() bool <span class="cov6" title="13">{
        return agentType.ScrapeOnlyOwnNode()
}</span>

func GetNodeName() string <span class="cov4" title="7">{
        return os.Getenv(NodeNameEnvVar)
}</span>

func GetNamespaceName() string <span class="cov2" title="2">{
        return os.Getenv(NamespaceNameEnvVar)
}</span>

func GetInstallationMethod() string <span class="cov3" title="4">{

        installationMethod := os.Getenv(InstallationMethodEnvVar)
        if len(installationMethod) == 0 </span><span class="cov3" title="4">{
                return "unknown"
        }</span>
        <span class="cov5" title="11">return installationMethod</span>
}

func GetKubernetesProvider() string <span class="cov4" title="5">{
        return os.Getenv(KubernetesProviderEnvVar)
}</span>

func SetKubernetesVersion(version string) <span class="cov5" title="10">{
        os.Setenv(KubernetesVersionEnvVar, version)
}</span>

func GetKubernetesVersion() string <span class="cov4" title="5">{
        return os.Getenv(KubernetesVersionEnvVar)
}</span>

func SetKubernetesProvider(providerID string) <span class="cov5" title="10">{
        provider := strings.Split(providerID, ":")
        if len(provider[0]) &gt; 0 </span><span class="cov5" title="10">{
                os.Setenv(KubernetesProviderEnvVar, provider[0])
        }</span> else<span class="cov0" title="0"> {
                os.Setenv(KubernetesProviderEnvVar, "unknown")
        }</span>
}

func AddK8sTags(tags map[string]string) <span class="cov3" title="4">{
        // Use separate function to add K8s tags since the Env variables are set via summary source
        if len(tags["k8s_version"]) == 0 &amp;&amp; len(GetKubernetesVersion()) &gt; 0 </span><span class="cov2" title="2">{
                tags["k8s_version"] = GetKubernetesVersion()
        }</span>
        <span class="cov3" title="4">if len(tags["k8s_provider"]) == 0 &amp;&amp; len(GetKubernetesProvider()) &gt; 0 </span><span class="cov2" title="2">{
                tags["k8s_provider"] = GetKubernetesProvider()
        }</span>
}

func GetNodeHostnameAndIP(node *kube_api.Node) (string, net.IP, error) <span class="cov4" title="5">{
        for _, c := range node.Status.Conditions </span><span class="cov10" title="80">{
                if c.Type == kube_api.NodeReady &amp;&amp; c.Status != kube_api.ConditionTrue </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("node %v is not ready", node.Name)
                }</span>
        }
        <span class="cov4" title="5">hostname, ip := node.Name, ""
        for _, addr := range node.Status.Addresses </span><span class="cov8" title="40">{
                if addr.Type == kube_api.NodeHostName &amp;&amp; addr.Address != "" </span><span class="cov7" title="20">{
                        hostname = addr.Address
                }</span>
                <span class="cov8" title="40">if addr.Type == kube_api.NodeInternalIP &amp;&amp; addr.Address != "" </span><span class="cov3" title="4">{
                        if net.ParseIP(addr.Address) != nil </span><span class="cov3" title="4">{
                                ip = addr.Address
                        }</span>
                }
                <span class="cov8" title="40">if addr.Type == kube_api.NodeExternalIP &amp;&amp; addr.Address != "" &amp;&amp; ip == "" </span><span class="cov0" title="0">{
                        ip = addr.Address
                }</span>
        }
        <span class="cov4" title="5">if parsedIP := net.ParseIP(ip); parsedIP != nil </span><span class="cov3" title="4">{
                return hostname, parsedIP, nil
        }</span>
        <span class="cov1" title="1">return "", nil, fmt.Errorf("node %v has no valid hostname and/or IP address: %v %v", node.Name, hostname, ip)</span>
}

func GetNodeRole(node *kube_api.Node) string <span class="cov9" title="64">{
        if _, ok := node.GetLabels()["node-role.kubernetes.io/control-plane"]; ok </span><span class="cov9" title="64">{
                return "control-plane"
        }</span>
        <span class="cov0" title="0">if _, ok := node.GetLabels()["node-role.kubernetes.io/master"]; ok </span><span class="cov0" title="0">{
                return "control-plane"
        }</span>
        <span class="cov0" title="0">return "worker"</span>
}

type ContainerStateInfo struct {
        Value    int
        State    string
        Reason   string
        ExitCode int32
}

func (csi ContainerStateInfo) IsKnownState() bool <span class="cov3" title="4">{
        return csi.Value &gt; 0
}</span>

func (csi ContainerStateInfo) AddMetricTags(tags map[string]string) <span class="cov3" title="4">{
        if csi.IsKnownState() </span><span class="cov3" title="4">{
                tags["status"] = csi.State
                if csi.Reason != "" </span><span class="cov9" title="50">{
                        tags["reason"] = csi.Reason
                        tags["exit_code"] = fmt.Sprint(csi.ExitCode)
                }</span>
        }
}

func NewContainerStateInfo(state kube_api.ContainerState) ContainerStateInfo <span class="cov3" title="4">{
        if state.Running != nil </span><span class="cov9" title="64">{
                return ContainerStateInfo{
                        Value:    CONTAINER_STATE_RUNNING,
                        State:    "running",
                        Reason:   "",
                        ExitCode: 0,
                }
        }</span>
        <span class="cov9" title="50">if state.Waiting != nil </span><span class="cov5" title="10">{
                return ContainerStateInfo{
                        Value:    CONTAINER_STATE_WAITING,
                        State:    "waiting",
                        Reason:   state.Waiting.Reason,
                        ExitCode: 0,
                }
        }</span>
        <span class="cov8" title="40">if state.Terminated != nil </span><span class="cov8" title="40">{
                return ContainerStateInfo{
                        Value:    CONTAINER_STATE_TERMINATED,
                        State:    "terminated",
                        Reason:   state.Terminated.Reason,
                        ExitCode: state.Terminated.ExitCode,
                }
        }</span>
        <span class="cov0" title="0">return ContainerStateInfo{
                Value:    0,
                State:    "unknown",
                Reason:   "",
                ExitCode: 0,
        }</span>
}

func ConvertPodPhase(phase kube_api.PodPhase) int64 <span class="cov5" title="8">{
        switch phase </span>{
        case kube_api.PodPending:<span class="cov7" title="20">
                return POD_PHASE_PENDING</span>
        case kube_api.PodRunning:<span class="cov9" title="64">
                return POD_PHASE_RUNNING</span>
        case kube_api.PodSucceeded:<span class="cov2" title="2">
                return POD_PHASE_SUCCEEDED</span>
        case kube_api.PodFailed:<span class="cov7" title="30">
                return POD_PHASE_FAILED</span>
        case kube_api.PodUnknown:<span class="cov0" title="0">
                return POD_PHASE_UNKNOWN</span>
        default:<span class="cov0" title="0">
                return POD_PHASE_UNKNOWN</span>
        }
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package util

import (
        "time"
)

var (
        // NeverStop may be passed to make it never stop
        NeverStop &lt;-chan struct{} = make(chan struct{})
)

// TODO: this needs a test! Tricky...
// Retry makes the function run infinitely after certain time period
func Retry(f func(), duration time.Duration, stopCh &lt;-chan struct{}) <span class="cov5" title="3">{
        t := time.NewTicker(duration)

        for </span><span class="cov5" title="3">{
                select </span>{
                case &lt;-stopCh:<span class="cov5" title="3">
                        return</span>
                case &lt;-t.C:<span class="cov10" title="9"></span>
                }

                <span class="cov10" title="9">select </span>{
                case &lt;-stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov10" title="9"></span>
                }

                <span class="cov10" title="9">f()</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package util

import (
        "os"
        "time"

        log "github.com/sirupsen/logrus"
)

type FileListener interface {
        Changed(file string)
}

type ConfigHandler interface {
        Handle(cfg interface{})
}

type FileWatcher interface {
        Watch()
        Stop()
}

type fileWatcher struct {
        file     string
        listener FileListener
        delay    time.Duration
        modTime  time.Time
        stopCh   chan struct{}
}

func NewFileWatcher(file string, listener FileListener, initialDelay time.Duration) FileWatcher <span class="cov8" title="1">{
        return &amp;fileWatcher{
                file:     file,
                listener: listener,
                delay:    initialDelay,
                stopCh:   make(chan struct{}),
        }
}</span>

// listens for changes to a given file every minute
func (fw *fileWatcher) Watch() <span class="cov8" title="1">{
        fw.stopCh = make(chan struct{})
        initial := true
        go Retry(func() </span><span class="cov8" title="1">{
                fileInfo, err := os.Stat(fw.file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error retrieving file stats: %v", err)
                        return
                }</span>

                <span class="cov8" title="1">if fileInfo.ModTime().After(fw.modTime) </span><span class="cov8" title="1">{
                        fw.modTime = fileInfo.ModTime()
                        if !initial </span><span class="cov0" title="0">{
                                fw.listener.Changed(fw.file)
                        }</span> else<span class="cov8" title="1"> {
                                initial = false
                        }</span>
                }
        }, 1*time.Minute, fw.stopCh)
}

func (fw *fileWatcher) Stop() <span class="cov0" title="0">{
        close(fw.stopCh)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package wf

import (
        "bytes"
        "errors"
        "fmt"
        "math"
        "sort"
        "time"

        "github.com/wavefronthq/wavefront-sdk-go/histogram"
        "golang.org/x/crypto/blake2b"
)

type Centroid struct {
        Value float64
        Count float64
}

type Distribution struct {
        Cumulative bool
        name       string
        tags       map[string]string
        Source     string
        Centroids  []Centroid
        Timestamp  time.Time
}

// NewCumulativeDistribution encodes prometheus style distribution.
func NewCumulativeDistribution(name string, source string, tags map[string]string, centroids []Centroid, timestamp time.Time) *Distribution <span class="cov7" title="23">{
        return newDistribution(true, name, source, tags, centroids, timestamp)
}</span>

// NewFrequencyDistribution encodes a WF style distribution.
func NewFrequencyDistribution(name string, source string, tags map[string]string, centroids []Centroid, timestamp time.Time) *Distribution <span class="cov6" title="14">{
        return newDistribution(false, name, source, tags, centroids, timestamp)
}</span>

func newDistribution(cumulative bool, name string, source string, tags map[string]string, centroids []Centroid, timestamp time.Time) *Distribution <span class="cov8" title="38">{
        sort.Slice(centroids, func(i, j int) bool </span><span class="cov8" title="42">{
                return centroids[i].Value &lt; centroids[j].Value
        }</span>)
        <span class="cov8" title="38">return &amp;Distribution{
                Cumulative: cumulative,
                name:       name,
                Source:     source,
                tags:       tags,
                Centroids:  centroids,
                Timestamp:  timestamp,
        }</span>
}

func (d *Distribution) Clone() *Distribution <span class="cov5" title="12">{
        return newDistribution(d.Cumulative, d.Name(), d.Source, d.clonedTags(), d.clonedCentroids(), d.Timestamp)
}</span>

func (d *Distribution) clonedTags() map[string]string <span class="cov5" title="12">{
        clonedTags := make(map[string]string, len(d.Tags()))
        for k, v := range d.Tags() </span><span class="cov5" title="12">{
                clonedTags[k] = v
        }</span>
        <span class="cov5" title="12">return clonedTags</span>
}

func (d *Distribution) clonedCentroids() []Centroid <span class="cov5" title="12">{
        cloned := make([]Centroid, len(d.Centroids))
        copy(cloned, d.Centroids)
        return cloned
}</span>

func (d *Distribution) Points() int <span class="cov1" title="1">{
        return 7
}</span>

func (d *Distribution) ToFrequency() *Distribution <span class="cov5" title="10">{
        if !d.Cumulative </span><span class="cov1" title="1">{
                return d
        }</span>
        <span class="cov5" title="9">return NewFrequencyDistribution(
                d.Name(),
                d.Source,
                d.Tags(),
                smoothCentroids(deriveCentroids(d.Centroids)),
                d.Timestamp,
        )</span>
}

func smoothCentroids(derivedCentroids []Centroid) []Centroid <span class="cov5" title="9">{
        if len(derivedCentroids) == 1 &amp;&amp; derivedCentroids[0].Value == math.Inf(1) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov5" title="8">amplification := math.Max(1, 1/smallestCountAboveZero(derivedCentroids))
        centroidCounts := map[float64]float64{}
        for i, centroid := range derivedCentroids </span><span class="cov4" title="6">{
                currentBucketBound := centroid.Value
                actualBucketCount := derivedCentroids[i].Count * amplification
                if currentBucketBound &lt;= 0 || actualBucketCount == 0 </span><span class="cov4" title="5">{
                        continue</span>
                }
                <span class="cov5" title="9">actualBucketCount = math.Max(1.0, actualBucketCount)
                if currentBucketBound == math.Inf(1) </span><span class="cov1" title="1">{
                        currentBucketBound = derivedCentroids[i-1].Value
                }</span>
                <span class="cov5" title="9">previousBucketBound := 0.0
                if i &gt; 0 </span><span class="cov4" title="6">{
                        previousBucketBound = derivedCentroids[i-1].Value
                }</span>
                <span class="cov5" title="9">lowerCount := math.Trunc(actualBucketCount / 4)
                centroidCounts[previousBucketBound] += lowerCount

                middleCount := math.Trunc(actualBucketCount / 2)
                centroidCounts[(currentBucketBound+previousBucketBound)/2] += middleCount

                upperCount := math.Trunc(actualBucketCount - lowerCount - middleCount)
                centroidCounts[currentBucketBound] += upperCount</span>
        }
        <span class="cov5" title="8">return centroidMapToSlice(centroidCounts)</span>
}

func centroidMapToSlice(centroidCounts map[float64]float64) []Centroid <span class="cov5" title="8">{
        centroids := make([]Centroid, 0, len(centroidCounts))
        for value, count := range centroidCounts </span><span class="cov7" title="22">{
                centroids = append(centroids, Centroid{Value: value, Count: count})
        }</span>
        <span class="cov5" title="8">return centroids</span>
}

func smallestCountAboveZero(centroids []Centroid) float64 <span class="cov5" title="8">{
        minCount := math.MaxFloat64
        for _, centroid := range centroids </span><span class="cov4" title="6">{
                if centroid.Count &gt; 0 &amp;&amp; centroid.Count &lt; minCount </span><span class="cov4" title="6">{
                        minCount = centroid.Count
                }</span>
        }
        <span class="cov5" title="8">return minCount</span>
}

func deriveCentroids(centroids []Centroid) []Centroid <span class="cov5" title="9">{
        var derived []Centroid
        for i, centroid := range centroids </span><span class="cov4" title="6">{
                deltaCount := 0.0
                if i &gt; 0 </span><span class="cov4" title="7">{
                        deltaCount = centroid.Count - centroids[i-1].Count
                }</span> else<span class="cov5" title="8"> {
                        deltaCount = centroid.Count
                }</span>
                <span class="cov4" title="6">derived = append(derived, Centroid{
                        Value: centroid.Value,
                        Count: deltaCount,
                })</span>
        }
        <span class="cov5" title="9">return derived</span>
}

func (d *Distribution) OverrideTag(name, value string) <span class="cov0" title="0">{
        if d == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if d.tags == nil </span><span class="cov0" title="0">{
                d.tags = map[string]string{}
        }</span>
        <span class="cov0" title="0">d.tags[name] = value</span>
}

func (d *Distribution) AddTags(tags map[string]string) <span class="cov1" title="1">{
        if tags == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">for name, value := range tags </span><span class="cov1" title="1">{
                d.addTag(name, value)
        }</span>
}

func (d *Distribution) addTag(name, value string) <span class="cov1" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">if d.tags == nil </span><span class="cov0" title="0">{
                d.tags = map[string]string{}
        }</span>
        <span class="cov1" title="1">if _, exists := d.tags[name]; !exists </span><span class="cov1" title="1">{
                d.tags[name] = value
        }</span>
}

func (d *Distribution) SetSource(source string) <span class="cov0" title="0">{
        d.Source = source
}</span>

func (d *Distribution) Name() string <span class="cov7" title="22">{
        return d.name
}</span>

func (d *Distribution) Tags() map[string]string <span class="cov10" title="96">{
        return d.tags
}</span>

func (d *Distribution) FilterTags(pred func(string) bool) <span class="cov0" title="0">{
        for name := range d.tags </span><span class="cov0" title="0">{
                if !pred(name) </span><span class="cov0" title="0">{
                        delete(d.tags, name)
                }</span>
        }
}

func (d *Distribution) Send(to Sender) error <span class="cov3" title="4">{
        if d.Cumulative </span><span class="cov1" title="1">{
                return errors.New("cannot send prometheus style distribution to wavefront")
        }</span>
        <span class="cov3" title="3">centroids := sendableCentroids(d)
        if len(centroids) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov2" title="2">return to.SendDistribution(
                d.Name(),
                centroids,
                map[histogram.Granularity]bool{histogram.MINUTE: true},
                d.Timestamp.Unix(),
                d.Source,
                d.Tags(),
        )</span>
}

func sendableCentroids(d *Distribution) []histogram.Centroid <span class="cov3" title="3">{
        wfCentroids := make([]histogram.Centroid, 0, len(d.Centroids))
        for _, centroid := range d.Centroids </span><span class="cov5" title="8">{
                if centroid.Count == 0.0 </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov4" title="7">wfCentroids = append(wfCentroids, histogram.Centroid{
                        Value: centroid.Value,
                        Count: int(centroid.Count),
                })</span>
        }
        <span class="cov3" title="3">return wfCentroids</span>
}

func (d *Distribution) Equals(b *Distribution) bool <span class="cov0" title="0">{
        return false
}</span>

type DistributionHash [32]byte

func (d *Distribution) Key() DistributionHash <span class="cov9" title="64">{
        buf := bytes.NewBuffer(nil)
        buf.Write([]byte(fmt.Sprintf("%t ", d.Cumulative)))
        buf.WriteString(d.name)
        buf.WriteString(" source=")
        buf.WriteString(d.Source)
        tags := d.Tags()
        var names []string
        for name := range tags </span><span class="cov9" title="64">{
                names = append(names, name)
        }</span>
        <span class="cov9" title="64">sort.Strings(names)
        for _, name := range names </span><span class="cov9" title="64">{
                buf.WriteByte(' ')
                buf.WriteString(name)
                buf.WriteByte('=')
                buf.WriteString(tags[name])
        }</span>
        <span class="cov9" title="64">return blake2b.Sum256(buf.Bytes())</span>
}

func (d *Distribution) Rate(prev *Distribution) *Distribution <span class="cov3" title="4">{
        if prev == nil || prev.Key() != d.Key() </span><span class="cov4" title="5">{
                return nil
        }</span>
        <span class="cov4" title="7">centroidRate := CentroidRate(d.Centroids, prev.Centroids, d.Timestamp.Sub(prev.Timestamp))
        if centroidRate == nil </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov4" title="5">return newDistribution(d.Cumulative, d.Name(), d.Source, d.Tags(), centroidRate, d.Timestamp)</span>
}

func CentroidRate(curr, prev []Centroid, duration time.Duration) []Centroid <span class="cov4" title="7">{
        if len(curr) != len(prev) </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="7">var centroids = make([]Centroid, len(curr))
        for i := 0; i &lt; len(curr); i++ </span><span class="cov5" title="8">{
                if curr[i].Value != prev[i].Value || curr[i].Count &lt; prev[i].Count || duration.Seconds() &lt;= 0 </span><span class="cov3" title="3">{
                        return nil
                }</span>
                <span class="cov4" title="5">centroids[i] = Centroid{
                        Value: curr[i].Value,
                        Count: (curr[i].Count - prev[i].Count) / duration.Minutes(),
                }</span>
        }
        <span class="cov4" title="5">return centroids</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package wf

import (
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
)

type Incrementer interface {
        Inc(int642 int64)
}

// FilterAppend appends the point to points when Filter does not return nil
func FilterAppend(filter filter.Filter, filtered Incrementer, points []Metric, point Metric) []Metric <span class="cov9" title="542842">{
        point = Filter(filter, filtered, point)
        if point == nil </span><span class="cov2" title="8">{
                return points
        }</span>
        <span class="cov4" title="94">return append(points, point)</span>
}

// Filter returns nil when it does not match the supplied filter.Filter.
// Filter increments the Incrementor when filtering.
// Filter filters the tags on a matched point.
func Filter(filter filter.Filter, filtered Incrementer, point Metric) Metric <span class="cov10" title="656924">{
        if filter == nil || point == nil </span><span class="cov2" title="8">{
                return point
        }</span>
        <span class="cov9" title="586857">if !filter.MatchMetric(point.Name(), point.Tags()) </span><span class="cov2" title="8">{
                log.WithField("name", point.Name()).Tracef("dropping metric")
                filtered.Inc(1)
                return nil
        }</span>
        <span class="cov2" title="8">point.FilterTags(filter.MatchTag)
        return point</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package wf

type LabelPair struct {
        Name  *string
        Value *string
}

// Point is a single point in Wavefront metric format.
type Point struct {
        Metric    string
        Value     float64
        Timestamp int64
        Source    string

        tags       map[string]string
        labelPairs []LabelPair
}

func NewPoint(metric string, value float64, timestamp int64, source string, tags map[string]string) *Point <span class="cov2" title="7">{
        return &amp;Point{
                Metric:    metric,
                Value:     value,
                Timestamp: timestamp,
                Source:    source,
                tags:      tags,
        }
}</span>

func (m *Point) Points() int <span class="cov1" title="4">{
        return 1
}</span>

func (m *Point) Send(to Sender) error <span class="cov1" title="3">{
        return to.SendMetric(m.Metric, m.Value, m.Timestamp, m.Source, m.Tags())
}</span>

func (m *Point) SetSource(source string) <span class="cov0" title="0">{
        m.Source = source
}</span>

func (m *Point) Name() string <span class="cov3" title="74">{
        return m.Metric
}</span>

func (m *Point) SetLabelPairs(pairs []LabelPair) <span class="cov9" title="522932">{
        m.labelPairs = pairs
}</span>

func (m *Point) SetTags(tags map[string]string) <span class="cov0" title="0">{
        m.tags = tags
}</span>

// OverrideTag sets a tag regardless of whether it already exists
func (m *Point) OverrideTag(name, value string) <span class="cov1" title="3">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="3">if m.tags == nil </span><span class="cov8" title="94690">{
                m.tags = map[string]string{}
        }</span>
        <span class="cov1" title="3">m.tags[name] = value</span>
}

// AddTag adds a tag if it does not already exist
func (m *Point) AddTag(name, value string) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if m.tags == nil </span><span class="cov0" title="0">{
                m.tags = map[string]string{}
        }</span>
        <span class="cov0" title="0">if _, exists := m.tags[name]; !exists </span><span class="cov0" title="0">{
                m.tags[name] = value
        }</span>
}

// AddTags adds any tags that do not already exist
func (m *Point) AddTags(tags map[string]string) <span class="cov1" title="3">{
        if tags == nil </span><span class="cov1" title="3">{
                return
        }</span>
        <span class="cov0" title="0">for name, value := range tags </span><span class="cov0" title="0">{
                m.AddTag(name, value)
        }</span>
}

func (m *Point) Tags() map[string]string <span class="cov4" title="97">{
        tags := make(map[string]string, len(m.labelPairs))
        for _, labelPair := range m.labelPairs </span><span class="cov3" title="89">{
                tags[*labelPair.Name] = *labelPair.Value
        }</span>

        <span class="cov4" title="97">for k, v := range m.tags </span><span class="cov2" title="8">{
                tags[k] = v
        }</span>

        <span class="cov4" title="97">return tags</span>
}

func (m *Point) FilterTags(pred func(string) bool) <span class="cov2" title="8">{
        var nextLabelPairs []LabelPair
        for _, labelPair := range m.labelPairs </span><span class="cov10" title="734240">{
                if pred(*labelPair.Name) </span><span class="cov10" title="734240">{
                        nextLabelPairs = append(nextLabelPairs, labelPair)
                }</span>
        }
        <span class="cov2" title="8">m.labelPairs = nextLabelPairs

        for name := range m.tags </span><span class="cov3" title="80">{
                if !pred(name) </span><span class="cov7" title="9438">{
                        delete(m.tags, name)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package discovery

import (
        "context"
        "time"

        v12 "k8s.io/apimachinery/pkg/apis/meta/v1"

        log "github.com/sirupsen/logrus"
        v1 "k8s.io/api/authorization/v1"
        authv1 "k8s.io/client-go/kubernetes/typed/authorization/v1"
)

type AuthChecker struct {
        accessGetter authv1.SelfSubjectAccessReviewInterface
        namespace    string

        hasAccess bool

        refreshInterval time.Duration
        reportInterval  time.Duration
        lastChecked     time.Time
        lastReported    time.Time
        logger          func(format string, args ...interface{})
}

func NewAuthChecker(accessGetter authv1.SelfSubjectAccessReviewInterface, namespace string, refreshInterval time.Duration, reportInterval time.Duration) *AuthChecker <span class="cov4" title="3">{
        return TestAuthChecker(accessGetter, namespace, refreshInterval, reportInterval, log.Infof)
}</span>

func TestAuthChecker(accessGetter authv1.SelfSubjectAccessReviewInterface, namespace string, refreshInterval time.Duration, reportInterval time.Duration, logger func(format string, args ...interface{})) *AuthChecker <span class="cov8" title="9">{
        checker := &amp;AuthChecker{
                accessGetter:    accessGetter,
                namespace:       namespace,
                refreshInterval: refreshInterval,
                reportInterval:  reportInterval,
                logger:          logger,
        }

        return checker
}</span>

func (checker *AuthChecker) CanListSecrets() bool <span class="cov10" title="16">{
        checker.refreshAccess()
        return checker.hasAccess
}</span>

func (checker *AuthChecker) refreshAccess() <span class="cov10" title="16">{
        if !checker.timeToRefresh() </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov9" title="15">checker.lastChecked = time.Now()

        checker.hasAccess = checker.canListSecretsAPI()
        checker.reportAccess()</span>
}

func (checker *AuthChecker) timeToRefresh() bool <span class="cov10" title="16">{
        return time.Now().Sub(checker.lastChecked) &gt; checker.refreshInterval
}</span>

func (checker *AuthChecker) reportAccess() <span class="cov9" title="15">{
        if checker.hasAccess </span><span class="cov7" title="7">{
                checker.lastReported = time.Time{}
                return
        }</span>
        <span class="cov7" title="8">if time.Now().Sub(checker.lastReported) &lt; checker.reportInterval </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov7" title="7">checker.lastReported = time.Now()
        checker.logger("Secret Access Disabled for Configuration")</span>
}

func (checker *AuthChecker) canListSecretsAPI() bool <span class="cov9" title="15">{
        sar := &amp;v1.SelfSubjectAccessReview{
                Spec: v1.SelfSubjectAccessReviewSpec{
                        ResourceAttributes: &amp;v1.ResourceAttributes{
                                Namespace: checker.namespace,
                                Verb:      "list",
                                Resource:  "secrets",
                        },
                },
        }
        review, err := checker.accessGetter.Create(context.Background(), sar, v12.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unable to check api access: %v", err)
                return false
        }</span>
        <span class="cov9" title="15">return review.Status.Allowed</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "context"
        "io/ioutil"
        "sort"
        "sync"
        "time"

        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
)

const (
        discoveryAnnotation = "wavefront.com/discovery-config"
)

type configHandler struct {
        stopCh            chan struct{}
        configMapInformer cache.SharedInformer
        secretInformer    cache.SharedInformer

        mtx                    sync.RWMutex
        wiredCfg               discovery.Config            // wired configuration
        runtimeCfgs            map[string]discovery.Config // dynamic runtime configurations
        internalPluginProvider discovery.PluginProvider
}

type configResource struct {
        meta metav1.ObjectMeta
        data map[string]string
}

func newConfigHandler(kubeClient kubernetes.Interface, cfg discovery.Config, internalPluginProvider discovery.PluginProvider) *configHandler <span class="cov1" title="1">{
        handler := &amp;configHandler{
                wiredCfg:               cfg,
                runtimeCfgs:            make(map[string]discovery.Config),
                internalPluginProvider: internalPluginProvider,
        }

        ns := util.GetNamespaceName()
        if ns == "" </span><span class="cov0" title="0">{
                ns = readNamespaceFromFile()
                if ns == "" </span><span class="cov0" title="0">{
                        return handler
                }</span>
        }

        <span class="cov1" title="1">handler.configMapInformer = newConfigMapInformer(kubeClient, ns, handler)
        handler.secretInformer = newSecretInformer(kubeClient, ns, handler)
        return handler</span>
}

func newConfigMapInformer(kubeClient kubernetes.Interface, ns string, handler *configHandler) cache.SharedInformer <span class="cov1" title="1">{
        s := kubeClient.CoreV1().ConfigMaps(ns)
        lw := &amp;cache.ListWatch{
                ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov1" title="1">{
                        return s.List(context.Background(), options)
                }</span>,
                WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov1" title="1">{
                        return s.Watch(context.Background(), options)
                }</span>,
        }

        <span class="cov1" title="1">inf := cache.NewSharedInformer(lw, &amp;v1.ConfigMap{}, 1*time.Hour)
        inf.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov7" title="4">{
                        updateConfigMapIfValid(obj, handler)
                }</span>,
                UpdateFunc: func(_, obj interface{}) <span class="cov5" title="3">{
                        updateConfigMapIfValid(obj, handler)
                }</span>,
                DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                        deleteConfigMapIfValid(obj, handler)
                }</span>,
        })
        <span class="cov1" title="1">return inf</span>
}

func deleteConfigMapIfValid(obj interface{}, handler *configHandler) <span class="cov1" title="1">{
        cfg, ok := obj.(*v1.ConfigMap)
        if ok </span><span class="cov0" title="0">{
                handler.deleted(cfg.Name)
        }</span>
}

func updateConfigMapIfValid(obj interface{}, handler *configHandler) <span class="cov9" title="7">{
        cfg, ok := obj.(*v1.ConfigMap)
        if ok </span><span class="cov9" title="7">{
                handler.updated(&amp;configResource{cfg.ObjectMeta, cfg.Data})
        }</span>
}

func emptySecretList() *v1.SecretList <span class="cov0" title="0">{
        return &amp;v1.SecretList{
                ListMeta: metav1.ListMeta{
                        Continue:           "false",
                        RemainingItemCount: nil,
                        ResourceVersion:    "0",
                },
                Items: make([]v1.Secret, 0),
        }
}</span>

func newSecretInformer(kubeClient kubernetes.Interface, ns string, handler *configHandler) cache.SharedInformer <span class="cov1" title="1">{
        authChecker := NewAuthChecker(kubeClient.AuthorizationV1().SelfSubjectAccessReviews(),
                ns, time.Minute, 12*time.Hour)
        s := kubeClient.CoreV1().Secrets(ns)
        lw := &amp;cache.ListWatch{
                ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov1" title="1">{
                        if authChecker.CanListSecrets() </span><span class="cov1" title="1">{
                                return s.List(context.Background(), options)
                        }</span> else<span class="cov0" title="0"> {
                                return emptySecretList(), nil
                        }</span>
                },
                WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov1" title="1">{
                        return s.Watch(context.Background(), options)
                }</span>,
        }

        <span class="cov1" title="1">inf := cache.NewSharedInformer(lw, &amp;v1.Secret{}, 1*time.Hour)
        inf.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov1" title="1">{
                        updateSecretIfValid(obj, handler)
                }</span>,
                UpdateFunc: func(_, obj interface{}) <span class="cov0" title="0">{
                        updateSecretIfValid(obj, handler)
                }</span>,
                DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                        deleteSecretIfValid(obj, handler)
                }</span>,
        })
        <span class="cov1" title="1">return inf</span>
}

func deleteSecretIfValid(obj interface{}, handler *configHandler) <span class="cov1" title="1">{
        secret, ok := obj.(*v1.Secret)
        if ok </span><span class="cov0" title="0">{
                handler.deleted(secret.Name)
        }</span>
}

func updateSecretIfValid(obj interface{}, handler *configHandler) <span class="cov1" title="1">{
        secret, ok := obj.(*v1.Secret)
        if ok </span><span class="cov1" title="1">{
                handler.updated(&amp;configResource{secret.ObjectMeta, convertByteArrayData(secret.Data)})
        }</span>
}

// Config gets the combined discovery configuration and a boolean indicating whether
// the configuration has changed since the last call to this function
func (handler *configHandler) Config() discovery.Config <span class="cov7" title="4">{
        handler.mtx.Lock()
        defer handler.mtx.Unlock()

        return combine(handler.wiredCfg, handler.runtimeCfgs, handler.internalPluginProvider)
}</span>

func (handler *configHandler) updated(configResource *configResource) <span class="cov10" title="8">{
        if !annotated(configResource.meta.Annotations) </span><span class="cov8" title="6">{
                // delegate to deleted and return
                log.Infof("no runtime annotation on %s", configResource.meta.Name)
                handler.deleted(configResource.meta.Name)
                return
        }</span>

        <span class="cov4" title="2">loaded, err := load(configResource.data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error loading discovery config: %s error: %v", configResource.meta.Name, err)
                return
        }</span>
        <span class="cov4" title="2">log.Infof("loaded discovery configuration from %s", configResource.meta.Name)

        handler.mtx.Lock()
        defer handler.mtx.Unlock()

        // update the internal map entry
        handler.runtimeCfgs[configResource.meta.Name] = loaded</span>
}

func (handler *configHandler) deleted(name string) <span class="cov8" title="6">{
        handler.mtx.Lock()
        defer handler.mtx.Unlock()
        if _, found := handler.runtimeCfgs[name]; found </span><span class="cov1" title="1">{
                log.Infof("deleted discovery configuration from %s", name)
                delete(handler.runtimeCfgs, name)
        }</span>
}

func annotated(annotations map[string]string) bool <span class="cov10" title="8">{
        if val, ok := annotations[discoveryAnnotation]; ok </span><span class="cov4" title="2">{
                return val == "true"
        }</span>
        <span class="cov8" title="6">return false</span>
}

func load(data map[string]string) (discovery.Config, error) <span class="cov5" title="3">{
        cfg := &amp;discovery.Config{}
        for _, config := range data </span><span class="cov5" title="3">{
                loadedCfg, err := discovery.FromYAML([]byte(config))
                if err != nil </span><span class="cov0" title="0">{
                        return *cfg, err
                }</span>
                <span class="cov5" title="3">cfg.PluginConfigs = append(cfg.PluginConfigs, loadedCfg.PluginConfigs...)</span>
        }
        <span class="cov5" title="3">return *cfg, nil</span>
}

func combine(wiredCfg discovery.Config, runtimeCfgs map[string]discovery.Config, internalPluginProvider discovery.PluginProvider) discovery.Config <span class="cov10" title="8">{
        runCfg := &amp;discovery.Config{
                DiscoveryInterval:          wiredCfg.DiscoveryInterval,
                AnnotationPrefix:           wiredCfg.AnnotationPrefix,
                AnnotationExcludes:         wiredCfg.AnnotationExcludes,
                PluginConfigs:              wiredCfg.PluginConfigs,
                DisableAnnotationDiscovery: wiredCfg.DisableAnnotationDiscovery,
        }

        // build a sorted slice of map keys for consistent iteration order
        keys := make([]string, len(runtimeCfgs))
        i := 0
        for k := range runtimeCfgs </span><span class="cov10" title="8">{
                keys[i] = k
                i++
        }</span>

        <span class="cov10" title="8">sort.Strings(keys)

        log.Debug("combining discovery configurations")
        for _, key := range keys </span><span class="cov10" title="8">{
                c := runtimeCfgs[key]
                if len(c.PluginConfigs) &gt; 0 </span><span class="cov10" title="8">{
                        runCfg.PluginConfigs = append(runCfg.PluginConfigs, c.PluginConfigs...)
                }</span>
        }

        <span class="cov10" title="8">if internalPluginProvider != nil </span><span class="cov4" title="2">{
                runCfg.PluginConfigs = append(runCfg.PluginConfigs, internalPluginProvider.DiscoveryPluginConfigs()...)
        }</span>

        <span class="cov10" title="8">log.Debugf("total plugin configs: %d", len(runCfg.PluginConfigs))
        return *runCfg</span>
}

func readNamespaceFromFile() string <span class="cov0" title="0">{
        data, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error reading namespace: %v", err)
                return ""
        }</span>
        <span class="cov0" title="0">ns := string(data)
        log.Infof("loaded namespace from file: %s", ns)
        return ns</span>
}

func convertByteArrayData(data map[string][]byte) map[string]string <span class="cov1" title="1">{
        stringData := make(map[string]string)
        for key, value := range data </span><span class="cov1" title="1">{
                stringData[key] = string(value)
        }</span>
        <span class="cov1" title="1">return stringData</span>
}

func (handler *configHandler) start() bool <span class="cov1" title="1">{
        handler.stopCh = make(chan struct{})
        go handler.configMapInformer.Run(handler.stopCh)
        go handler.secretInformer.Run(handler.stopCh)
        return cache.WaitForCacheSync(handler.stopCh, handler.configMapInformer.HasSynced, handler.secretInformer.HasSynced)
}</span>

func (handler *configHandler) stop() <span class="cov0" title="0">{
        if handler.stopCh != nil </span><span class="cov0" title="0">{
                close(handler.stopCh)
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/prometheus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/discovery/telegraf"

        gm "github.com/rcrowley/go-metrics"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type delegate struct {
        filter *resourceFilter
        plugin discovery.PluginConfig
}

type discoverer struct {
        wg    sync.WaitGroup
        mtx   sync.RWMutex
        queue chan discovery.Resource

        lister    discovery.ResourceLister
        ruleCount gm.Gauge

        endpoints       map[string][]*discovery.Endpoint
        endpointHandler discovery.EndpointHandler

        endpointCreator endpointCreator
}

func newDiscoverer(handler metrics.ProviderHandler, discoveryCfg discovery.Config, lister discovery.ResourceLister) discovery.Discoverer <span class="cov1" title="1">{
        ec := endpointCreator{
                delegates:                  makeDelegates(discoveryCfg),
                annotationExcludes:         makeAnnotationExclusions(discoveryCfg.AnnotationExcludes),
                providers:                  makeProviders(handler, discoveryCfg),
                disableAnnotationDiscovery: discoveryCfg.DisableAnnotationDiscovery,
        }
        d := &amp;discoverer{
                queue:           make(chan discovery.Resource, 1000),
                lister:          lister,
                ruleCount:       gm.GetOrRegisterGauge("discovery.rules.count", gm.DefaultRegistry),
                endpoints:       make(map[string][]*discovery.Endpoint, 32),
                endpointHandler: discovery.NewEndpointHandler(makeProviders(handler, discoveryCfg)),
                endpointCreator: ec,
        }
        d.ruleCount.Update(int64(len(d.endpointCreator.delegates)))
        go d.dequeue()
        go d.discoverNodeEndpoints(discoveryCfg.PluginConfigs)
        return d
}</span>

func makeProviders(handler metrics.ProviderHandler, discoveryCfg discovery.Config) map[string]discovery.ProviderInfo <span class="cov3" title="2">{
        providers := make(map[string]discovery.ProviderInfo, 2)
        providers["prometheus"] = prometheus.NewProviderInfo(handler, discoveryCfg.AnnotationPrefix)
        providers["telegraf"] = telegraf.NewProviderInfo(handler)
        return providers
}</span>

func makeDelegates(discoveryCfg discovery.Config) map[string]*delegate <span class="cov1" title="1">{
        plugins := discoveryCfg.PluginConfigs
        delegates := make(map[string]*delegate, len(plugins))
        for _, plugin := range plugins </span><span class="cov5" title="4">{
                delegate, err := makeDelegate(plugin)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error parsing plugin: %s error: %v", plugin.Name, err)
                        continue</span>
                }
                <span class="cov5" title="4">delegates[plugin.Name] = delegate</span>
        }
        <span class="cov1" title="1">return delegates</span>
}

func makeDelegate(plugin discovery.PluginConfig) (*delegate, error) <span class="cov5" title="4">{
        filter, err := newResourceFilter(plugin.Selectors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="4">if plugin.Port != "" </span><span class="cov5" title="4">{
                _, err := strconv.ParseInt(plugin.Port, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov5" title="4">if !(strings.Contains(plugin.Type, "prometheus") || strings.Contains(plugin.Type, "telegraf")) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid plugin type: %s", plugin.Type)
        }</span>
        <span class="cov5" title="4">return &amp;delegate{
                filter: filter,
                plugin: plugin,
        }, nil</span>
}

func makeAnnotationExclusions(selectors []discovery.Selectors) []*resourceFilter <span class="cov1" title="1">{
        var filters []*resourceFilter
        for _, selector := range selectors </span><span class="cov1" title="1">{
                filter, err := newResourceFilter(selector)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("invalid annotation exclusion: %s", err.Error())
                        continue</span>
                }
                <span class="cov1" title="1">filters = append(filters, filter)</span>
        }
        <span class="cov1" title="1">return filters</span>
}

func (d *discoverer) enqueue(resource discovery.Resource) <span class="cov10" title="21">{
        d.wg.Add(1)
        defer d.wg.Done()
        d.queue &lt;- resource
}</span>

func (d *discoverer) dequeue() <span class="cov1" title="1">{
        for resource := range d.queue </span><span class="cov10" title="21">{
                switch resource.Status </span>{
                case "delete":<span class="cov0" title="0">
                        d.internalDelete(resource)</span>
                default:<span class="cov10" title="21">
                        d.internalDiscover(resource)</span>
                }
        }
        <span class="cov0" title="0">log.Infof("stopping discoverer deque")</span>
}

func (d *discoverer) Stop() <span class="cov0" title="0">{
        d.wg.Wait()
        close(d.queue)
}</span>

func (d *discoverer) Discover(resource discovery.Resource) <span class="cov10" title="21">{
        d.enqueue(resource)
}</span>

func (d *discoverer) Delete(resource discovery.Resource) <span class="cov0" title="0">{
        resource.Status = "delete"
        d.enqueue(resource)
}</span>

func (d *discoverer) DeleteAll() <span class="cov0" title="0">{
        d.mtx.Lock()
        defer d.mtx.Unlock()

        for k, eps := range d.endpoints </span><span class="cov0" title="0">{
                for _, ep := range eps </span><span class="cov0" title="0">{
                        d.endpointHandler.Delete(ep)
                }</span>
                <span class="cov0" title="0">delete(d.endpoints, k)</span>
        }
}

func (d *discoverer) internalDiscover(resource discovery.Resource) <span class="cov10" title="21">{
        d.mtx.Lock()
        defer d.mtx.Unlock()

        eps := d.endpointCreator.discoverEndpoints(resource)

        resourceName := discovery.ResourceName(resource.Kind, resource.Meta)
        oldEps := d.endpoints[resourceName]
        delete(d.endpoints, resourceName)

        if len(eps) &gt; 0 </span><span class="cov6" title="7">{
                d.endpoints[resourceName] = eps
        }</span>

        <span class="cov10" title="21">if reflect.DeepEqual(eps, oldEps) </span><span class="cov8" title="14">{
                log.Debugf("no endpoint changes for %s", resourceName)
                return
        }</span>

        <span class="cov6" title="7">for _, ep := range oldEps </span><span class="cov0" title="0">{
                d.endpointHandler.Delete(ep)
        }</span>
        <span class="cov6" title="7">for _, ep := range eps </span><span class="cov7" title="9">{
                d.endpointHandler.Add(ep)
        }</span>
}

func (d *discoverer) internalDelete(resource discovery.Resource) <span class="cov0" title="0">{
        d.mtx.Lock()
        defer d.mtx.Unlock()

        resourceName := discovery.ResourceName(resource.Kind, resource.Meta)
        eps := d.endpoints[resourceName]
        delete(d.endpoints, resourceName)

        for _, ep := range eps </span><span class="cov0" title="0">{
                d.endpointHandler.Delete(ep)
        }</span>
}

func (d *discoverer) discoverNodeEndpoints(plugins []discovery.PluginConfig) <span class="cov1" title="1">{
        // wait for listers to index
        time.Sleep(30 * time.Second)

        for _, plugin := range plugins </span><span class="cov5" title="4">{
                if plugin.Selectors.ResourceType == discovery.NodeType.String() </span><span class="cov0" title="0">{
                        err := d.discoverNodeEndpoint(plugin)
                        if err != nil </span><span class="cov0" title="0">{
                                log.WithFields(log.Fields{
                                        "error": err,
                                        "name":  plugin.Name,
                                        "type":  plugin.Type,
                                }).Error("error processing rule")
                        }</span>
                }
        }
}

func (d *discoverer) discoverNodeEndpoint(plugin discovery.PluginConfig) error <span class="cov0" title="0">{
        nodes, err := d.lister.ListNodes()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error listing nodes: %v", err)
        }</span>

        <span class="cov0" title="0">count := len(nodes)
        if count != 1 </span><span class="cov0" title="0">{
                // node based discovery not supported in non-daemonset mode
                return fmt.Errorf("invalid number of nodes found: %d", count)
        }</span>

        <span class="cov0" title="0">_, ip, err := util.GetNodeHostnameAndIP(nodes[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting node IP: %v", err)
        }</span>

        <span class="cov0" title="0">resource := discovery.Resource{
                Kind: discovery.NodeType.String(),
                IP:   ip.String(),
                Meta: metav1.ObjectMeta{Name: util.GetNodeName()},
        }

        d.mtx.Lock()
        defer d.mtx.Unlock()

        if ep := d.endpointCreator.makeEndpoint(resource, plugin); ep != nil </span><span class="cov0" title="0">{
                name := discovery.ResourceName(resource.Kind, resource.Meta)
                var eps []*discovery.Endpoint
                if val, ok := d.endpoints[name]; ok </span><span class="cov0" title="0">{
                        eps = val
                }</span>
                <span class="cov0" title="0">eps = append(eps, ep)
                d.endpoints[name] = eps
                d.endpointHandler.Add(ep)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func pluginType(plugin discovery.PluginConfig) string <span class="cov6" title="7">{
        if strings.Contains(plugin.Type, "prometheus") </span><span class="cov6" title="7">{
                return "prometheus"
        }</span> else<span class="cov5" title="4"> if strings.Contains(plugin.Type, "telegraf") </span><span class="cov5" title="4">{
                return "telegraf"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
)

type endpointCreator struct {
        delegates                  map[string]*delegate
        providers                  map[string]discovery.ProviderInfo
        disableAnnotationDiscovery bool
        annotationExcludes         []*resourceFilter
}

func (e *endpointCreator) discoverEndpointsWithRules(resource discovery.Resource) []*discovery.Endpoint <span class="cov4" title="7">{
        var eps []*discovery.Endpoint
        for _, delegate := range e.delegates </span><span class="cov10" title="84">{
                if delegate.filter.matches(resource) </span><span class="cov4" title="6">{
                        if ep := e.makeEndpoint(resource, delegate.plugin); ep != nil </span><span class="cov4" title="6">{
                                eps = append(eps, ep)
                        }</span>
                }
        }
        <span class="cov4" title="7">return eps</span>
}

func (e *endpointCreator) discoverEndpointsWithAnnotations(resource discovery.Resource) []*discovery.Endpoint <span class="cov4" title="6">{
        for _, exclude := range e.annotationExcludes </span><span class="cov4" title="5">{
                if exclude.matches(resource) </span><span class="cov2" title="2">{
                        return nil
                }</span>
        }
        <span class="cov3" title="4">var eps []*discovery.Endpoint
        if ep := e.makeEndpoint(resource, discovery.PluginConfig{Type: "prometheus"}); ep != nil </span><span class="cov3" title="3">{
                eps = append(eps, ep)
        }</span>

        <span class="cov3" title="4">return eps</span>
}

func (e *endpointCreator) discoverEndpoints(resource discovery.Resource) []*discovery.Endpoint <span class="cov4" title="7">{
        eps := e.discoverEndpointsWithRules(resource)
        if len(eps) == 0 &amp;&amp; !e.disableAnnotationDiscovery </span><span class="cov4" title="6">{
                eps = e.discoverEndpointsWithAnnotations(resource)
        }</span>
        <span class="cov4" title="7">return eps</span>
}

func (e *endpointCreator) makeEndpoint(resource discovery.Resource, plugin discovery.PluginConfig) *discovery.Endpoint <span class="cov3" title="4">{
        if name, cfg, ok := e.Encode(resource, plugin); ok </span><span class="cov5" title="9">{
                return &amp;discovery.Endpoint{
                        Name:       name,
                        Config:     cfg,
                        PluginType: pluginType(plugin),
                }
        }</span>
        <span class="cov6" title="13">return nil</span>
}

func (e *endpointCreator) Encode(resource discovery.Resource, rule discovery.PluginConfig) (string, interface{}, bool) <span class="cov3" title="4">{
        kind := resource.Kind
        ip := resource.IP
        meta := resource.Meta

        if log.IsLevelEnabled(log.DebugLevel) </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{
                        "kind":      kind,
                        "name":      meta.Name,
                        "namespace": meta.Namespace,
                }).Debug("handling resource")
        }</span>

        <span class="cov3" title="4">if delegate, ok := e.providers[pluginType(rule)]; ok </span><span class="cov3" title="4">{
                return delegate.Encoder.Encode(ip, kind, meta, rule)
        }</span>
        <span class="cov0" title="0">return "", nil, false</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "fmt"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"

        "github.com/gobwas/glob"
)

type resourceFilter struct {
        kind       string
        images     glob.Glob
        namespaces glob.Glob
        labels     map[string]glob.Glob
}

func newResourceFilter(selectors discovery.Selectors) (*resourceFilter, error) <span class="cov5" title="7">{
        rf := &amp;resourceFilter{
                images:     filter.Compile(selectors.Images),
                labels:     filter.MultiCompile(selectors.Labels),
                namespaces: filter.Compile(selectors.Namespaces),
        }

        kind, err := resourceType(selectors.ResourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="7">rf.kind = kind
        if rf.kind != discovery.NodeType.String() &amp;&amp; rf.images == nil &amp;&amp; rf.labels == nil &amp;&amp; rf.namespaces == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no selectors specified")
        }</span>
        <span class="cov5" title="7">return rf, nil</span>
}

func resourceType(kind string) (string, error) <span class="cov5" title="7">{
        if kind == "" </span><span class="cov5" title="7">{
                return discovery.PodType.String(), nil
        }</span>
        <span class="cov0" title="0">switch kind </span>{
        case discovery.PodType.String(), discovery.ServiceType.String(), discovery.NodeType.String():<span class="cov0" title="0">
                return kind, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid resource type: %s", kind)</span>
        }
}

func (r *resourceFilter) matches(resource discovery.Resource) bool <span class="cov7" title="22">{
        if r == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov7" title="22">if r.kind != resource.Kind </span><span class="cov7" title="25">{
                return false
        }</span>
        <span class="cov10" title="76">if r.labels != nil &amp;&amp; !matchesTags(r.labels, resource.Meta.Labels) </span><span class="cov4" title="5">{
                return false
        }</span>
        <span class="cov8" title="37">if r.namespaces != nil &amp;&amp; !r.namespaces.Match(resource.Meta.Namespace) </span><span class="cov5" title="11">{
                return false
        }</span>
        <span class="cov7" title="26">if r.images != nil </span><span class="cov7" title="25">{
                for _, container := range resource.Containers </span><span class="cov7" title="25">{
                        if r.images.Match(container.Image) </span><span class="cov4" title="6">{
                                return true
                        }</span>
                }
                <span class="cov3" title="4">return false</span>
        }
        <span class="cov4" title="6">return true</span>
}

func matchesTags(matchers map[string]glob.Glob, tags map[string]string) bool <span class="cov8" title="44">{
        if tags == nil || len(tags) == 0 </span><span class="cov3" title="4">{
                return false
        }</span>
        <span class="cov4" title="6">for k, matcher := range matchers </span><span class="cov5" title="8">{
                val, ok := tags[k]
                if !ok || !matcher.Match(val) </span><span class="cov8" title="39">{
                        return false
                }</span>
        }
        <span class="cov4" title="5">return true</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"

        apiv1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        v1listers "k8s.io/client-go/listers/core/v1"
)

type resourceLister struct {
        podLister     v1listers.PodLister
        serviceLister v1listers.ServiceLister
        nodeLister    v1listers.NodeLister
}

func NewResourceLister(pl v1listers.PodLister, sl v1listers.ServiceLister, nl v1listers.NodeLister) discovery.ResourceLister <span class="cov8" title="1">{
        return &amp;resourceLister{
                podLister:     pl,
                serviceLister: sl,
                nodeLister:    nl,
        }
}</span>

func (rl *resourceLister) ListPods(ns string, l map[string]string) ([]*apiv1.Pod, error) <span class="cov0" title="0">{
        if ns == "" </span><span class="cov0" title="0">{
                return rl.podLister.List(labels.SelectorFromSet(l))
        }</span>
        <span class="cov0" title="0">nsLister := rl.podLister.Pods(ns)
        return nsLister.List(labels.SelectorFromSet(l))</span>
}

func (rl *resourceLister) ListServices(ns string, l map[string]string) ([]*apiv1.Service, error) <span class="cov0" title="0">{
        if ns == "" </span><span class="cov0" title="0">{
                return rl.serviceLister.List(labels.SelectorFromSet(l))
        }</span>
        <span class="cov0" title="0">nsLister := rl.serviceLister.Services(ns)
        return nsLister.List(labels.SelectorFromSet(l))</span>
}

func (rl *resourceLister) ListNodes() ([]*apiv1.Node, error) <span class="cov0" title="0">{
        return rl.nodeLister.List(labels.Everything())
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "reflect"
        "time"

        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        gm "github.com/rcrowley/go-metrics"

        "k8s.io/client-go/kubernetes"
)

const (
        subscriberName = "discovery.manager"
)

var (
        discoveryEnabled gm.Counter
)

func init() <span class="cov1" title="1">{
        discoveryEnabled = gm.GetOrRegisterCounter("discovery.enabled", gm.DefaultRegistry)
}</span>

// RunConfig encapsulates the runtime configuration required for a discovery manager
type RunConfig struct {
        KubeClient             kubernetes.Interface
        DiscoveryConfig        discovery.Config
        Handler                metrics.ProviderHandler
        InternalPluginProvider discovery.PluginProvider
        Lister                 discovery.ResourceLister
        ScrapeCluster          bool
}

// Manager manages the discovery of kubernetes targets based on annotations or configuration rules.
type Manager struct {
        runConfig       RunConfig
        discoverer      discovery.Discoverer
        configListener  *configHandler
        podListener     *podHandler
        serviceListener *serviceHandler
        leadershipMgr   *leadership.Manager
        stopCh          chan struct{}
}

// NewDiscoveryManager creates a new instance of a discovery manager based on the given configuration.
func NewDiscoveryManager(cfg RunConfig) *Manager <span class="cov1" title="1">{
        mgr := &amp;Manager{
                runConfig: cfg,
                stopCh:    make(chan struct{}),
        }
        mgr.leadershipMgr = leadership.NewManager(mgr, subscriberName, cfg.KubeClient)
        return mgr
}</span>

func (dm *Manager) Start() <span class="cov1" title="1">{
        log.Infof("Starting discovery manager")
        discoveryEnabled.Inc(1)

        dm.stopCh = make(chan struct{})

        // init configuration file and discoverer
        cfg := dm.runConfig.DiscoveryConfig
        if cfg.EnableRuntimePlugins </span><span class="cov1" title="1">{
                log.Info("runtime plugins enabled")
                dm.configListener = newConfigHandler(
                        dm.runConfig.KubeClient,
                        dm.runConfig.DiscoveryConfig,
                        dm.runConfig.InternalPluginProvider,
                )
                if !dm.configListener.start() </span><span class="cov0" title="0">{
                        log.Error("timed out waiting for configmap caches to sync")
                }</span>
                <span class="cov1" title="1">cfg = dm.configListener.Config()</span>
        }
        <span class="cov1" title="1">dm.discoverer = newDiscoverer(dm.runConfig.Handler, cfg, dm.runConfig.Lister)
        dm.startResyncConfig()

        // init discovery handlers
        dm.podListener = newPodHandler(dm.runConfig.KubeClient, dm.discoverer)
        if util.ScrapeAnyNodes() </span><span class="cov1" title="1">{
                dm.podListener.start()
        }</span>
        <span class="cov1" title="1">dm.serviceListener = newServiceHandler(dm.runConfig.KubeClient, dm.discoverer)

        if dm.runConfig.ScrapeCluster </span><span class="cov1" title="1">{
                dm.leadershipMgr.Start()
        }</span>
}

func (dm *Manager) Stop() <span class="cov0" title="0">{
        log.Infof("Stopping discovery manager")
        discoveryEnabled.Dec(1)

        leadership.Unsubscribe(subscriberName)
        if dm.configListener != nil </span><span class="cov0" title="0">{
                dm.configListener.stop()
        }</span>
        <span class="cov0" title="0">dm.podListener.stop()
        dm.serviceListener.stop()
        close(dm.stopCh)

        dm.discoverer.Stop()
        dm.discoverer.DeleteAll()</span>
}

func (dm *Manager) Resume() <span class="cov1" title="1">{
        log.Infof("elected leader: %s starting service discovery", leadership.Leader())
        dm.serviceListener.start()
}</span>

func (dm *Manager) Pause() <span class="cov0" title="0">{
        log.Infof("stopping service discovery. new leader: %s", leadership.Leader())
        dm.serviceListener.stop()
}</span>

// startResyncConfig periodically checks for changes to the discovery config.
// It stops monitoring existing resources and reloads the discovery manager on changes
func (dm *Manager) startResyncConfig() <span class="cov1" title="1">{
        if !dm.runConfig.DiscoveryConfig.EnableRuntimePlugins </span><span class="cov0" title="0">{
                log.Info("runtime plugins disabled")
                return
        }</span>

        <span class="cov1" title="1">interval := dm.runConfig.DiscoveryConfig.DiscoveryInterval
        log.Infof("discovery config interval: %v", interval)

        go NotifyOfChanges(func() discovery.Config </span><span class="cov1" title="1">{
                log.Info("checking for runtime plugin changes")
                return dm.configListener.Config()
        }</span>, func() <span class="cov0" title="0">{
                log.Info("found new runtime plugins")
                dm.Stop()
                dm.Start()

        }</span>, interval, dm.stopCh)
}

func NotifyOfChanges(get func() discovery.Config, notify func(), interval time.Duration, stopCh chan struct{}) <span class="cov5" title="3">{
        prevVal := get()
        util.Retry(func() </span><span class="cov10" title="9">{
                val := get()
                if !reflect.DeepEqual(val, prevVal) </span><span class="cov3" title="2">{
                        notify()
                }</span>
        }, interval, stopCh)
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        v1 "k8s.io/api/core/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
)

type podHandler struct {
        ch       chan struct{}
        informer cache.SharedInformer
}

func newPodHandler(kubeClient kubernetes.Interface, discoverer discovery.Discoverer) *podHandler <span class="cov1" title="1">{
        client := kubeClient.CoreV1().RESTClient()
        fieldSelector := util.GetFieldSelector("pods")
        lw := cache.NewListWatchFromClient(client, "pods", v1.NamespaceAll, fieldSelector)
        inf := cache.NewSharedInformer(lw, &amp;v1.Pod{}, 1*time.Hour)

        inf.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov9" title="22">{
                        updatePodIfValid(obj, discoverer)
                }</span>,
                UpdateFunc: func(_, obj interface{}) <span class="cov4" title="3">{
                        updatePodIfValid(obj, discoverer)
                }</span>,
                DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                        deletePodIfValid(obj, discoverer)
                }</span>,
        })
        <span class="cov1" title="1">return &amp;podHandler{
                informer: inf,
        }</span>
}

func deletePodIfValid(obj interface{}, discoverer discovery.Discoverer) <span class="cov1" title="1">{
        pod, ok := obj.(*v1.Pod)
        if ok </span><span class="cov0" title="0">{
                discoverer.Delete(discovery.Resource{
                        Kind:       discovery.PodType.String(),
                        IP:         pod.Status.PodIP,
                        Meta:       pod.ObjectMeta,
                        Containers: pod.Spec.Containers,
                })
        }</span>
}

func updatePodIfValid(obj interface{}, discoverer discovery.Discoverer) <span class="cov10" title="25">{
        pod, ok := obj.(*v1.Pod)
        if ok </span><span class="cov10" title="25">{
                podUpdated(pod, discoverer)
        }</span>
}

func podUpdated(pod *v1.Pod, discoverer discovery.Discoverer) <span class="cov10" title="25">{
        if podReady(pod) </span><span class="cov8" title="16">{
                discoverer.Discover(discovery.Resource{
                        Kind:       discovery.PodType.String(),
                        IP:         pod.Status.PodIP,
                        Meta:       pod.ObjectMeta,
                        Containers: pod.Spec.Containers,
                })
        }</span>
}

func podReady(pod *v1.Pod) bool <span class="cov10" title="25">{
        if pod.Status.Phase != "Running" </span><span class="cov7" title="9">{
                return false
        }</span>
        <span class="cov8" title="16">if pod.Status.PodIP == "" || pod.Status.PodIP == "None" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="16">return true</span>
}

func (handler *podHandler) start() <span class="cov1" title="1">{
        handler.ch = make(chan struct{})
        go handler.informer.Run(handler.ch)
}</span>

func (handler *podHandler) stop() <span class="cov0" title="0">{
        if handler.ch != nil </span><span class="cov0" title="0">{
                close(handler.ch)
        }</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/utils"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        log "github.com/sirupsen/logrus"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        scrapeAnnotationFormat             = "%s/scrape"
        schemeAnnotationFormat             = "%s/scheme"
        pathAnnotationFormat               = "%s/path"
        portAnnotationFormat               = "%s/port"
        prefixAnnotationFormat             = "%s/prefix"
        labelsAnnotationFormat             = "%s/includeLabels"
        sourceAnnotationFormat             = "%s/source"
        collectionIntervalAnnotationFormat = "%s/collectionInterval"
        timeoutAnnotationFormat            = "%s/timeout"
        insecureSkipVerifyFormat           = "%s/insecureSkipVerify"
        serverNameFormat                   = "%s/serverName"
)

// used as source for discovered resources
var nodeName string

func init() <span class="cov1" title="1">{
        nodeName = util.GetNodeName()
}</span>

type prometheusEncoder struct {
        scrapeAnnotation             string
        schemeAnnotation             string
        pathAnnotation               string
        portAnnotation               string
        prefixAnnotation             string
        labelsAnnotation             string
        sourceAnnotation             string
        collectionIntervalAnnotation string
        timeoutAnnotation            string
        insecureSkipVerifyAnnotation string
        serverNameAnnotation         string
}

func newPrometheusEncoder(prefix string) prometheusEncoder <span class="cov4" title="5">{
        if len(prefix) == 0 </span><span class="cov2" title="2">{
                prefix = "prometheus.io"
        }</span>
        <span class="cov4" title="5">return prometheusEncoder{
                scrapeAnnotation:             customAnnotation(scrapeAnnotationFormat, prefix),
                schemeAnnotation:             customAnnotation(schemeAnnotationFormat, prefix),
                pathAnnotation:               customAnnotation(pathAnnotationFormat, prefix),
                portAnnotation:               customAnnotation(portAnnotationFormat, prefix),
                prefixAnnotation:             customAnnotation(prefixAnnotationFormat, prefix),
                labelsAnnotation:             customAnnotation(labelsAnnotationFormat, prefix),
                sourceAnnotation:             customAnnotation(sourceAnnotationFormat, prefix),
                collectionIntervalAnnotation: customAnnotation(collectionIntervalAnnotationFormat, prefix),
                timeoutAnnotation:            customAnnotation(timeoutAnnotationFormat, prefix),
                insecureSkipVerifyAnnotation: customAnnotation(insecureSkipVerifyFormat, prefix),
                serverNameAnnotation:         customAnnotation(serverNameFormat, prefix),
        }</span>
}

func (e prometheusEncoder) Encode(ip, kind string, meta metav1.ObjectMeta, cfg interface{}) (string, interface{}, bool) <span class="cov5" title="6">{
        if ip == "" || ip == "None" </span><span class="cov1" title="1">{
                log.Debugf("missing ip for %s=%s", kind, meta.Name)
                return "", configuration.PrometheusSourceConfig{}, false
        }</span>

        <span class="cov4" title="5">result := configuration.PrometheusSourceConfig{
                Transforms: configuration.Transforms{
                        Tags: make(map[string]string),
                },
        }

        rule := discovery.PluginConfig{}
        discoveryType := "annotation"
        if cfg != nil </span><span class="cov4" title="5">{
                rule = cfg.(discovery.PluginConfig)
                if rule.Name != "" </span><span class="cov4" title="4">{
                        discoveryType = "rule"
                }</span>
        }
        <span class="cov4" title="5">result.Discovered = discoveryType

        if kind == discovery.ServiceType.String() </span><span class="cov4" title="5">{
                // always use leader election for cluster level resources
                result.UseLeaderElection = true
        }</span>

        <span class="cov4" title="5">collectionInterval := utils.Param(meta, e.collectionIntervalAnnotation, rule.Collection.Interval.String(), "0s")
        timeout := utils.Param(meta, e.timeoutAnnotation, rule.Collection.Timeout.String(), "0s")

        collectionDuration, err := time.ParseDuration(collectionInterval)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error parsing collection interval: %s %v", collectionInterval, err)
                return "", result, false
        }</span>
        <span class="cov4" title="5">timeoutDuration, err := time.ParseDuration(timeout)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error parsing timeout: %s %v", timeout, err)
                return "", result, false
        }</span>
        <span class="cov4" title="5">result.Collection = configuration.CollectionConfig{
                Interval: collectionDuration,
                Timeout:  timeoutDuration,
        }

        scrape := utils.Param(meta, e.scrapeAnnotation, "", "false")
        if rule.Name == "" &amp;&amp; scrape != "true" </span><span class="cov2" title="2">{
                log.Debugf("prometheus scrape=false for %s=%s", kind, meta.Name)
                return "", result, false
        }</span>

        <span class="cov5" title="7">scheme := utils.Param(meta, e.schemeAnnotation, rule.Scheme, "http")
        path := utils.Param(meta, e.pathAnnotation, rule.Path, "/metrics")
        port := utils.Param(meta, e.portAnnotation, rule.Port, "")
        prefix := utils.Param(meta, e.prefixAnnotation, rule.Prefix, "")
        source := utils.Param(meta, e.sourceAnnotation, rule.Source, nodeName)
        includeLabels := utils.Param(meta, e.labelsAnnotation, rule.IncludeLabels, "true")
        insecureSkipVerify := utils.Param(meta, e.insecureSkipVerifyAnnotation, "", "")
        serverName := utils.Param(meta, e.serverNameAnnotation, "", "")

        if source == "" </span><span class="cov3" title="3">{
                source = meta.Name
        }</span>
        <span class="cov5" title="7">name := discovery.ResourceName(kind, meta)
        port = sanitizePort(meta.Name, port)
        name = uniqueName(name, port, path, rule.Internal)

        encodeBase(&amp;result, scheme, ip, port, path, name, source, prefix)
        utils.EncodeMeta(result.Tags, kind, meta)
        utils.EncodeTags(result.Tags, "", rule.Tags)
        if includeLabels == "true" </span><span class="cov5" title="7">{
                utils.EncodeTags(result.Tags, "label.", meta.Labels)
        }</span>
        <span class="cov5" title="7">result.Filters = rule.Filters

        err = encodeHTTPConf(&amp;result, rule.Conf, insecureSkipVerify, serverName)
        if err != nil </span><span class="cov0" title="0">{
                return "", result, false
        }</span>
        <span class="cov5" title="7">return name, result, true</span>
}

func encodeHTTPConf(cfg *configuration.PrometheusSourceConfig, conf, insecure, serverName string) error <span class="cov5" title="7">{
        if conf != "" </span><span class="cov1" title="1">{
                httpConf, err := httputil.FromYAML([]byte(conf))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">cfg.HTTPClientConfig = httpConf</span>
        } else<span class="cov5" title="7"> {
                insecureBool := true
                if len(insecure) &gt; 0 </span><span class="cov0" title="0">{
                        insecureBool, _ = strconv.ParseBool(insecure)
                }</span> else<span class="cov5" title="7"> if len(serverName) &gt; 0 </span><span class="cov0" title="0">{
                        insecureBool = false
                }</span>
                <span class="cov5" title="7">cfg.HTTPClientConfig = httputil.ClientConfig{
                        TLSConfig: httputil.TLSConfig{
                                InsecureSkipVerify: insecureBool,
                                ServerName:         serverName,
                        },
                }</span>
        }
        <span class="cov5" title="7">return nil</span>
}

func encodeBase(cfg *configuration.PrometheusSourceConfig, scheme, ip, port, path, name, source, prefix string) <span class="cov5" title="7">{
        if port != "" </span><span class="cov5" title="7">{
                port = fmt.Sprintf(":%s", port)
        }</span>
        <span class="cov5" title="7">cfg.URL = fmt.Sprintf("%s://%s%s%s", scheme, ip, port, path)
        cfg.Name = name
        cfg.Source = source
        cfg.Prefix = prefix</span>
}

func sanitizePort(name, port string) string <span class="cov5" title="7">{
        if strings.Contains(name, "kube-state-metrics") &amp;&amp; port == "" </span><span class="cov0" title="0">{
                log.Debugf("using port 8080 for %s", name)
                return "8080"
        }</span>
        <span class="cov5" title="7">return port</span>
}

func customAnnotation(annotationFormat, prefix string) string <span class="cov10" title="55">{
        return fmt.Sprintf(annotationFormat, prefix)
}</span>

func uniqueName(name, port, path string, internal bool) string <span class="cov5" title="7">{
        out := name
        if port != "" </span><span class="cov5" title="7">{
                out = fmt.Sprintf("%s:%s", out, port)
        }</span>
        <span class="cov5" title="7">if path != "" </span><span class="cov5" title="7">{
                out = fmt.Sprintf("%s%s", out, path)
        }</span>
        <span class="cov5" title="7">if internal </span><span class="cov2" title="2">{
                out = out + ".internal"
        }</span>
        <span class="cov5" title="7">return out</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus"
)

func NewProviderInfo(handler metrics.ProviderHandler, prefix string) discovery.ProviderInfo <span class="cov10" title="5">{
        return discovery.ProviderInfo{
                Handler: handler,
                Factory: prometheus.NewFactory(),
                Encoder: newPrometheusEncoder(prefix),
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package discovery

import (
        "context"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"

        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
)

type serviceHandler struct {
        ch       chan struct{}
        informer cache.SharedInformer
}

func newServiceHandler(kubeClient kubernetes.Interface, discoverer discovery.Discoverer) *serviceHandler <span class="cov1" title="1">{
        s := kubeClient.CoreV1().Services(v1.NamespaceAll)
        lw := &amp;cache.ListWatch{
                ListFunc: func(options metav1.ListOptions) (runtime.Object, error) </span><span class="cov1" title="1">{
                        return s.List(context.Background(), options)
                }</span>,
                WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) <span class="cov1" title="1">{
                        return s.Watch(context.Background(), options)
                }</span>,
        }
        <span class="cov1" title="1">inf := cache.NewSharedInformer(lw, &amp;v1.Service{}, 1*time.Hour)

        inf.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov10" title="6">{
                        updateServiceIfValid(obj, discoverer)
                }</span>,
                UpdateFunc: func(_, obj interface{}) <span class="cov0" title="0">{
                        updateServiceIfValid(obj, discoverer)
                }</span>,
                DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                        deleteServiceIfValid(obj, discoverer)
                }</span>,
        })
        <span class="cov1" title="1">return &amp;serviceHandler{
                informer: inf,
        }</span>
}

func deleteServiceIfValid(obj interface{}, discoverer discovery.Discoverer) <span class="cov0" title="0">{
        service, ok := obj.(*v1.Service)
        if ok </span><span class="cov0" title="0">{
                discoverer.Discover(discovery.Resource{
                        Kind: discovery.ServiceType.String(),
                        IP:   service.Spec.ClusterIP,
                        Meta: service.ObjectMeta,
                })
        }</span>
}

func updateServiceIfValid(obj interface{}, discoverer discovery.Discoverer) <span class="cov10" title="6">{
        service, ok := obj.(*v1.Service)
        if ok &amp;&amp; hasIP(service.Spec.ClusterIP) </span><span class="cov9" title="5">{
                discoverer.Discover(discovery.Resource{
                        Kind: discovery.ServiceType.String(),
                        IP:   service.Spec.ClusterIP,
                        Meta: service.ObjectMeta,
                })
        }</span>
}

func hasIP(ip string) bool <span class="cov10" title="6">{
        return ip != "" &amp;&amp; ip != "None"
}</span>

func (handler *serviceHandler) start() <span class="cov1" title="1">{
        handler.ch = make(chan struct{})
        go handler.informer.Run(handler.ch)
}</span>

func (handler *serviceHandler) stop() <span class="cov0" title="0">{
        if handler.ch != nil </span><span class="cov0" title="0">{
                close(handler.ch)
        }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "fmt"
        "strings"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery/utils"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var defaultEncoder = telegrafEncoder{}

func NewProviderInfo(handler metrics.ProviderHandler) discovery.ProviderInfo <span class="cov10" title="5">{
        return discovery.ProviderInfo{
                Handler: handler,
                Factory: telegraf.NewFactory(),
                Encoder: defaultEncoder,
        }
}</span>

type telegrafEncoder struct{}

func NewEncoder() discovery.Encoder <span class="cov0" title="0">{
        return telegrafEncoder{}
}</span>

func (e telegrafEncoder) Encode(ip, kind string, meta metav1.ObjectMeta, rule interface{}) (string, interface{}, bool) <span class="cov4" title="2">{
        if ip == "" || ip == "None" </span><span class="cov0" title="0">{
                return "", configuration.TelegrafSourceConfig{}, false
        }</span>

        <span class="cov4" title="2">result := configuration.TelegrafSourceConfig{
                Transforms: configuration.Transforms{
                        Tags: make(map[string]string),
                },
        }

        if kind == discovery.ServiceType.String() </span><span class="cov0" title="0">{
                // always use leader election for cluster level resources
                result.UseLeaderElection = true
        }</span>

        // panics if rule is not of expected type
        <span class="cov4" title="2">cfg := rule.(discovery.PluginConfig)
        name := uniqueName(discovery.ResourceName(kind, meta), cfg.Port)
        pluginName := strings.Replace(cfg.Type, "telegraf/", "", -1)

        result.Discovered = "rule"
        result.Plugins = []string{pluginName}
        result.Name = name

        // parse telegraf configuration
        scheme := utils.Param(meta, "", cfg.Scheme, "http")
        server := fmt.Sprintf("%s://%s:%s", scheme, ip, cfg.Port)
        conf := strings.Replace(cfg.Conf, "${server}", server, -1)
        conf = strings.Replace(conf, "${host}", ip, -1)
        conf = strings.Replace(conf, "${port}", cfg.Port, -1)
        result.Conf = conf

        // parse prefix, tags, labels and filters
        prefix := utils.Param(meta, discovery.PrefixAnnotation, cfg.Prefix, "")
        includeLabels := utils.Param(meta, discovery.LabelsAnnotation, cfg.IncludeLabels, "true")

        result.Prefix = prefix
        result.Collection = configuration.CollectionConfig{
                Interval: cfg.Collection.Interval,
                Timeout:  cfg.Collection.Timeout,
        }

        utils.EncodeMeta(result.Tags, kind, meta)
        utils.EncodeTags(result.Tags, "", cfg.Tags)
        if includeLabels == "true" </span><span class="cov4" title="2">{
                utils.EncodeTags(result.Tags, "label.", meta.Labels)
        }</span>
        <span class="cov4" title="2">result.Filters = cfg.Filters

        return name, result, true</span>
}

func uniqueName(name, port string) string <span class="cov4" title="2">{
        if port == "" </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov4" title="2">return fmt.Sprintf("%s:%s", name, port)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package events

import (
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/events"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront"
        "github.com/wavefronthq/wavefront-sdk-go/event"

        gometrics "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"

        v1 "k8s.io/api/core/v1"

        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        corelisters "k8s.io/client-go/listers/core/v1"
        "k8s.io/client-go/tools/cache"
)

var Log = log.WithField("system", "events")
var leadershipName = "eventRouter"
var filteredEvents = gometrics.GetOrRegisterCounter("events.filtered", gometrics.DefaultRegistry)
var receivedEvents = gometrics.GetOrRegisterCounter("events.received", gometrics.DefaultRegistry)
var sentEvents = gometrics.GetOrRegisterCounter("events.sent", gometrics.DefaultRegistry)

type EventRouter struct {
        kubeClient        kubernetes.Interface
        eLister           corelisters.EventLister
        eListerSynced     cache.InformerSynced
        sink              wavefront.WavefrontSink
        sharedInformers   informers.SharedInformerFactory
        stop              chan struct{}
        scrapeCluster     bool
        leadershipManager *leadership.Manager
        filters           eventFilter
}

func NewEventRouter(clientset kubernetes.Interface, cfg configuration.EventsConfig, sink wavefront.WavefrontSink, scrapeCluster bool) *EventRouter <span class="cov0" title="0">{
        sharedInformers := informers.NewSharedInformerFactory(clientset, time.Minute)
        eventsInformer := sharedInformers.Core().V1().Events()

        er := &amp;EventRouter{
                kubeClient:      clientset,
                sink:            sink,
                scrapeCluster:   scrapeCluster,
                sharedInformers: sharedInformers,
                filters:         newEventFilter(cfg.Filters),
        }

        eventsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: er.addEvent,
        })
        er.eLister = eventsInformer.Lister()
        er.eListerSynced = eventsInformer.Informer().HasSynced
        er.leadershipManager = leadership.NewManager(er, leadershipName, clientset)

        return er
}</span>

func (er *EventRouter) Start() <span class="cov0" title="0">{
        if er.scrapeCluster </span><span class="cov0" title="0">{
                er.leadershipManager.Start()
        }</span>
}

func (er *EventRouter) Resume() <span class="cov0" title="0">{
        er.stop = make(chan struct{})

        Log.Infof("Starting EventRouter")

        go func() </span><span class="cov0" title="0">{ er.sharedInformers.Start(er.stop) }</span>()

        // here is where we kick the caches into gear
        <span class="cov0" title="0">if !cache.WaitForCacheSync(er.stop, er.eListerSynced) </span><span class="cov0" title="0">{
                log.Error("timed out waiting for caches to sync")
                return
        }</span>
        <span class="cov0" title="0">&lt;-er.stop

        Log.Infof("Shutting down EventRouter")</span>
}

func (er *EventRouter) Pause() <span class="cov0" title="0">{
        if er.stop != nil </span><span class="cov0" title="0">{
                close(er.stop)
        }</span>
}

func (er *EventRouter) Stop() <span class="cov0" title="0">{
        if er.scrapeCluster </span><span class="cov0" title="0">{
                er.leadershipManager.Stop()
        }</span>
        <span class="cov0" title="0">er.Pause()</span>
}

// addEvent is called when an event is created, or during the initial list
func (er *EventRouter) addEvent(obj interface{}) <span class="cov0" title="0">{
        e, ok := obj.(*v1.Event)
        if !ok </span><span class="cov0" title="0">{
                return // prevent unlikely panic
        }</span>

        // ignore events older than a minute to prevent surge on startup
        <span class="cov0" title="0">if e.LastTimestamp.Time.Before(time.Now().Add(-1 * time.Minute)) </span><span class="cov0" title="0">{
                Log.WithField("event", e.Message).Trace("Ignoring older event")
                return
        }</span>

        <span class="cov0" title="0">ns := e.InvolvedObject.Namespace
        if len(ns) == 0 </span><span class="cov0" title="0">{
                ns = "default"
        }</span>

        <span class="cov0" title="0">tags := map[string]string{
                "namespace_name": ns,
                "kind":           e.InvolvedObject.Kind,
                "reason":         e.Reason,
                "component":      e.Source.Component,
        }

        resourceName := e.InvolvedObject.Name
        if resourceName != "" </span><span class="cov0" title="0">{
                if strings.ToLower(e.InvolvedObject.Kind) == "pod" </span><span class="cov0" title="0">{
                        tags["pod_name"] = resourceName
                }</span> else<span class="cov0" title="0"> {
                        tags["resource_name"] = resourceName
                }</span>
        }

        <span class="cov0" title="0">receivedEvents.Inc(1)
        if !er.filters.matches(tags) </span><span class="cov0" title="0">{
                if log.IsLevelEnabled(log.TraceLevel) </span><span class="cov0" title="0">{
                        Log.WithField("event", e.Message).Trace("Dropping event")
                }</span>
                <span class="cov0" title="0">filteredEvents.Inc(1)
                return</span>
        }
        <span class="cov0" title="0">sentEvents.Inc(1)

        eType := e.Type
        if len(eType) == 0 </span><span class="cov0" title="0">{
                eType = "Normal"
        }</span>

        <span class="cov0" title="0">er.sink.ExportEvent(newEvent(
                e.Message,
                e.LastTimestamp.Time,
                e.Source.Host,
                tags,
                event.Type(eType),
        ))</span>
}

func newEvent(message string, ts time.Time, host string, tags map[string]string, options ...event.Option) *events.Event <span class="cov0" title="0">{
        // convert tags to annotations
        for k, v := range tags </span><span class="cov0" title="0">{
                options = append(options, event.Annotate(k, v))
        }</span>

        <span class="cov0" title="0">return &amp;events.Event{
                Message: message,
                Ts:      ts,
                Host:    host,
                Options: options,
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
package events

import (
        "github.com/gobwas/glob"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
)

type eventFilter struct {
        allowList     map[string]glob.Glob
        denyList      map[string]glob.Glob
        allowListSets []map[string]glob.Glob
        denyListSets  []map[string]glob.Glob
}

func newEventFilter(filters configuration.EventsFilter) eventFilter <span class="cov7" title="8">{
        allowList := filters.TagWhitelist
        if len(filters.TagAllowList) &gt; 0 </span><span class="cov1" title="1">{
                allowList = filters.TagAllowList
        }</span>
        <span class="cov7" title="8">denyList := filters.TagBlacklist
        if len(filters.TagDenyList) &gt; 0 </span><span class="cov1" title="1">{
                denyList = filters.TagDenyList
        }</span>
        <span class="cov7" title="8">allowListSets := filters.TagWhitelistSets
        if len(filters.TagAllowListSets) &gt; 0 </span><span class="cov1" title="1">{
                allowListSets = filters.TagAllowListSets
        }</span>
        <span class="cov7" title="8">denyListSets := filters.TagBlacklistSets
        if len(filters.TagDenyListSets) &gt; 0 </span><span class="cov1" title="1">{
                denyListSets = filters.TagDenyListSets
        }</span>

        <span class="cov7" title="8">return eventFilter{
                allowList:     filter.MultiCompile(allowList),
                denyList:      filter.MultiCompile(denyList),
                allowListSets: filter.MultiSetCompile(allowListSets),
                denyListSets:  filter.MultiSetCompile(denyListSets),
        }</span>
}

func (ef eventFilter) matches(tags map[string]string) bool <span class="cov10" title="16">{
        if len(ef.allowList) &gt; 0 &amp;&amp; !filter.MatchesTags(ef.allowList, tags) </span><span class="cov3" title="2">{
                return false
        }</span>
        <span class="cov9" title="14">if len(ef.denyList) &gt; 0 &amp;&amp; filter.MatchesTags(ef.denyList, tags) </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov9" title="12">if len(ef.allowListSets) &gt; 0 </span><span class="cov5" title="4">{
                // AND tags within a set, OR between sets
                for _, wl := range ef.allowListSets </span><span class="cov5" title="4">{
                        if filter.MatchesAllTags(wl, tags) </span><span class="cov3" title="2">{
                                return true
                        }</span>
                }
                <span class="cov3" title="2">return false</span>
        }
        <span class="cov7" title="8">if len(ef.denyListSets) &gt; 0 </span><span class="cov5" title="4">{
                // AND tags within a set, OR between sets
                for _, bl := range ef.denyListSets </span><span class="cov5" title="4">{
                        if filter.MatchesAllTags(bl, tags) </span><span class="cov3" title="2">{
                                return false
                        }</span>
                }
        }
        <span class="cov6" title="6">return true</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/metrics/manager/manager.go
// Diff against master for changes to the original code.

// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package manager

import (
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources"

        log "github.com/sirupsen/logrus"
)

// FlushManager deals with data push
type FlushManager interface {
        Start()
        Stop()
}

type flushManagerImpl struct {
        processors    []metrics.Processor
        sink          wavefront.WavefrontSink
        flushInterval time.Duration
        ticker        *time.Ticker
        stopChan      chan struct{}
}

// NewFlushManager crates a new PushManager
func NewFlushManager(processors []metrics.Processor,
        sink wavefront.WavefrontSink, flushInterval time.Duration) (FlushManager, error) <span class="cov1" title="1">{
        manager := flushManagerImpl{
                processors:    processors,
                sink:          sink,
                flushInterval: flushInterval,
                stopChan:      make(chan struct{}),
        }

        return &amp;manager, nil
}</span>

func (rm *flushManagerImpl) Start() <span class="cov1" title="1">{
        rm.ticker = time.NewTicker(rm.flushInterval)
        go rm.run()
}</span>

func (rm *flushManagerImpl) run() <span class="cov1" title="1">{
        for </span><span class="cov8" title="6">{
                select </span>{
                case &lt;-rm.ticker.C:<span class="cov7" title="5">
                        go rm.push()</span>
                case &lt;-rm.stopChan:<span class="cov1" title="1">
                        rm.ticker.Stop()
                        rm.sink.Stop()
                        return</span>
                }
        }
}

func (rm *flushManagerImpl) Stop() <span class="cov1" title="1">{
        rm.stopChan &lt;- struct{}{}
}</span>

func (rm *flushManagerImpl) push() <span class="cov7" title="5">{
        dataBatches := sources.Manager().GetPendingMetrics()
        combinedBatch := &amp;metrics.Batch{}

        for _, data := range dataBatches </span><span class="cov7" title="4">{
                combineMetricSets(data, combinedBatch)
        }</span>

        // process the combined metric sets
        <span class="cov7" title="5">for _, p := range rm.processors </span><span class="cov7" title="5">{
                processedBatch, err := p.Process(combinedBatch)
                if err == nil </span><span class="cov7" title="5">{
                        combinedBatch = processedBatch
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Error in processor: %v", err)
                        return
                }</span>
        }

        <span class="cov7" title="5">rm.sink.Export(combinedBatch)</span>
}

func combineMetricSets(src, dst *metrics.Batch) <span class="cov8" title="6">{
        // use the most recent timestamp for the shared batch
        dst.Timestamp = src.Timestamp
        if dst.Sets == nil </span><span class="cov7" title="5">{
                dst.Sets = make(map[metrics.ResourceKey]*metrics.Set)
        }</span>
        <span class="cov8" title="6">for k, v := range src.Sets </span><span class="cov10" title="8">{
                dst.Sets[k] = v
        }</span>
        <span class="cov8" title="6">dst.Metrics = append(dst.Metrics, src.Metrics...)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

func NewClusterAggregator(metricsToAggregate []string) metrics.Processor <span class="cov1" title="1">{
        return NewSumCountAggregator("cluster", []SumCountAggregateSpec{
                {
                        ResourceSumMetrics:  metricsToAggregate,
                        ResourceCountMetric: metrics.MetricPodCount.Name,
                        IsPartOfGroup:       isType(metrics.MetricSetTypeNamespace),
                        Group:               clusterGroup,
                },
                {
                        ResourceSumMetrics:  []string{},
                        ResourceCountMetric: metrics.MetricPodContainerCount.Name,
                        IsPartOfGroup:       isType(metrics.MetricSetTypeNamespace),
                        Group:               clusterGroup,
                },
        })
}</span>

func clusterGroup(batch *metrics.Batch, _ metrics.ResourceKey, _ *metrics.Set) (metrics.ResourceKey, *metrics.Set) <span class="cov10" title="4">{
        clusterSet := batch.Sets[metrics.ClusterKey()]
        if clusterSet == nil </span><span class="cov10" title="4">{
                clusterSet = clusterMetricSet()
        }</span>
        <span class="cov10" title="4">return metrics.ClusterKey(), clusterSet</span>
}

func clusterMetricSet() *metrics.Set <span class="cov10" title="4">{
        return &amp;metrics.Set{
                Values: make(map[string]metrics.Value),
                Labels: map[string]string{
                        metrics.LabelMetricSetType.Key: metrics.MetricSetTypeCluster,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package processors

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
)

type CumulativeDistributionConverter struct {
}

func (rc *CumulativeDistributionConverter) Name() string <span class="cov0" title="0">{
        return "cumulative distribution converter"
}</span>

func (rc *CumulativeDistributionConverter) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov2" title="4">{
        batch.Metrics = mapInPlace(func(metric wf.Metric) wf.Metric </span><span class="cov10" title="109020">{
                distribution, ok := metric.(*wf.Distribution)
                if !ok </span><span class="cov10" title="109020">{
                        return metric
                }</span>
                <span class="cov1" title="1">return distribution.ToFrequency()</span>
        }, batch.Metrics)
        <span class="cov2" title="4">return batch, nil</span>
}

func mapInPlace(transform func(wf.Metric) wf.Metric, es []wf.Metric) []wf.Metric <span class="cov2" title="4">{
        for i, e := range es </span><span class="cov10" title="109020">{
                es[i] = transform(e)
        }</span>
        <span class="cov2" title="4">return es</span>
}

func NewCumulativeDistributionConverter() *CumulativeDistributionConverter <span class="cov1" title="1">{
        return &amp;CumulativeDistributionConverter{}
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package processors

import (
        "sync"

        gometrics "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
)

func DuplicateHistogramCounter(name string) gometrics.Counter <span class="cov2" title="6">{
        return gometrics.GetOrRegisterCounter(
                reporting.EncodeKey("histograms.duplicates", map[string]string{"metricname": name}),
                gometrics.DefaultRegistry,
        )
}</span>

type DistributionRateCalculator struct {
        lock              sync.Mutex
        prevDistributions map[wf.DistributionHash]*wf.Distribution
}

func (rc *DistributionRateCalculator) Name() string <span class="cov0" title="0">{
        return "distribution rate calculator"
}</span>

func (rc *DistributionRateCalculator) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov2" title="9">{
        rc.lock.Lock()
        defer rc.lock.Unlock()
        seen := map[wf.DistributionHash]struct{}{}
        batch.Metrics = filterMapInPlace(func(metric wf.Metric) (wf.Metric, bool) </span><span class="cov3" title="14">{
                distribution, ok := metric.(*wf.Distribution)
                if !ok </span><span class="cov10" title="109020">{
                        return metric, true
                }</span>
                <span class="cov3" title="14">if _, isDuplicate := seen[distribution.Key()]; isDuplicate </span><span class="cov1" title="2">{
                        log.Warnf(
                                "duplicate histogram series name=%s source=%s tags=%v",
                                distribution.Name(), distribution.Source, distribution.Tags(),
                        )
                        DuplicateHistogramCounter(distribution.Name()).Inc(1)
                        return nil, false
                }</span>
                <span class="cov2" title="12">rate := distribution.Rate(rc.prevDistributions[distribution.Key()])
                rc.prevDistributions[distribution.Key()] = distribution.Clone()
                seen[distribution.Key()] = struct{}{}
                return rate, rate != nil</span>
        }, batch.Metrics)
        <span class="cov2" title="9">return batch, nil</span>
}

func filterMapInPlace(f func(wf.Metric) (wf.Metric, bool), es []wf.Metric) []wf.Metric <span class="cov2" title="9">{
        newEs := es[:0]
        for _, e := range es </span><span class="cov3" title="14">{
                newE, include := f(e)
                if include </span><span class="cov2" title="5">{
                        newEs = append(newEs, newE)
                }</span>
        }
        <span class="cov2" title="9">for i := range es[len(newEs):] </span><span class="cov2" title="9">{
                es[len(newEs)+i] = nil
        }</span>
        <span class="cov2" title="9">return newEs</span>
}

func NewDistributionRateCalculator() *DistributionRateCalculator <span class="cov2" title="4">{
        return &amp;DistributionRateCalculator{prevDistributions: map[wf.DistributionHash]*wf.Distribution{}}
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "fmt"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

func aggregate(src, dst *metrics.Set, metricsToAggregate []string) error <span class="cov8" title="288">{
        for _, metricName := range metricsToAggregate </span><span class="cov10" title="864">{
                metricValue, found := src.Values[metricName]
                if !found </span><span class="cov4" title="20">{
                        continue</span>
                }
                <span class="cov9" title="844">aggregatedValue, found := dst.Values[metricName]
                if found </span><span class="cov9" title="705">{
                        if aggregatedValue.ValueType != metricValue.ValueType </span><span class="cov0" title="0">{
                                return fmt.Errorf("aggregator: type not supported in %s", metricName)
                        }</span>

                        <span class="cov9" title="705">if aggregatedValue.ValueType == metrics.ValueInt64 </span><span class="cov9" title="705">{
                                aggregatedValue.IntValue += metricValue.IntValue
                        }</span> else<span class="cov0" title="0"> if aggregatedValue.ValueType == metrics.ValueFloat </span><span class="cov0" title="0">{
                                aggregatedValue.FloatValue += metricValue.FloatValue
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("aggregator: type not supported in %s", metricName)
                        }</span>
                } else<span class="cov7" title="139"> {
                        aggregatedValue = metricValue
                }</span>
                <span class="cov9" title="844">dst.Values[metricName] = aggregatedValue</span>
        }
        <span class="cov8" title="288">return nil</span>
}

// aggregates the count of pods or containers by node, namespace and cluster.
// If the source already has aggregated counts (by namespace for example), they are used to get the counts per cluster.
// If the source does not have any counts, we increment the dest count by 1 assuming this method is invoked once per pod/container.
func aggregateCount(src, dst *metrics.Set, metricName string) <span class="cov8" title="288">{
        srcCount := int64(0)
        if count, found := src.Values[metricName]; found </span><span class="cov3" title="9">{
                srcCount += count.IntValue
        }</span> else<span class="cov3" title="9"> {
                srcCount = 1
        }</span>

        <span class="cov8" title="288">dstCount, found := dst.Values[metricName]
        if found </span><span class="cov3" title="5">{
                dstCount.IntValue += srcCount
        }</span> else<span class="cov6" title="48"> {
                dstCount = metrics.Value{
                        IntValue: srcCount,
                }
        }</span>
        <span class="cov8" title="288">dst.Values[metricName] = dstCount</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

func NewNamespaceAggregator(metricsToAggregate []string) metrics.Processor <span class="cov1" title="1">{
        return NewSumCountAggregator("namespace", []SumCountAggregateSpec{
                {
                        ResourceSumMetrics:  metricsToAggregate,
                        ResourceCountMetric: metrics.MetricPodCount.Name,
                        IsPartOfGroup:       isAggregatablePod,
                        Group:               namespaceGroup,
                },
                {
                        ResourceSumMetrics:  []string{},
                        ResourceCountMetric: metrics.MetricPodContainerCount.Name,
                        IsPartOfGroup:       isAggregatablePodContainer,
                        Group:               namespaceGroup,
                },
        })
}</span>

func namespaceGroup(batch *metrics.Batch, resourceKey metrics.ResourceKey, resourceSet *metrics.Set) (metrics.ResourceKey, *metrics.Set) <span class="cov3" title="2">{
        namespaceName, found := resourceSet.Labels[metrics.LabelNamespaceName.Key]
        if !found </span><span class="cov0" title="0">{
                log.Errorf("no namespace info in pod %s: %v", resourceKey, resourceSet.Labels)
                return "", nil
        }</span>
        <span class="cov3" title="2">namespaceKey := metrics.NamespaceKey(namespaceName)
        namespaceSet := batch.Sets[namespaceKey]
        if namespaceSet == nil </span><span class="cov10" title="16">{
                namespaceSet = namespaceMetricSet(namespaceName, resourceSet.Labels[metrics.LabelPodNamespaceUID.Key])
        }</span>
        <span class="cov3" title="2">return namespaceKey, namespaceSet</span>
}

func namespaceMetricSet(namespaceName, uid string) *metrics.Set <span class="cov10" title="16">{
        return &amp;metrics.Set{
                Values: make(map[string]metrics.Value),
                Labels: map[string]string{
                        metrics.LabelMetricSetType.Key:   metrics.MetricSetTypeNamespace,
                        metrics.LabelNamespaceName.Key:   namespaceName,
                        metrics.LabelPodNamespaceUID.Key: uid,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        kube_api "k8s.io/api/core/v1"
        kube_client "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
)

type NamespaceBasedEnricher struct {
        store cache.Store
}

func (nbe *NamespaceBasedEnricher) Name() string <span class="cov0" title="0">{
        return "namespace_based_enricher"
}</span>

func (nbe *NamespaceBasedEnricher) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov3" title="4">{
        for _, ms := range batch.Sets </span><span class="cov10" title="140">{
                nbe.addNamespaceInfo(ms)
        }</span>
        <span class="cov3" title="4">return batch, nil</span>
}

// Adds UID to all namespaced elements.
func (nbe *NamespaceBasedEnricher) addNamespaceInfo(metricSet *metrics.Set) <span class="cov10" title="140">{
        metricSetType, found := metricSet.Labels[metrics.LabelMetricSetType.Key]
        if !found </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov10" title="140">if metricSetType != metrics.MetricSetTypePodContainer &amp;&amp;
                metricSetType != metrics.MetricSetTypePod &amp;&amp;
                metricSetType != metrics.MetricSetTypeNamespace </span><span class="cov5" title="12">{
                return
        }</span>

        <span class="cov9" title="128">namespaceName, found := metricSet.Labels[metrics.LabelNamespaceName.Key]
        if !found </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov9" title="128">nsObj, exists, err := nbe.store.GetByKey(namespaceName)
        if exists &amp;&amp; err == nil </span><span class="cov9" title="128">{
                namespace, ok := nsObj.(*kube_api.Namespace)
                if ok </span><span class="cov9" title="128">{
                        metricSet.Labels[metrics.LabelPodNamespaceUID.Key] = string(namespace.UID)
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("Wrong namespace store content")
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Warningf("Failed to get namespace %s: %v", namespaceName, err)
        }</span> else<span class="cov0" title="0"> if !exists </span><span class="cov0" title="0">{
                log.Warningf("Namespace doesn't exist: %s", namespaceName)
        }</span>
}

func NewNamespaceBasedEnricher(kubeClient *kube_client.Clientset) (*NamespaceBasedEnricher, error) <span class="cov1" title="1">{
        return &amp;NamespaceBasedEnricher{
                store: util.GetNamespaceStore(kubeClient),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

func NewNodeAggregator(metricsToAggregate []string) metrics.Processor <span class="cov1" title="1">{
        return NewSumCountAggregator("node", []SumCountAggregateSpec{
                {
                        ResourceSumMetrics:  metricsToAggregate,
                        ResourceCountMetric: metrics.MetricPodCount.Name,
                        IsPartOfGroup:       isAggregatablePod,
                        Group:               nodeGroup,
                },
                {
                        ResourceSumMetrics:  []string{},
                        ResourceCountMetric: metrics.MetricPodContainerCount.Name,
                        IsPartOfGroup:       isAggregatablePodContainer,
                        Group:               nodeGroup,
                },
        })
}</span>

func nodeGroup(batch *metrics.Batch, resourceKey metrics.ResourceKey, resourceSet *metrics.Set) (metrics.ResourceKey, *metrics.Set) <span class="cov10" title="2">{
        nodeName := resourceSet.Labels[metrics.LabelNodename.Key]
        if nodeName == "" </span><span class="cov0" title="0">{
                log.Errorf("no node info for resource %s: %v", resourceKey, resourceSet.Labels)
                return "", nil
        }</span>
        <span class="cov10" title="2">nodeKey := metrics.NodeKey(nodeName)
        return nodeKey, batch.Sets[nodeKey]</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        kube_api "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        kube_client "k8s.io/client-go/kubernetes"
        v1listers "k8s.io/client-go/listers/core/v1"
        "k8s.io/client-go/tools/cache"
)

type NodeAutoscalingEnricher struct {
        nodeLister  v1listers.NodeLister
        reflector   *cache.Reflector
        labelCopier *util.LabelCopier
}

func (nae *NodeAutoscalingEnricher) Name() string <span class="cov0" title="0">{
        return "node_autoscaling_enricher"
}</span>

func (nae *NodeAutoscalingEnricher) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov4" title="4">{
        nodes, err := nae.nodeLister.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="4">for _, node := range nodes </span><span class="cov4" title="4">{
                if metricSet, found := batch.Sets[metrics.NodeKey(node.Name)]; found </span><span class="cov4" title="4">{
                        nae.labelCopier.Copy(node.Labels, metricSet.Labels)
                        metricSet.Labels[metrics.LabelNodeRole.Key] = util.GetNodeRole(node)
                        capacityCpu, _ := node.Status.Capacity[kube_api.ResourceCPU]
                        capacityMem, _ := node.Status.Capacity[kube_api.ResourceMemory]
                        capacityEphemeralStorage, storageExist := node.Status.Capacity[kube_api.ResourceEphemeralStorage]
                        allocatableCpu, _ := node.Status.Allocatable[kube_api.ResourceCPU]
                        allocatableMem, _ := node.Status.Allocatable[kube_api.ResourceMemory]
                        allocatableEphemeralStorage, allocatableStorageExist := node.Status.Allocatable[kube_api.ResourceEphemeralStorage]

                        cpuRequested := getInt(metricSet, &amp;metrics.MetricCpuRequest)
                        cpuUsed := getInt(metricSet, &amp;metrics.MetricCpuUsageRate)
                        memRequested := getInt(metricSet, &amp;metrics.MetricMemoryRequest)
                        memWorkingSet := getInt(metricSet, &amp;metrics.MetricMemoryWorkingSet)
                        epheRequested := getInt(metricSet, &amp;metrics.MetricEphemeralStorageRequest)
                        epheUsed := getInt(metricSet, &amp;metrics.MetricEphemeralStorageUsage)

                        if allocatableCpu.MilliValue() != 0 </span><span class="cov4" title="4">{
                                setFloat(metricSet, &amp;metrics.MetricNodeCpuUtilization, float64(cpuUsed)/float64(allocatableCpu.MilliValue()))
                                setFloat(metricSet, &amp;metrics.MetricNodeCpuReservation, float64(cpuRequested)/float64(allocatableCpu.MilliValue()))
                        }</span>
                        <span class="cov4" title="4">setFloat(metricSet, &amp;metrics.MetricNodeCpuCapacity, float64(capacityCpu.MilliValue()))
                        setFloat(metricSet, &amp;metrics.MetricNodeCpuAllocatable, float64(allocatableCpu.MilliValue()))

                        if allocatableMem.Value() != 0 </span><span class="cov4" title="4">{
                                setFloat(metricSet, &amp;metrics.MetricNodeMemoryUtilization, float64(memWorkingSet)/float64(allocatableMem.Value()))
                                setFloat(metricSet, &amp;metrics.MetricNodeMemoryReservation, float64(memRequested)/float64(allocatableMem.Value()))
                        }</span>
                        <span class="cov4" title="4">setFloat(metricSet, &amp;metrics.MetricNodeMemoryCapacity, float64(capacityMem.Value()))
                        setFloat(metricSet, &amp;metrics.MetricNodeMemoryAllocatable, float64(allocatableMem.Value()))

                        if storageExist &amp;&amp; allocatableStorageExist </span><span class="cov4" title="4">{
                                setFloat(metricSet, &amp;metrics.MetricNodeEphemeralStorageCapacity, float64(capacityEphemeralStorage.Value()))
                                setFloat(metricSet, &amp;metrics.MetricNodeEphemeralStorageAllocatable, float64(allocatableEphemeralStorage.Value()))
                                if allocatableEphemeralStorage.Value() != 0 </span><span class="cov4" title="4">{
                                        setFloat(metricSet, &amp;metrics.MetricNodeEphemeralStorageUtilization, float64(epheUsed)/float64(allocatableEphemeralStorage.Value()))
                                        setFloat(metricSet, &amp;metrics.MetricNodeEphemeralStorageReservation, float64(epheRequested)/float64(allocatableEphemeralStorage.Value()))
                                }</span>
                        }
                }
        }
        <span class="cov4" title="4">return batch, nil</span>
}

func getInt(metricSet *metrics.Set, metric *metrics.Metric) int64 <span class="cov8" title="24">{
        if value, found := metricSet.Values[metric.MetricDescriptor.Name]; found </span><span class="cov8" title="23">{
                return value.IntValue
        }</span>
        <span class="cov1" title="1">return 0</span>
}

func setFloat(metricSet *metrics.Set, metric *metrics.Metric, value float64) <span class="cov10" title="48">{
        metricSet.Values[metric.MetricDescriptor.Name] = metrics.Value{
                ValueType:  metrics.ValueFloat,
                FloatValue: value,
        }
}</span>

func NewNodeAutoscalingEnricher(kubeClient *kube_client.Clientset, labelCopier *util.LabelCopier) (*NodeAutoscalingEnricher, error) <span class="cov1" title="1">{
        // watch nodes
        nodeLister, reflector, _ := util.GetNodeLister(kubeClient)

        return &amp;NodeAutoscalingEnricher{
                nodeLister:  nodeLister,
                reflector:   reflector,
                labelCopier: labelCopier,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "fmt"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

var LabelsToPopulate = []metrics.LabelDescriptor{
        metrics.LabelPodId,
        metrics.LabelPodName,
        metrics.LabelNamespaceName,
        metrics.LabelPodNamespaceUID,
        metrics.LabelHostname,
        metrics.LabelHostID,
}

type PodAggregator struct {
        skippedMetrics map[string]struct{}
}

func (aggregator *PodAggregator) Name() string <span class="cov0" title="0">{
        return "pod_aggregator"
}</span>

func (aggregator *PodAggregator) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov2" title="4">{
        newPods := make(map[metrics.ResourceKey]*metrics.Set)

        // If pod already has pod-level metrics, it no longer needs to aggregates its container's metrics.
        requireAggregate := make(map[string]bool)
        for key, metricSet := range batch.Sets </span><span class="cov7" title="140">{
                if metricSetType, found := metricSet.Labels[metrics.LabelMetricSetType.Key]; !found || metricSetType != metrics.MetricSetTypePodContainer </span><span class="cov6" title="76">{
                        continue</span>
                }

                // Aggregating containers
                <span class="cov3" title="9">podName, found := metricSet.Labels[metrics.LabelPodName.Key]
                ns, found2 := metricSet.Labels[metrics.LabelNamespaceName.Key]
                if !found || !found2 </span><span class="cov0" title="0">{
                        log.Errorf("No namespace and/or pod info in container %s: %v", key, metricSet.Labels)
                        continue</span>
                }

                <span class="cov3" title="9">podKey := metrics.PodKey(ns, podName)
                pod, found := batch.Sets[podKey]
                if !found </span><span class="cov1" title="2">{
                        pod, found = newPods[podKey]
                        if !found </span><span class="cov1" title="1">{
                                log.Infof("Pod not found adding %s", podKey)
                                pod = aggregator.podMetricSet(metricSet.Labels)
                                newPods[podKey] = pod
                        }</span>
                }

                <span class="cov3" title="9">for metricName, metricValue := range metricSet.Values </span><span class="cov6" title="45">{
                        if _, found := aggregator.skippedMetrics[metricName]; found </span><span class="cov8" title="256">{
                                continue</span>
                        }

                        <span class="cov10" title="909">aggregatedValue, found := pod.Values[metricName]
                        if !found </span><span class="cov9" title="451">{
                                requireAggregate[podKey.String()+metricName] = true
                                aggregatedValue = metricValue
                        }</span> else<span class="cov9" title="458"> {
                                if requireAggregate[podKey.String()+metricName] </span><span class="cov4" title="19">{
                                        if aggregatedValue.ValueType != metricValue.ValueType </span><span class="cov0" title="0">{
                                                log.Errorf("PodAggregator: inconsistent type in %s", metricName)
                                                continue</span>
                                        }

                                        <span class="cov4" title="19">switch aggregatedValue.ValueType </span>{
                                        case metrics.ValueInt64:<span class="cov4" title="19">
                                                aggregatedValue.IntValue += metricValue.IntValue</span>
                                        case metrics.ValueFloat:<span class="cov0" title="0">
                                                aggregatedValue.FloatValue += metricValue.FloatValue</span>
                                        default:<span class="cov0" title="0">
                                                return nil, fmt.Errorf("PodAggregator: type not supported in %s", metricName)</span>
                                        }
                                }
                        }

                        <span class="cov10" title="909">pod.Values[metricName] = aggregatedValue</span>
                }
        }
        <span class="cov2" title="4">for key, val := range newPods </span><span class="cov1" title="1">{
                batch.Sets[key] = val
        }</span>
        <span class="cov2" title="4">return batch, nil</span>
}

func (aggregator *PodAggregator) podMetricSet(labels map[string]string) *metrics.Set <span class="cov1" title="1">{
        newLabels := map[string]string{
                metrics.LabelMetricSetType.Key: metrics.MetricSetTypePod,
        }
        for _, l := range LabelsToPopulate </span><span class="cov3" title="6">{
                if val, ok := labels[l.Key]; ok </span><span class="cov1" title="2">{
                        newLabels[l.Key] = val
                }</span>
        }
        <span class="cov1" title="1">return &amp;metrics.Set{
                Values: make(map[string]metrics.Value),
                Labels: newLabels,
        }</span>
}

func NewPodAggregator() *PodAggregator <span class="cov1" title="1">{
        skipped := make(map[string]struct{})
        for _, metric := range metrics.StandardMetrics </span><span class="cov4" title="14">{
                if metric.MetricDescriptor.Type == metrics.Cumulative ||
                        metric.MetricDescriptor.Type == metrics.Delta </span><span class="cov3" title="8">{
                        skipped[metric.MetricDescriptor.Name] = struct{}{}
                }</span>
        }
        <span class="cov1" title="1">return &amp;PodAggregator{
                skippedMetrics: skipped,
        }</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "fmt"
        "time"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        kube_api "k8s.io/api/core/v1"
        v1listers "k8s.io/client-go/listers/core/v1"
)

type PodBasedEnricher struct {
        podLister          v1listers.PodLister
        labelCopier        *util.LabelCopier
        collectionInterval time.Duration
}

func (pbe *PodBasedEnricher) Name() string <span class="cov0" title="0">{
        return "pod_based_enricher"
}</span>

func (pbe *PodBasedEnricher) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov3" title="4">{
        newMs := make(map[metrics.ResourceKey]*metrics.Set, len(batch.Sets))
        for k, v := range batch.Sets </span><span class="cov10" title="140">{
                switch v.Labels[metrics.LabelMetricSetType.Key] </span>{
                case metrics.MetricSetTypePod:<span class="cov8" title="64">
                        namespace := v.Labels[metrics.LabelNamespaceName.Key]
                        podName := v.Labels[metrics.LabelPodName.Key]
                        pod, err := pbe.getPod(namespace, podName)
                        if err != nil </span><span class="cov1" title="1">{
                                delete(batch.Sets, k)
                                log.Debugf("Failed to get pod %s from cache: %v", metrics.PodKey(namespace, podName), err)
                                continue</span>
                        }
                        <span class="cov8" title="64">pbe.addPodInfo(v, pod, batch, newMs)</span>
                case metrics.MetricSetTypePodContainer:<span class="cov4" title="8">
                        namespace := v.Labels[metrics.LabelNamespaceName.Key]
                        podName := v.Labels[metrics.LabelPodName.Key]
                        pod, err := pbe.getPod(namespace, podName)
                        if err != nil </span><span class="cov2" title="2">{
                                delete(batch.Sets, k)
                                log.Debugf("Failed to get pod %s from cache: %v", metrics.PodKey(namespace, podName), err)
                                continue</span>
                        }
                        <span class="cov8" title="64">pbe.addContainerInfo(k, v, pod, batch, newMs)</span>
                }
        }
        <span class="cov3" title="4">for k, v := range newMs </span><span class="cov5" title="12">{
                batch.Sets[k] = v
        }</span>
        <span class="cov3" title="4">return batch, nil</span>
}

func (pbe *PodBasedEnricher) getPod(namespace, name string) (*kube_api.Pod, error) <span class="cov5" title="14">{
        pod, err := pbe.podLister.Pods(namespace).Get(name)
        if err != nil </span><span class="cov3" title="3">{
                return nil, err
        }</span>
        <span class="cov9" title="128">if pod == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find pod definition")
        }</span>
        <span class="cov9" title="128">return pod, nil</span>
}

func (pbe *PodBasedEnricher) addContainerInfo(key metrics.ResourceKey, containerMs *metrics.Set, pod *kube_api.Pod, batch *metrics.Batch, newMs map[metrics.ResourceKey]*metrics.Set) <span class="cov8" title="64">{
        for _, container := range pod.Spec.Containers </span><span class="cov8" title="64">{
                if key == metrics.PodContainerKey(pod.Namespace, pod.Name, container.Name) </span><span class="cov8" title="64">{
                        updateContainerResourcesAndLimits(containerMs, container)
                        if _, ok := containerMs.Labels[metrics.LabelContainerBaseImage.Key]; !ok </span><span class="cov8" title="64">{
                                containerMs.Labels[metrics.LabelContainerBaseImage.Key] = container.Image
                        }</span>
                        <span class="cov8" title="64">break</span>
                }
        }

        <span class="cov8" title="64">for _, containerStatus := range pod.Status.ContainerStatuses </span><span class="cov8" title="64">{
                if key == metrics.PodContainerKey(pod.Namespace, pod.Name, containerStatus.Name) </span><span class="cov8" title="64">{
                        containerMs.Values[metrics.MetricRestartCount.Name] = intValue(int64(containerStatus.RestartCount))
                        if !pod.Status.StartTime.IsZero() </span><span class="cov8" title="64">{
                                containerMs.EntityCreateTime = pod.Status.StartTime.Time
                        }</span>
                        <span class="cov8" title="64">pbe.addContainerStatus(batch.Timestamp, containerMs, &amp;metrics.MetricContainerStatus, containerStatus)
                        break</span>
                }
        }

        <span class="cov8" title="64">containerMs.Labels[metrics.LabelPodId.Key] = string(pod.UID)
        pbe.labelCopier.Copy(pod.Labels, containerMs.Labels)

        namespace := containerMs.Labels[metrics.LabelNamespaceName.Key]
        podName := containerMs.Labels[metrics.LabelPodName.Key]

        podKey := metrics.PodKey(namespace, podName)
        _, oldfound := batch.Sets[podKey]
        if !oldfound </span><span class="cov4" title="6">{
                _, newfound := newMs[podKey]
                if !newfound </span><span class="cov4" title="6">{
                        log.Debugf("Pod %s not found, creating a stub", podKey)
                        podMs := &amp;metrics.Set{
                                Values: make(map[string]metrics.Value),
                                Labels: map[string]string{
                                        metrics.LabelMetricSetType.Key: metrics.MetricSetTypePod,
                                        metrics.LabelNamespaceName.Key: namespace,
                                        metrics.LabelPodName.Key:       podName,
                                        metrics.LabelNodename.Key:      containerMs.Labels[metrics.LabelNodename.Key],
                                        metrics.LabelHostname.Key:      containerMs.Labels[metrics.LabelHostname.Key],
                                        metrics.LabelHostID.Key:        containerMs.Labels[metrics.LabelHostID.Key],
                                },
                        }
                        if !pod.Status.StartTime.IsZero() </span><span class="cov0" title="0">{
                                podMs.EntityCreateTime = pod.Status.StartTime.Time
                        }</span>
                        <span class="cov4" title="6">newMs[podKey] = podMs
                        pbe.addPodInfo(podMs, pod, batch, newMs)</span>
                }
        }
}

func (pbe *PodBasedEnricher) addPodInfo(podMs *metrics.Set, pod *kube_api.Pod, batch *metrics.Batch, newMs map[metrics.ResourceKey]*metrics.Set) <span class="cov8" title="64">{
        // Pod based enricher only adds metrics for pods that are in running state
        // Pods that are in other states will be processed by kstate/non_running_pods
        if pod.Status.Phase != kube_api.PodRunning </span><span class="cov4" title="7">{
                return
        }</span>
        // Add UID and create time to pod
        <span class="cov8" title="64">podMs.Labels[metrics.LabelPodId.Key] = string(pod.UID)
        if !pod.Status.StartTime.IsZero() </span><span class="cov8" title="64">{
                podMs.EntityCreateTime = pod.Status.StartTime.Time
        }</span>
        <span class="cov8" title="64">pbe.labelCopier.Copy(pod.Labels, podMs.Labels)

        // Add pod phase
        addLabeledIntMetric(podMs, &amp;metrics.MetricPodPhase, map[string]string{"phase": string(pod.Status.Phase)}, util.ConvertPodPhase(pod.Status.Phase))

        // Add cpu/mem requests and limits to containers
        for _, container := range pod.Spec.Containers </span><span class="cov4" title="8">{
                containerKey := metrics.PodContainerKey(pod.Namespace, pod.Name, container.Name)
                if _, found := batch.Sets[containerKey]; found </span><span class="cov8" title="64">{
                        continue</span>
                }
                <span class="cov4" title="6">if _, found := newMs[containerKey]; found </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="6">log.Debugf("Container %s not found, creating a stub", containerKey)
                containerMs := &amp;metrics.Set{
                        Values: make(map[string]metrics.Value),
                        Labels: map[string]string{
                                metrics.LabelMetricSetType.Key:      metrics.MetricSetTypePodContainer,
                                metrics.LabelNamespaceName.Key:      pod.Namespace,
                                metrics.LabelPodName.Key:            pod.Name,
                                metrics.LabelContainerName.Key:      container.Name,
                                metrics.LabelContainerBaseImage.Key: container.Image,
                                metrics.LabelPodId.Key:              string(pod.UID),
                                metrics.LabelNodename.Key:           podMs.Labels[metrics.LabelNodename.Key],
                                metrics.LabelHostname.Key:           podMs.Labels[metrics.LabelHostname.Key],
                                metrics.LabelHostID.Key:             podMs.Labels[metrics.LabelHostID.Key],
                        },
                        EntityCreateTime: podMs.CollectionStartTime,
                }
                pbe.labelCopier.Copy(pod.Labels, containerMs.Labels)
                updateContainerResourcesAndLimits(containerMs, container)
                newMs[containerKey] = containerMs</span>
        }
        <span class="cov8" title="64">pbe.updateContainerStatus(newMs, pod, pod.Status.ContainerStatuses, batch.Timestamp)</span>
}

func updateContainerResourcesAndLimits(metricSet *metrics.Set, container kube_api.Container) <span class="cov8" title="64">{
        requests := container.Resources.Requests

        for key, val := range container.Resources.Requests </span><span class="cov8" title="68">{
                metric, found := metrics.ResourceRequestMetrics[key]
                // Inserts a metric to metrics.ResourceRequestMetrics if there is no
                // existing one for the given resource. The name of this metric is
                // ResourceName/request where ResourceName is the name of the resource
                // requested in container resource requests.
                if !found </span><span class="cov1" title="1">{
                        metric = metrics.Metric{
                                MetricDescriptor: metrics.MetricDescriptor{
                                        Name:        string(key) + "/request",
                                        Description: string(key) + " resource request. This metric is Kubernetes specific.",
                                        Type:        metrics.Gauge,
                                        ValueType:   metrics.ValueInt64,
                                        Units:       metrics.Count,
                                },
                        }
                        metrics.ResourceRequestMetrics[key] = metric
                }</span>
                <span class="cov8" title="68">if key == kube_api.ResourceCPU </span><span class="cov7" title="40">{
                        metricSet.Values[metric.Name] = intValue(val.MilliValue())
                }</span> else<span class="cov7" title="28"> {
                        metricSet.Values[metric.Name] = intValue(val.Value())
                }</span>
        }

        // For primary resources like cpu and memory, explicitly sets their request resource
        // metric to zero if they are not requested.
        <span class="cov8" title="64">if _, found := requests[kube_api.ResourceCPU]; !found </span><span class="cov6" title="24">{
                metricSet.Values[metrics.MetricCpuRequest.Name] = intValue(0)
        }</span>
        <span class="cov8" title="64">if _, found := requests[kube_api.ResourceMemory]; !found </span><span class="cov7" title="36">{
                metricSet.Values[metrics.MetricMemoryRequest.Name] = intValue(0)
        }</span>
        <span class="cov8" title="64">if _, found := requests[kube_api.ResourceEphemeralStorage]; !found </span><span class="cov8" title="64">{
                metricSet.Values[metrics.MetricEphemeralStorageRequest.Name] = intValue(0)
        }</span>

        <span class="cov8" title="64">limits := container.Resources.Limits
        if val, found := limits[kube_api.ResourceCPU]; found </span><span class="cov3" title="4">{
                metricSet.Values[metrics.MetricCpuLimit.Name] = intValue(val.MilliValue())
        }</span> else<span class="cov4" title="8"> {
                metricSet.Values[metrics.MetricCpuLimit.Name] = intValue(0)
        }</span>
        <span class="cov8" title="64">if val, found := limits[kube_api.ResourceMemory]; found </span><span class="cov3" title="4">{
                metricSet.Values[metrics.MetricMemoryLimit.Name] = intValue(val.Value())
        }</span> else<span class="cov4" title="8"> {
                metricSet.Values[metrics.MetricMemoryLimit.Name] = intValue(0)
        }</span>
        <span class="cov8" title="64">if val, found := limits[kube_api.ResourceEphemeralStorage]; found </span><span class="cov3" title="4">{
                metricSet.Values[metrics.MetricEphemeralStorageLimit.Name] = intValue(val.Value())
        }</span> else<span class="cov4" title="8"> {
                metricSet.Values[metrics.MetricEphemeralStorageLimit.Name] = intValue(0)
        }</span>
}

func (pbe *PodBasedEnricher) addContainerStatus(collectionTime time.Time, containerMs *metrics.Set, metric *metrics.Metric, status kube_api.ContainerStatus) <span class="cov8" title="64">{
        labels := make(map[string]string, 2)

        containerStateInfo := pbe.findContainerState(collectionTime, status)
        containerStateInfo.AddMetricTags(labels)

        addLabeledIntMetric(containerMs, metric, labels, int64(containerStateInfo.Value))
}</span>

func (pbe *PodBasedEnricher) findContainerState(collectionTime time.Time, status kube_api.ContainerStatus) util.ContainerStateInfo <span class="cov8" title="64">{
        if status.LastTerminationState.Terminated == nil </span><span class="cov8" title="64">{
                return util.NewContainerStateInfo(status.State)
        }</span>

        <span class="cov2" title="2">lastTerminationTime := status.LastTerminationState.Terminated.FinishedAt.Time
        lastCollectionTime := collectionTime.Add(-1 * pbe.collectionInterval)
        if lastCollectionTime.After(lastTerminationTime) </span><span class="cov1" title="1">{
                return util.NewContainerStateInfo(status.State)
        }</span>

        <span class="cov1" title="1">return util.NewContainerStateInfo(status.LastTerminationState)</span>
}

func (pbe *PodBasedEnricher) updateContainerStatus(metricSets map[metrics.ResourceKey]*metrics.Set, pod *kube_api.Pod, statuses []kube_api.ContainerStatus, collectionTime time.Time) <span class="cov8" title="64">{
        if len(statuses) == 0 </span><span class="cov3" title="4">{
                return
        }</span>
        <span class="cov8" title="64">for _, status := range statuses </span><span class="cov8" title="64">{
                containerKey := metrics.PodContainerKey(pod.Namespace, pod.Name, status.Name)
                containerMs, found := metricSets[containerKey]
                if !found </span><span class="cov8" title="64">{
                        log.Debugf("Container key %s not found", containerKey)
                        continue</span>
                }
                <span class="cov0" title="0">pbe.addContainerStatus(collectionTime, containerMs, &amp;metrics.MetricContainerStatus, status)</span>
        }
}

// addLabeledIntMetric is a convenience method for adding the labeled metric and value to the metric set.
func addLabeledIntMetric(ms *metrics.Set, metric *metrics.Metric, labels map[string]string, value int64) <span class="cov4" title="8">{
        val := metrics.LabeledValue{
                Name:   metric.Name,
                Labels: labels,
                Value: metrics.Value{
                        ValueType: metrics.ValueInt64,
                        IntValue:  value,
                },
        }
        ms.LabeledValues = append(ms.LabeledValues, val)
}</span>

func intValue(value int64) metrics.Value <span class="cov8" title="80">{
        return metrics.Value{
                IntValue:  value,
                ValueType: metrics.ValueInt64,
        }
}</span>

func NewPodBasedEnricher(podLister v1listers.PodLister, labelCopier *util.LabelCopier, collectionInterval time.Duration) *PodBasedEnricher <span class="cov5" title="11">{
        return &amp;PodBasedEnricher{
                podLister:          podLister,
                labelCopier:        labelCopier,
                collectionInterval: collectionInterval,
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package processors

import (
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"

        log "github.com/sirupsen/logrus"
)

type RateCalculator struct {
        rateMetricsMapping map[string]metrics.Metric

        lock               sync.Mutex
        previousMetricSets map[metrics.ResourceKey]*metrics.Set
        cachePruneInterval time.Duration
        lastPruneTime      time.Time
}

func (rc *RateCalculator) Name() string <span class="cov0" title="0">{
        return "rate calculator"
}</span>

func (rc *RateCalculator) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov2" title="4">{
        rc.lock.Lock()
        defer rc.lock.Unlock()

        for key, newMs := range batch.Sets </span><span class="cov1" title="2">{
                oldMs, found := rc.previousMetricSets[key]
                if !found </span><span class="cov5" title="35">{
                        log.Debugf("Skipping rates for '%s' - no previous batch found", key)
                        rc.previousMetricSets[key] = newMs
                        continue</span>
                }

                <span class="cov6" title="105">if !newMs.ScrapeTime.After(oldMs.ScrapeTime) </span><span class="cov1" title="2">{
                        // New must be strictly after old.
                        log.Debugf("Skipping rates for '%s' - new batch (%s) was not scraped strictly after old batch (%s)", key, newMs.ScrapeTime, oldMs.ScrapeTime)
                        continue</span>
                }
                <span class="cov6" title="103">if !newMs.CollectionStartTime.Equal(oldMs.CollectionStartTime) </span><span class="cov0" title="0">{
                        log.Debugf("Skipping rates for '%s' - different collection start time (restart) new:%v  old:%v", key, newMs.CollectionStartTime, oldMs.CollectionStartTime)
                        rc.previousMetricSets[key] = newMs
                        continue</span>
                }

                <span class="cov6" title="103">var metricValNew, metricValOld metrics.Value
                var foundNew, foundOld bool

                for metricName, targetMetric := range rc.rateMetricsMapping </span><span class="cov8" title="927">{
                        if metricName == metrics.MetricDiskIORead.MetricDescriptor.Name || metricName == metrics.MetricDiskIOWrite.MetricDescriptor.Name </span><span class="cov7" title="206">{
                                for _, itemNew := range newMs.LabeledValues </span><span class="cov10" title="2740">{
                                        foundNew, foundOld = false, false
                                        if itemNew.Name == metricName </span><span class="cov0" title="0">{
                                                metricValNew, foundNew = itemNew.Value, true
                                                for _, itemOld := range oldMs.LabeledValues </span><span class="cov0" title="0">{
                                                        // Fix negative value on "disk/io_read_bytes_rate" and "disk/io_write_bytes_rate" when multiple disk devices are available
                                                        if itemOld.Name == metricName &amp;&amp; itemOld.Labels[metrics.LabelResourceID.Key] == itemNew.Labels[metrics.LabelResourceID.Key] </span><span class="cov0" title="0">{
                                                                metricValOld, foundOld = itemOld.Value, true
                                                                break</span>
                                                        }
                                                }
                                        }

                                        <span class="cov10" title="2740">if foundNew &amp;&amp; foundOld </span><span class="cov0" title="0">{
                                                if targetMetric.MetricDescriptor.ValueType == metrics.ValueFloat </span><span class="cov0" title="0">{
                                                        newVal := 1e9 * float64(metricValNew.IntValue-metricValOld.IntValue) /
                                                                float64(newMs.ScrapeTime.UnixNano()-oldMs.ScrapeTime.UnixNano())

                                                        newMs.LabeledValues = append(newMs.LabeledValues, metrics.LabeledValue{
                                                                Name:   targetMetric.MetricDescriptor.Name,
                                                                Labels: itemNew.Labels,
                                                                Value: metrics.Value{
                                                                        ValueType:  metrics.ValueFloat,
                                                                        FloatValue: newVal,
                                                                },
                                                        })
                                                }</span>
                                        } else<span class="cov10" title="2740"> if foundNew &amp;&amp; !foundOld || !foundNew &amp;&amp; foundOld </span><span class="cov0" title="0">{
                                                log.Debugf("Skipping rates for '%s' in '%s': metric not found in one of old (%v) or new (%v)", metricName, key, foundOld, foundNew)
                                        }</span>
                                }
                        } else<span class="cov8" title="721"> {
                                metricValNew, foundNew = newMs.Values[metricName]
                                metricValOld, foundOld = oldMs.Values[metricName]

                                if foundNew &amp;&amp; foundOld &amp;&amp; metricName == metrics.MetricCpuUsage.MetricDescriptor.Name </span><span class="cov6" title="103">{
                                        // cpu/usage values are in nanoseconds; we want to have it in millicores (that's why constant 1000 is here).
                                        newVal := 1000 * (metricValNew.IntValue - metricValOld.IntValue) /
                                                (newMs.ScrapeTime.UnixNano() - oldMs.ScrapeTime.UnixNano())

                                        newMs.Values[targetMetric.MetricDescriptor.Name] = metrics.Value{
                                                ValueType: metrics.ValueInt64,
                                                IntValue:  newVal,
                                        }

                                }</span> else<span class="cov8" title="618"> if foundNew &amp;&amp; foundOld &amp;&amp; targetMetric.MetricDescriptor.ValueType == metrics.ValueFloat </span><span class="cov7" title="406">{
                                        newVal := 1e9 * float64(metricValNew.IntValue-metricValOld.IntValue) /
                                                float64(newMs.ScrapeTime.UnixNano()-oldMs.ScrapeTime.UnixNano())

                                        newMs.Values[targetMetric.MetricDescriptor.Name] = metrics.Value{
                                                ValueType:  metrics.ValueFloat,
                                                FloatValue: newVal,
                                        }
                                }</span> else<span class="cov2" title="5"> if foundNew &amp;&amp; !foundOld || !foundNew &amp;&amp; foundOld </span><span class="cov0" title="0">{
                                        log.Debugf("Skipping rates for '%s' in '%s': metric not found in one of old (%v) or new (%v)", metricName, key, foundOld, foundNew)
                                }</span>
                        }
                }
                <span class="cov6" title="103">rc.previousMetricSets[key] = newMs</span>
        }

        // periodically prune deleted pods, containers etc from the internal cache
        <span class="cov2" title="4">log.Debugf("rate cache size: %d", len(rc.previousMetricSets))
        if rc.lastPruneTime.Before(time.Now().Add(-1 * rc.cachePruneInterval)) </span><span class="cov0" title="0">{
                log.Infof("pruning rate cache. cache size: %d lastPruneTime: %v", len(rc.previousMetricSets), rc.lastPruneTime)
                for key := range rc.previousMetricSets </span><span class="cov0" title="0">{
                        if _, found := batch.Sets[key]; !found </span><span class="cov0" title="0">{
                                log.Debugf("removing key %s from rate cache", key)
                                delete(rc.previousMetricSets, key)
                        }</span>
                }
                <span class="cov0" title="0">rc.lastPruneTime = time.Now()
                log.Infof("cache pruning completed. cache size: %d", len(rc.previousMetricSets))</span>
        }
        <span class="cov2" title="4">return batch, nil</span>
}

func NewRateCalculator(rateMetricsMapping map[string]metrics.Metric) *RateCalculator <span class="cov1" title="1">{
        return &amp;RateCalculator{
                rateMetricsMapping: rateMetricsMapping,
                previousMetricSets: make(map[metrics.ResourceKey]*metrics.Set, 256),
                cachePruneInterval: 5 * time.Minute,
                lastPruneTime:      time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package processors

import (
        "fmt"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        corev1 "k8s.io/api/core/v1"
)

type SumCountAggregator struct {
        name  string
        specs []SumCountAggregateSpec
}

type SumCountAggregateSpec struct {
        ResourceSumMetrics  []string
        ResourceCountMetric string
        IsPartOfGroup       func(*metrics.Set) bool
        Group               func(batch *metrics.Batch, resourceKey metrics.ResourceKey, resourceSet *metrics.Set) (metrics.ResourceKey, *metrics.Set)
}

func NewSumCountAggregator(name string, specs []SumCountAggregateSpec) *SumCountAggregator <span class="cov2" title="3">{
        return &amp;SumCountAggregator{name, specs}
}</span>

func (a *SumCountAggregator) Name() string <span class="cov1" title="1">{
        return fmt.Sprintf("%s_aggregator", a.name)
}</span>

func (a *SumCountAggregator) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov3" title="9">{
        for _, spec := range a.specs </span><span class="cov5" title="24">{
                for resourceKey, resourceSet := range batch.Sets </span><span class="cov10" title="942">{
                        if !spec.IsPartOfGroup(resourceSet) </span><span class="cov9" title="654">{
                                continue</span>
                        }
                        <span class="cov8" title="288">groupKey, groupSet := spec.Group(batch, resourceKey, resourceSet)
                        if groupSet == nil </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="288">aggregateCount(resourceSet, groupSet, spec.ResourceCountMetric)
                        if err := aggregate(resourceSet, groupSet, spec.ResourceSumMetrics); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="288">batch.Sets[groupKey] = groupSet</span>
                }
        }
        <span class="cov3" title="9">return batch, nil</span>
}

func isAggregatablePod(set *metrics.Set) bool <span class="cov8" title="310">{
        return isType(metrics.MetricSetTypePod)(set) &amp;&amp; podTakesUpResources(set)
}</span>

func isAggregatablePodContainer(set *metrics.Set) bool <span class="cov8" title="312">{
        return isType(metrics.MetricSetTypePodContainer)(set) &amp;&amp; podContainerTakesUpResources(set)
}</span>

func isType(matchType string) func(*metrics.Set) bool <span class="cov9" title="624">{
        return func(set *metrics.Set) bool </span><span class="cov10" title="942">{
                return set.Labels[metrics.LabelMetricSetType.Key] == matchType
        }</span>
}

func podTakesUpResources(set *metrics.Set) bool <span class="cov2" title="4">{
        labels, _ := set.FindLabels(metrics.MetricPodPhase.Name)
        return labels["phase"] == string(corev1.PodRunning)
}</span>

func podContainerTakesUpResources(set *metrics.Set) bool <span class="cov2" title="4">{
        labels, _ := set.FindLabels(metrics.MetricContainerStatus.Name)
        return labels["state"] != "terminated"
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package sinks

import (
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront"
)

type SinkFactory struct {
}

func (factory *SinkFactory) Build(cfg configuration.WavefrontSinkConfig) (wavefront.WavefrontSink, error) <span class="cov8" title="1">{
        return wavefront.NewWavefrontSink(cfg)
}</span>

func (factory *SinkFactory) BuildAll(cfgs []*configuration.WavefrontSinkConfig) []wavefront.WavefrontSink <span class="cov8" title="1">{
        result := make([]wavefront.WavefrontSink, 0, len(cfgs))

        for _, cfg := range cfgs </span><span class="cov8" title="1">{
                sink, err := factory.Build(*cfg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to create sink: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, sink)</span>
        }

        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                log.Fatal("No available sink to use")
        }</span>
        <span class="cov8" title="1">return result</span>
}

func NewSinkFactory() *SinkFactory <span class="cov8" title="1">{
        return &amp;SinkFactory{}
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/metrics/sinks/manager.go
// Diff against master for changes to the original code.

// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package sinks

import (
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sinks/wavefront"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/events"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"

        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
)

const (
        DefaultSinkStopTimeout = 60 * time.Second
)

var (
        sinkTimeouts gm.Counter
)

func init() <span class="cov1" title="1">{
        sinkTimeouts = gm.GetOrRegisterCounter("sink.manager.timeouts", gm.DefaultRegistry)
}</span>

type sinkHolder struct {
        sink              wavefront.WavefrontSink
        dataBatchChannel  chan *metrics.Batch
        eventBatchChannel chan *events.Event
        stopChannel       chan bool
}

// Sink Manager - a special sink that distributes data to other sinks. It pushes data
// only to these sinks that completed their previous exports. Data that could not be
// pushed in the defined time is dropped and not retried.
type sinkManager struct {
        sinkHolders       []sinkHolder
        exportDataTimeout time.Duration
        stopTimeout       time.Duration
}

func NewSinkManager(sinks []wavefront.WavefrontSink, exportDataTimeout, stopTimeout time.Duration) (wavefront.WavefrontSink, error) <span class="cov6" title="4">{
        var sinkHolders []sinkHolder
        for _, sink := range sinks </span><span class="cov9" title="8">{
                sh := sinkHolder{
                        sink:              sink,
                        dataBatchChannel:  make(chan *metrics.Batch),
                        eventBatchChannel: make(chan *events.Event),
                        stopChannel:       make(chan bool),
                }
                sinkHolders = append(sinkHolders, sh)
                go func(sh sinkHolder) </span><span class="cov9" title="8">{
                        for </span><span class="cov7" title="5">{
                                select </span>{
                                case data := &lt;-sh.dataBatchChannel:<span class="cov6" title="4">
                                        sh.sink.Export(data)</span>
                                case event := &lt;-sh.eventBatchChannel:<span class="cov0" title="0">
                                        sh.sink.ExportEvent(event)</span>
                                case isStop := &lt;-sh.stopChannel:<span class="cov3" title="2">
                                        log.WithField("name", sh.sink.Name()).Info("Sink stop received")
                                        if isStop </span><span class="cov3" title="2">{
                                                sh.sink.Stop()
                                                return
                                        }</span>
                                }
                        }
                }(sh)
        }
        <span class="cov6" title="4">return &amp;sinkManager{
                sinkHolders:       sinkHolders,
                exportDataTimeout: exportDataTimeout,
                stopTimeout:       stopTimeout,
        }, nil</span>
}

// Guarantees that the export will complete in sinkExportDataTimeout.
func (sm *sinkManager) Export(data *metrics.Batch) <span class="cov10" title="9">{
        var wg sync.WaitGroup
        for _, sh := range sm.sinkHolders </span><span class="cov6" title="4">{
                wg.Add(1)
                go func(sh sinkHolder, wg *sync.WaitGroup) </span><span class="cov6" title="4">{
                        defer wg.Done()
                        log.WithField("name", sh.sink.Name()).Debug("Pushing data to sink")
                        select </span>{
                        case sh.dataBatchChannel &lt;- data:<span class="cov6" title="4">
                                log.WithField("name", sh.sink.Name()).Info("Data push complete")</span>
                                // everything ok
                        case &lt;-time.After(sm.exportDataTimeout):<span class="cov8" title="6">
                                sinkTimeouts.Inc(1)
                                log.WithField("name", sh.sink.Name()).Info("Data push timed out. Increasing sinkExportDataTimeout may help.")</span>
                        }
                }(sh, &amp;wg)
        }
        // Wait for all pushes to complete or timeout.
        <span class="cov10" title="9">wg.Wait()</span>
}

func (sm *sinkManager) ExportEvent(event *events.Event) <span class="cov0" title="0">{
        var wg sync.WaitGroup
        for _, sh := range sm.sinkHolders </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(sh sinkHolder, wg *sync.WaitGroup) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        log.WithField("name", sh.sink.Name()).Debug("Pushing Events to sink")
                        select </span>{
                        case sh.eventBatchChannel &lt;- event:<span class="cov0" title="0">
                                log.WithField("name", sh.sink.Name()).Debug("Events push complete")</span>
                                // everything ok
                        case &lt;-time.After(sm.exportDataTimeout):<span class="cov0" title="0">
                                sinkTimeouts.Inc(1)
                                log.WithField("name", sh.sink.Name()).Info("Events push failed")</span>
                        }
                }(sh, &amp;wg)
        }
        // Wait for all pushes to complete or timeout.
        <span class="cov0" title="0">wg.Wait()</span>
}

func (sm *sinkManager) Name() string <span class="cov0" title="0">{
        return "Manager"
}</span>

func (sm *sinkManager) Stop() <span class="cov1" title="1">{
        for _, sh := range sm.sinkHolders </span><span class="cov3" title="2">{
                log.Infof("Running stop for: %s", sh.sink.Name())

                go func(sh sinkHolder) </span><span class="cov3" title="2">{
                        select </span>{
                        case sh.stopChannel &lt;- true:<span class="cov3" title="2">
                                // everything ok
                                log.Infof("Stop sent to sink: %s", sh.sink.Name())</span>

                        case &lt;-time.After(sm.stopTimeout):<span class="cov0" title="0">
                                log.Warningf("Failed to stop sink: %s", sh.sink.Name())</span>
                        }
                        <span class="cov3" title="2">return</span>
                }(sh)
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package wavefront

import (
        "fmt"
        "sort"
        "sync"

        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-sdk-go/event"
        "github.com/wavefronthq/wavefront-sdk-go/histogram"
        "github.com/wavefronthq/wavefront-sdk-go/senders"
)

type TestSender struct {
        testReceivedLines string
        mutex             sync.Mutex
}

func NewTestSender() senders.Sender <span class="cov6" title="6">{
        log.SetFormatter(&amp;log.JSONFormatter{})
        return &amp;TestSender{
                testReceivedLines: "",
        }
}</span>

func (t *TestSender) SendMetric(name string, value float64, _ int64, source string, tags map[string]string) error <span class="cov7" title="7">{
        line := fmt.Sprintf("Metric: %s %f source=\"%s\" %s\n", name, value, source, orderedTagString(tags))
        t.mutex.Lock()
        defer t.mutex.Unlock()
        t.testReceivedLines += line
        return nil
}</span>

func (t *TestSender) GetReceivedLines() string <span class="cov5" title="4">{
        t.mutex.Lock()
        defer t.mutex.Unlock()
        return t.testReceivedLines
}</span>

func (t *TestSender) SendEvent(name string, startMillis, endMillis int64, source string, tags map[string]string, setters ...event.Option) error <span class="cov0" title="0">{
        annotations := map[string]interface{}{}
        annotations["annotations"] = map[string]string{}
        for _, setter := range setters </span><span class="cov0" title="0">{
                setter(annotations)
        }</span>
        <span class="cov0" title="0">line := fmt.Sprintf("%s %s source=\"%s\" %s\n", name, "event", source, orderedTagString(tags))
        t.mutex.Lock()
        defer t.mutex.Unlock()
        t.testReceivedLines += line
        return nil</span>
}

func orderedTagString(tags map[string]string) string <span class="cov7" title="7">{
        tagNames := sortKeys(tags)

        tagStr := ""
        for _, tagName := range tagNames </span><span class="cov10" title="15">{
                if tagName != "cluster" </span><span class="cov7" title="8">{
                        tagStr += tagName + "=\"" + tags[tagName] + "\" "
                }</span>
        }
        <span class="cov6" title="6">return tagStr</span>
}

func sortKeys(tags map[string]string) []string <span class="cov7" title="7">{
        tagCount := len(tags)
        tagNames := make([]string, tagCount)

        count := 0
        for tagName := range tags </span><span class="cov10" title="15">{
                tagNames[count] = tagName
                count++
        }</span>

        <span class="cov7" title="7">sort.Strings(tagNames)
        return tagNames</span>
}

func (t *TestSender) SendDeltaCounter(name string, value float64, source string, tags map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (t *TestSender) SendDistribution(name string, centroids []histogram.Centroid, hgs map[histogram.Granularity]bool, ts int64, source string, tags map[string]string) error <span class="cov0" title="0">{
        return nil
}</span>

func (t *TestSender) SendSpan(name string, startMillis, durationMillis int64, source, traceId, spanId string, parents, followsFrom []string, tags []senders.SpanTag, spanLogs []senders.SpanLog) error <span class="cov0" title="0">{
        return nil
}</span>

func (t *TestSender) Flush() error <span class="cov0" title="0">{
        return nil
}</span>

func (t *TestSender) GetFailureCount() int64 <span class="cov0" title="0">{
        return 0
}</span>

func (t *TestSender) Start() {<span class="cov0" title="0">
}</span>

func (t *TestSender) Close() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package wavefront

import (
        "strings"

        log "github.com/sirupsen/logrus"
)

const (
        emptyReason       = "they were empty"
        excludeListReason = "they were on an exclude list"
        dedupeReason      = "there were too many tags so we removed tags with duplicate tag values"
)

// cleanTags removes empty, excluded tags, and tags with duplicate values (if there are too many tags) and returns a map
// that lists removed tag names by their reason for removal
func cleanTags(tags map[string]string, maxCapacity int) map[string][]string <span class="cov2" title="14">{
        removedReasons := map[string][]string{}
        removedReasons[emptyReason] = removeEmptyTags(tags)
        removedReasons[excludeListReason] = excludeTags(tags)
        if len(tags) &gt; maxCapacity </span><span class="cov1" title="3">{
                removedReasons[dedupeReason] = dedupeTagValues(tags)
        }</span>
        <span class="cov2" title="14">return removedReasons</span>
}

func logTagCleaningReasons(metricName string, reasons map[string][]string) <span class="cov1" title="3">{
        for reason, tagNames := range reasons </span><span class="cov2" title="6">{
                if len(tagNames) == 0 </span><span class="cov2" title="5">{
                        continue</span>
                }
                <span class="cov7" title="10062">log.Debugf(
                        "the following tags were removed from %s because %s: %s",
                        metricName, reason, strings.Join(tagNames, ", "),
                )</span>
        }
}

func copyStringMap(dst map[string]string, src map[string]string) <span class="cov0" title="0">{
        for k, v := range src </span><span class="cov0" title="0">{
                dst[k] = v
        }</span>
}

func withReason(tagNames []string, reason string) map[string]string <span class="cov0" title="0">{
        withReasons := map[string]string{}
        for _, tagName := range tagNames </span><span class="cov0" title="0">{
                withReasons[tagName] = reason
        }</span>
        <span class="cov0" title="0">return withReasons</span>
}

const minDedupeTagValueLen = 10

func dedupeTagValues(tags map[string]string) []string <span class="cov1" title="3">{
        var removedTags []string
        invertedTags := map[string]string{} // tag value -&gt; tag name
        for name, value := range tags </span><span class="cov2" title="6">{
                if len(value) &lt; minDedupeTagValueLen </span><span class="cov1" title="2">{
                        continue</span>
                }
                <span class="cov1" title="4">if len(invertedTags[value]) == 0 </span><span class="cov1" title="2">{
                        invertedTags[value] = name
                }</span> else<span class="cov1" title="2"> if isWinningName(name, invertedTags[value]) </span><span class="cov1" title="2">{
                        removedTags = append(removedTags, invertedTags[value])
                        delete(tags, invertedTags[value])
                        invertedTags[value] = name
                }</span> else<span class="cov0" title="0"> {
                        removedTags = append(removedTags, name)
                        delete(tags, name)
                }</span>
        }
        <span class="cov1" title="3">return removedTags</span>
}

func isWinningName(name string, prevWinner string) bool <span class="cov1" title="2">{
        return len(name) &lt; len(prevWinner) || (len(name) == len(prevWinner) &amp;&amp; name &lt; prevWinner)
}</span>

func removeEmptyTags(tags map[string]string) []string <span class="cov2" title="14">{
        var removed []string
        for name, value := range tags </span><span class="cov10" title="846979">{
                if len(value) == 0 </span><span class="cov6" title="5356">{
                        removed = append(removed, name)
                        delete(tags, name)
                }</span>
        }
        <span class="cov2" title="14">return removed</span>
}

func excludeTags(tags map[string]string) []string <span class="cov2" title="14">{
        var removed []string
        for name := range tags </span><span class="cov9" title="841623">{
                if excludeTag(name) </span><span class="cov2" title="6">{
                        removed = append(removed, name)
                        delete(tags, name)
                }</span>
        }
        <span class="cov2" title="14">return removed</span>
}

func excludeTag(name string) bool <span class="cov9" title="841623">{
        for _, excludeName := range excludeTagList </span><span class="cov3" title="62">{
                if excludeName == name </span><span class="cov1" title="4">{
                        return true
                }</span>
        }
        <span class="cov9" title="827139">for _, excludePrefix := range excludeTagPrefixes </span><span class="cov3" title="25">{
                if strings.HasPrefix(name, excludePrefix) </span><span class="cov5" title="542">{
                        return true
                }</span>
        }
        <span class="cov9" title="826597">return false</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package wavefront

import (
        "fmt"
        "math/rand"
        "os"
        "runtime/debug"
        "strconv"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/wavefront-sdk-go/event"
        "github.com/wavefronthq/wavefront-sdk-go/histogram"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/events"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        "github.com/wavefronthq/wavefront-sdk-go/senders"

        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
)

const (
        proxyClient  = 1
        directClient = 2
        testClient   = 3
)

const maxWavefrontTags = 20 // the maximum numbers of tags allowed in a wavefront point

var (
        excludeTagList     = [...]string{"namespace_id", "host_id", "pod_id", "hostname"}
        excludeTagPrefixes = [...]string{"label.beta.", "label.alpha."}
        sentPoints         gm.Counter
        errPoints          gm.Counter
        filteredPoints     gm.Counter
        sentEvents         gm.Counter
        errEvents          gm.Counter
        clientType         gm.Gauge
        sanitizedChars     = strings.NewReplacer("+", "-")
)

func init() <span class="cov1" title="1">{
        sentPoints = gm.GetOrRegisterCounter("wavefront.points.sent.count", gm.DefaultRegistry)
        errPoints = gm.GetOrRegisterCounter("wavefront.points.errors.count", gm.DefaultRegistry)
        filteredPoints = gm.GetOrRegisterCounter("wavefront.points.filtered.count", gm.DefaultRegistry)
        sentEvents = gm.GetOrRegisterCounter("wavefront.events.sent.count", gm.DefaultRegistry)
        errEvents = gm.GetOrRegisterCounter("wavefront.events.errors.count", gm.DefaultRegistry)
        clientType = gm.GetOrRegisterGauge("wavefront.sender.type", gm.DefaultRegistry)
}</span>

type WavefrontSink interface {
        Name() string
        Stop()
        metrics.Sink
        events.EventSink
}

type wavefrontSink struct {
        WavefrontClient senders.Sender
        ClusterName     string
        Prefix          string
        globalTags      map[string]string
        filters         filter.Filter
        forceGC         bool
        logPercent      float32
        stopHeartbeat   chan struct{}
}

func (sink *wavefrontSink) SendDistribution(name string, centroids []histogram.Centroid, hgs map[histogram.Granularity]bool, ts int64, source string, tags map[string]string) error <span class="cov0" title="0">{
        name = sanitizedChars.Replace(name)
        if len(sink.Prefix) &gt; 0 </span><span class="cov0" title="0">{
                name = sink.Prefix + "." + name
        }</span>
        <span class="cov0" title="0">logTagCleaningReasons(name, cleanTags(tags, maxWavefrontTags))
        return sink.WavefrontClient.SendDistribution(name, centroids, hgs, ts, source, tags)</span>
}

func NewWavefrontSink(cfg configuration.WavefrontSinkConfig) (WavefrontSink, error) <span class="cov6" title="4">{
        storage := &amp;wavefrontSink{
                ClusterName: configuration.GetStringValue(cfg.ClusterName, "k8s-cluster"),
                logPercent:  0.01,
        }

        if cfg.TestMode </span><span class="cov6" title="4">{
                storage.WavefrontClient = NewTestSender()
                clientType.Update(testClient)
        }</span> else<span class="cov1" title="1"> if cfg.ProxyAddress != "" </span><span class="cov1" title="1">{
                s := strings.Split(cfg.ProxyAddress, ":")
                host, portStr := s[0], s[1]
                port, err := strconv.Atoi(portStr)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error parsing proxy port: %s", err.Error())
                }</span>
                <span class="cov1" title="1">storage.WavefrontClient, err = senders.NewProxySender(&amp;senders.ProxyConfiguration{
                        Host:             host,
                        MetricsPort:      port,
                        DistributionPort: port,
                        EventsPort:       port,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating proxy sender: %s", err.Error())
                }</span>
                <span class="cov1" title="1">clientType.Update(proxyClient)</span>
        } else<span class="cov0" title="0"> if cfg.Server != "" </span><span class="cov0" title="0">{
                if len(cfg.Token) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("token missing for Wavefront sink")
                }</span>
                <span class="cov0" title="0">var err error
                storage.WavefrontClient, err = senders.NewDirectSender(&amp;senders.DirectConfiguration{
                        Server:        cfg.Server,
                        Token:         cfg.Token,
                        BatchSize:     cfg.BatchSize,
                        MaxBufferSize: cfg.MaxBufferSize,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error creating direct sender: %s", err.Error())
                }</span>
                <span class="cov0" title="0">clientType.Update(directClient)</span>
        }
        <span class="cov6" title="4">if storage.WavefrontClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proxyAddress or server property required for Wavefront sink")
        }</span>

        <span class="cov6" title="4">storage.globalTags = cfg.Tags
        if cfg.Prefix != "" </span><span class="cov6" title="4">{
                storage.Prefix = strings.Trim(cfg.Prefix, ".")
        }</span>
        <span class="cov6" title="4">storage.filters = filter.FromConfig(cfg.Filters)

        // force garbage collection if experimental flag enabled
        storage.forceGC = os.Getenv(util.ForceGC) != ""

        // configure error logging percentage
        if cfg.ErrorLogPercent &gt; 0.0 &amp;&amp; cfg.ErrorLogPercent &lt;= 1.0 </span><span class="cov0" title="0">{
                storage.logPercent = cfg.ErrorLogPercent
        }</span>

        // emit heartbeat metric
        <span class="cov6" title="4">storage.emitHeartbeat(storage.WavefrontClient, cfg)

        return storage, nil</span>
}

func (sink *wavefrontSink) Name() string <span class="cov10" title="9">{
        return "wavefront_sink"
}</span>

func (sink *wavefrontSink) Stop() <span class="cov0" title="0">{
        close(sink.stopHeartbeat)
        sink.WavefrontClient.Close()
}</span>

func (sink *wavefrontSink) SendMetric(metricName string, value float64, timestamp int64, source string, tags map[string]string) error <span class="cov5" title="3">{
        metricName = sanitizedChars.Replace(metricName)
        if len(sink.Prefix) &gt; 0 </span><span class="cov5" title="3">{
                metricName = sink.Prefix + "." + metricName
        }</span>
        <span class="cov5" title="3">logTagCleaningReasons(metricName, cleanTags(tags, maxWavefrontTags))

        return sink.WavefrontClient.SendMetric(metricName, value, timestamp, source, tags)</span>
}

func (sink *wavefrontSink) logVerboseError(f log.Fields, msg string) <span class="cov0" title="0">{
        if log.IsLevelEnabled(log.DebugLevel) </span><span class="cov0" title="0">{
                log.WithFields(f).Error(msg)
        }</span> else<span class="cov0" title="0"> if sink.loggingAllowed() </span><span class="cov0" title="0">{
                log.WithFields(f).Errorf("%s %s", "[sampled error]", msg)
        }</span>
}

func (sink *wavefrontSink) Export(batch *metrics.Batch) <span class="cov6" title="4">{
        log.Debugf("received metric points: %d", len(batch.Metrics))

        before := errPoints.Count()
        for _, point := range batch.Metrics </span><span class="cov6" title="4">{
                if point == nil </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov5" title="3">point.OverrideTag(metrics.LabelCluster.Key, sink.ClusterName)
                point.AddTags(sink.globalTags)
                point = wf.Filter(sink.filters, filteredPoints, point)
                if point == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="3">err := point.Send(sink)
                if err != nil </span><span class="cov0" title="0">{
                        errPoints.Inc(1)
                        sink.logVerboseError(log.Fields{
                                "name":  point.Name(),
                                "error": err,
                        }, "error sending metric")
                }</span> else<span class="cov5" title="3"> {
                        sentPoints.Inc(1)
                }</span>
        }

        <span class="cov6" title="4">after := errPoints.Count()
        if after &gt; before </span><span class="cov0" title="0">{
                log.WithField("count", after).Warning("Error sending one or more points")
        }</span>

        // This seems like an odd place for this considering that we still have references to the big
        // memory user, the Batch. However, moving it until that reference was released actually
        // reduced the effectiveness of this flag. The garbage collector has some interesting ideas about
        // what to clean and when.
        <span class="cov6" title="4">if sink.forceGC </span><span class="cov0" title="0">{
                log.Info("sink: forcing memory release")
                debug.FreeOSMemory()
        }</span>
}

func (sink *wavefrontSink) ExportEvent(ev *events.Event) <span class="cov0" title="0">{
        ev.Options = append(ev.Options, event.Annotate("cluster", sink.ClusterName))
        host := sink.ClusterName

        err := sink.WavefrontClient.SendEvent(
                ev.Message,
                ev.Ts.Unix(), 0,
                host,
                ev.Tags,
                ev.Options...,
        )
        if err != nil </span><span class="cov0" title="0">{
                sink.logVerboseError(log.Fields{
                        "message": ev.Message,
                        "error":   err,
                }, "error sending event")
                errEvents.Inc(1)
        }</span> else<span class="cov0" title="0"> {
                sentEvents.Inc(1)
        }</span>
}

func getDefault(val, defaultVal string) string <span class="cov6" title="4">{
        if val == "" </span><span class="cov6" title="4">{
                return defaultVal
        }</span>
        <span class="cov1" title="1">return val</span>
}

func (sink *wavefrontSink) loggingAllowed() bool <span class="cov0" title="0">{
        return rand.Float32() &lt;= sink.logPercent
}</span>

func (sink *wavefrontSink) emitHeartbeat(sender senders.Sender, cfg configuration.WavefrontSinkConfig) <span class="cov6" title="4">{
        ticker := time.NewTicker(1 * time.Minute)
        sink.stopHeartbeat = make(chan struct{})
        source := getDefault(util.GetNodeName(), "wavefront-collector-for-kubernetes")
        tags := map[string]string{
                "cluster":             cfg.ClusterName,
                "stats_prefix":        configuration.GetStringValue(cfg.Prefix, "kubernetes."),
                "installation_method": util.GetInstallationMethod(),
        }

        eventsEnabled := 0.0
        if cfg.EventsEnabled </span><span class="cov0" title="0">{
                eventsEnabled = 1.0
        }</span>

        <span class="cov6" title="4">go func() </span><span class="cov6" title="4">{
                log.Debug("emitting heartbeat metric")
                util.AddK8sTags(tags)
                err := sender.SendMetric("~wavefront.kubernetes.collector.version", cfg.Version, 0, source, tags)
                if err != nil </span><span class="cov1" title="1">{
                        log.Debugf("error emitting heartbeat metric :%v", err)
                }</span>
                <span class="cov6" title="4">for </span><span class="cov6" title="4">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov1" title="1">
                                util.AddK8sTags(tags)
                                _ = sender.SendMetric("~wavefront.kubernetes.collector.version", cfg.Version, 0, source, tags)
                                _ = sender.SendMetric("~wavefront.kubernetes.collector.config.events.enabled", eventsEnabled, 0, source, tags)
                                sink.logStatus()</span>
                        case &lt;-sink.stopHeartbeat:<span class="cov0" title="0">
                                log.Info("stopping heartbeat")
                                ticker.Stop()
                                return</span>
                        }
                }
        }()
}

func (sink *wavefrontSink) logStatus() <span class="cov1" title="1">{
        // # events can be large in volume. log a status message periodically
        sent := sentEvents.Count()
        errs := errEvents.Count()
        if sent &gt; 0 || errs &gt; 0 </span><span class="cov0" title="0">{
                log.WithFields(log.Fields{
                        "sent":   sentEvents.Count(),
                        "errors": errEvents.Count(),
                }).Info("Events processed")
        }</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package cadvisor

import (
        "context"
        "net"
        "net/url"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type NodeLister interface {
        List(ctx context.Context, opts metav1.ListOptions) (*v1.NodeList, error)
}

const cAdvisorEndpoint = "/metrics/cadvisor"

// GenerateURLs generates cAdvisor prometheus urls to be queried by THIS collector instance
func GenerateURLs(lister NodeLister, myNode string, scrapeOwnNode bool, kubeletURL func(ip net.IP, path string) *url.URL) ([]*url.URL, error) <span class="cov10" title="5">{
        nodeList, err := lister.List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="4">var urls []*url.URL
        for _, node := range nodeList.Items </span><span class="cov10" title="5">{
                _, ip, err := util.GetNodeHostnameAndIP(&amp;node)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="4">kubeletURL := kubeletURL(ip, cAdvisorEndpoint)
                if scrapeOwnNode </span><span class="cov4" title="2">{
                        if node.Name == myNode </span><span class="cov4" title="2">{
                                urls = append(urls, kubeletURL)
                                break</span>
                        }
                } else<span class="cov4" title="2"> {
                        urls = append(urls, kubeletURL)
                }</span>
        }
        <span class="cov7" title="3">return urls, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package cadvisor

import (
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

type cadvisorSourceProvider struct {
        metrics.DefaultSourceProvider
        config        configuration.CadvisorSourceConfig
        kubeClient    *kubernetes.Clientset
        kubeConfig    *rest.Config
        kubeletConfig *kubelet.KubeletClientConfig
}

func NewProvider(
        config configuration.CadvisorSourceConfig,
        summaryConfig configuration.SummarySourceConfig,
) (metrics.SourceProvider, error) <span class="cov1" title="1">{
        kubeConfig, kubeletConfig, err := kubelet.GetKubeConfigs(summaryConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">kubeClient, err := kubernetes.NewForConfig(kubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;cadvisorSourceProvider{
                config:        config,
                kubeClient:    kubeClient,
                kubeConfig:    kubeConfig,
                kubeletConfig: kubeletConfig,
        }, nil</span>
}

func (c *cadvisorSourceProvider) GetMetricsSources() []metrics.Source <span class="cov10" title="10">{
        if !util.ScrapeAnyNodes() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov10" title="10">promURLs, err := GenerateURLs(c.kubeClient.CoreV1().Nodes(), util.GetNodeName(), util.ScrapeOnlyOwnNode(), c.kubeletConfig.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error getting sources for cAdvisor: %s", err.Error())
                return nil
        }</span>
        <span class="cov10" title="10">var sources []metrics.Source
        for _, promURL := range promURLs </span><span class="cov10" title="10">{
                promSource, err := generatePrometheusSource(c.config, promURL.String(), c.kubeConfig)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error generating sources for cAdvisor: %s", err.Error())
                        return nil
                }</span>
                <span class="cov10" title="10">sources = append(sources, promSource)</span>
        }
        <span class="cov10" title="10">return sources</span>
}

func (c *cadvisorSourceProvider) Name() string <span class="cov1" title="1">{
        return "cadvisor_metrics_provider"
}</span>

func generatePrometheusSource(cfg configuration.CadvisorSourceConfig, promURL string, restConfig *rest.Config) (metrics.Source, error) <span class="cov10" title="10">{
        prom, err := prometheus.NewPrometheusMetricsSource(
                promURL,
                cfg.Prefix,
                cfg.Source,
                "",
                cfg.Tags,
                filter.FromConfig(cfg.Filters),
                generateHTTPCfg(restConfig),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="10">return metrics.NewErrorDecorator(prom, TransformPermissionError), nil</span>
}

func generateHTTPCfg(restConfig *rest.Config) httputil.ClientConfig <span class="cov10" title="10">{
        return httputil.ClientConfig{
                BearerTokenFile: restConfig.BearerTokenFile,
                BearerToken:     restConfig.BearerToken,
                TLSConfig: httputil.TLSConfig{
                        CAFile:             restConfig.CAFile,
                        CertFile:           restConfig.CertFile,
                        KeyFile:            restConfig.KeyFile,
                        ServerName:         restConfig.ServerName,
                        InsecureSkipVerify: restConfig.Insecure,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package cadvisor

import (
        "errors"
        "fmt"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus"
)

func TransformPermissionError(err error) error <span class="cov10" title="6">{
        var httpErr *prometheus.HTTPError
        if errors.As(err, &amp;httpErr) &amp;&amp; httpErr != nil &amp;&amp; (httpErr.StatusCode == 401 || httpErr.StatusCode == 403) </span><span class="cov4" title="2">{
                return fmt.Errorf("missing nodes/metrics permission in the collector's cluster role: %s", err.Error())
        }</span>
        <span class="cov7" title="4">return err</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package controlplane

import (
        "fmt"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet"
)

const (
        metricsURL    = "https://kubernetes.default.svc:443/metrics"
        metricsSource = "control_plane_source"
        jitterTime    = time.Second * 40
        metricsPrefix = "kubernetes.controlplane."
)

type provider struct {
        metrics.DefaultSourceProvider

        providers []metrics.SourceProvider
}

func NewProvider(cfg configuration.ControlPlaneSourceConfig, summaryCfg configuration.SummarySourceConfig) (metrics.SourceProvider, error) <span class="cov5" title="4">{
        var providers []metrics.SourceProvider
        for _, promCfg := range buildPromConfigs(cfg, summaryCfg) </span><span class="cov6" title="6">{
                provider, err := prometheus.NewPrometheusProvider(promCfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error building prometheus sources for control plane: %s", err.Error())
                }</span>
                <span class="cov6" title="6">providers = append(providers, provider)</span>
        }
        <span class="cov5" title="4">return &amp;provider{providers: providers}, nil</span>
}

func (p *provider) GetMetricsSources() []metrics.Source <span class="cov7" title="10">{
        var sources []metrics.Source
        for _, provider := range p.providers </span><span class="cov10" title="20">{
                sources = append(sources, provider.GetMetricsSources()...)
        }</span>
        <span class="cov7" title="10">return sources</span>
}

func (p *provider) Name() string <span class="cov1" title="1">{
        return metricsSource
}</span>

func (p *provider) DiscoveryPluginConfigs() []discovery.PluginConfig <span class="cov3" title="2">{
        if !util.ScrapeAnyNodes() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="2">return []discovery.PluginConfig{{
                Name: "coredns-discovery-controlplane",
                Type: "prometheus",
                Selectors: discovery.Selectors{
                        Images: []string{"*coredns:*"},
                        Labels: map[string][]string{
                                "k8s-app": {"kube-dns"},
                        },
                },
                Port:   "9153",
                Scheme: "http",
                Path:   "/metrics",
                Prefix: metricsPrefix,
                Filters: filter.Config{
                        MetricAllowList: []string{
                                metricsPrefix + "coredns.dns.request.duration.seconds.bucket",
                                metricsPrefix + "coredns.dns.responses.total.counter",
                        },
                },
                Collection: discovery.CollectionConfig{
                        Interval: p.CollectionInterval(),
                        Timeout:  p.Timeout(),
                },
                Internal: true,
        }}</span>
}

func buildPromConfigs(cfg configuration.ControlPlaneSourceConfig, summaryCfg configuration.SummarySourceConfig) []configuration.PrometheusSourceConfig <span class="cov5" title="4">{
        var prometheusSourceConfigs []configuration.PrometheusSourceConfig

        kubeConfig, _, err := kubelet.GetKubeConfigs(summaryCfg)
        if err != nil </span><span class="cov1" title="1">{
                log.Infof("error %v", err)
                return nil
        }</span>
        <span class="cov4" title="3">httpClientConfig := httputil.ClientConfig{
                BearerTokenFile: kubeConfig.BearerTokenFile,
                BearerToken:     kubeConfig.BearerToken,
                TLSConfig: httputil.TLSConfig{
                        CAFile:             kubeConfig.CAFile,
                        CertFile:           kubeConfig.CertFile,
                        KeyFile:            kubeConfig.KeyFile,
                        ServerName:         kubeConfig.ServerName,
                        InsecureSkipVerify: kubeConfig.Insecure,
                },
        }
        metricAllowList := []string{
                metricsPrefix + "etcd.request.duration.seconds.bucket",
                metricsPrefix + "etcd.request.duration.seconds",
                metricsPrefix + "etcd.object.counts.gauge",
                metricsPrefix + "etcd.db.total.size.in.bytes.gauge",
                metricsPrefix + "workqueue.adds.total.counter",
                metricsPrefix + "workqueue.queue.duration.seconds.bucket",
                metricsPrefix + "workqueue.queue.duration.seconds",
        }

        promSourceConfig := createPrometheusSourceConfig("etcd-workqueue", httpClientConfig, metricAllowList, nil, cfg.Collection.Interval+jitterTime)
        prometheusSourceConfigs = append(prometheusSourceConfigs, promSourceConfig)

        apiServerAllowList := []string{
                metricsPrefix + "apiserver.request.duration.seconds.bucket",
                metricsPrefix + "apiserver.request.duration.seconds",
                metricsPrefix + "apiserver.request.total.counter",
        }
        apiServerTagAllowList := map[string][]string{
                "resource": {"customresourcedefinitions", "namespaces", "lease", "nodes", "pods", "tokenreviews", "subjectaccessreviews"},
        }
        promApiServerSourceConfig := createPrometheusSourceConfig("apiserver", httpClientConfig, apiServerAllowList, apiServerTagAllowList, cfg.Collection.Interval)
        prometheusSourceConfigs = append(prometheusSourceConfigs, promApiServerSourceConfig)

        return prometheusSourceConfigs</span>
}

func createPrometheusSourceConfig(name string, httpClientConfig httputil.ClientConfig, metricAllowList []string,
        metricTagAllowList map[string][]string, collectionInterval time.Duration) configuration.PrometheusSourceConfig <span class="cov6" title="6">{

        controlPlaneTransform := configuration.Transforms{
                Source: metricsSource,
                Prefix: metricsPrefix,
                Tags:   nil,
                Filters: filter.Config{
                        MetricAllowList:    metricAllowList,
                        MetricDenyList:     nil,
                        MetricTagAllowList: metricTagAllowList,
                        MetricTagDenyList:  nil,
                        TagInclude:         nil,
                        TagExclude:         nil,
                },
        }

        sourceConfig := configuration.PrometheusSourceConfig{
                Transforms: controlPlaneTransform,
                Collection: configuration.CollectionConfig{
                        Interval: collectionInterval,
                        Timeout:  0,
                },
                URL:               metricsURL,
                HTTPClientConfig:  httpClientConfig,
                Discovered:        "",
                Name:              name,
                UseLeaderElection: true,
        }
        return sourceConfig
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package sources

import (
        "time"
)

type IntervalTimer struct {
        *time.Timer
        interval      time.Duration
        startTime     time.Time
        lastResetTime time.Time
}

func (t *IntervalTimer) Reset() (intervalsMissed int64) <span class="cov4" title="5">{
        now := time.Now()
        intervals := t.intervalsMissed(now)
        t.lastResetTime = now
        waitTime := t.waitToNextInterval(now.Sub(t.startTime))
        t.Timer.Reset(waitTime)
        return intervals
}</span>

func NewIntervalTimer(interval time.Duration) *IntervalTimer <span class="cov6" title="16">{
        now := time.Now()
        return &amp;IntervalTimer{
                Timer:         time.NewTimer(interval),
                interval:      interval,
                startTime:     now,
                lastResetTime: now,
        }
}</span>

func (t *IntervalTimer) intervalsMissed(now time.Time) (intervalsMissed int64) <span class="cov5" title="8">{
        if now.Sub(t.lastResetTime) &lt; t.interval </span><span class="cov9" title="71">{
                return 0
        }</span>
        <span class="cov10" title="82">return int64((now.Sub(t.lastResetTime) / t.interval) - 1)</span>
}

func (t *IntervalTimer) waitToNextInterval(diff time.Duration) time.Duration <span class="cov5" title="8">{
        wait := t.interval - (diff % t.interval)
        if wait &lt; scaleInterval(t.interval, 0.0333) </span><span class="cov1" title="1">{ // 3.33%. This was chosen arbitrarily. If you have a better idea, change it!
                wait += t.interval
        }</span>
        <span class="cov5" title="8">return wait</span>
}

func scaleInterval(interval time.Duration, ratio float64) time.Duration <span class="cov5" title="8">{
        return time.Duration(float64(interval) * ratio)
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        batchv1beta1 "k8s.io/api/batch/v1beta1"
)

func pointsForCronJob(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov0" title="0">{
        job, ok := item.(*batchv1beta1.CronJob)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov0" title="0">tags := buildTags("cronjob", job.Name, job.Namespace, transforms.Tags)
        now := time.Now().Unix()
        active := float64(len(job.Status.Active))

        return []wf.Metric{
                metricPoint(transforms.Prefix, "cronjob.active", active, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        appsv1 "k8s.io/api/apps/v1"
)

func pointsForDaemonSet(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="30">{
        ds, ok := item.(*appsv1.DaemonSet)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="30">tags := buildTags("daemonset", ds.Name, ds.Namespace, transforms.Tags)
        now := time.Now().Unix()
        currentScheduled := float64(ds.Status.CurrentNumberScheduled)
        desiredScheduled := float64(ds.Status.DesiredNumberScheduled)
        misScheduled := float64(ds.Status.NumberMisscheduled)
        ready := float64(ds.Status.NumberReady)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "daemonset.current_scheduled", currentScheduled, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "daemonset.desired_scheduled", desiredScheduled, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "daemonset.misscheduled", misScheduled, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "daemonset.ready", ready, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        appsv1 "k8s.io/api/apps/v1"
)

func pointsForDeployment(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="40">{
        deployment, ok := item.(*appsv1.Deployment)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="40">tags := buildTags("deployment", deployment.Name, deployment.Namespace, transforms.Tags)
        now := time.Now().Unix()
        desired := floatVal(deployment.Spec.Replicas, 1.0)
        available := float64(deployment.Status.AvailableReplicas)
        ready := float64(deployment.Status.ReadyReplicas)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "deployment.desired_replicas", desired, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "deployment.available_replicas", available, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "deployment.ready_replicas", ready, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
)

func buildTags(key, name, ns string, srcTags map[string]string) map[string]string <span class="cov3" title="7">{
        tags := make(map[string]string, len(srcTags)+2)
        tags[key] = name

        if ns != "" </span><span class="cov3" title="7">{
                tags["namespace_name"] = ns
        }</span>

        <span class="cov3" title="7">for k, v := range srcTags </span><span class="cov0" title="0">{
                tags[k] = v
        }</span>
        <span class="cov3" title="7">return tags</span>
}

func copyLabels(in map[string]string, out map[string]string) <span class="cov2" title="4">{
        for key, value := range in </span><span class="cov10" title="550">{
                if len(key) &gt; 0 &amp;&amp; len(value) &gt; 0 </span><span class="cov9" title="450">{
                        out["label."+key] = value
                }</span>
        }
}

func copyTags(in map[string]string, out map[string]string) <span class="cov3" title="7">{
        for key, value := range in </span><span class="cov9" title="480">{
                if len(key) &gt; 0 &amp;&amp; len(value) &gt; 0 </span><span class="cov9" title="480">{
                        out[key] = value
                }</span>
        }
}

func metricPoint(prefix, name string, value float64, ts int64, source string, tags map[string]string) wf.Metric <span class="cov3" title="7">{
        return wf.NewPoint(
                prefix+name,
                value,
                ts,
                source,
                tags,
        )
}</span>

func floatVal(i *int32, f float64) float64 <span class="cov7" title="130">{
        if i != nil </span><span class="cov7" title="130">{
                return float64(*i)
        }</span>
        <span class="cov0" title="0">return f</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
        "k8s.io/api/autoscaling/v2beta2"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
)

func pointsForHPA(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov0" title="0">{
        hpa, ok := item.(*v2beta2.HorizontalPodAutoscaler)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov0" title="0">tags := buildTags("hpa", hpa.Name, hpa.Namespace, transforms.Tags)
        now := time.Now().Unix()
        maxReplicas := float64(hpa.Spec.MaxReplicas)
        minReplicas := floatVal(hpa.Spec.MinReplicas, 1.0)
        currReplicas := float64(hpa.Status.CurrentReplicas)
        desiredReplicas := float64(hpa.Status.DesiredReplicas)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "hpa.max_replicas", maxReplicas, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "hpa.min_replicas", minReplicas, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "hpa.current_replicas", currReplicas, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "hpa.desired_replicas", desiredReplicas, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        batchv1 "k8s.io/api/batch/v1"
)

func pointsForJob(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="20">{
        job, ok := item.(*batchv1.Job)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="20">tags := buildTags("job", job.Name, job.Namespace, transforms.Tags)
        now := time.Now().Unix()
        active := float64(job.Status.Active)
        failed := float64(job.Status.Failed)
        succeeded := float64(job.Status.Succeeded)
        completions := floatVal(job.Spec.Completions, -1.0)
        parallelism := floatVal(job.Spec.Parallelism, -1.0)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "job.active", active, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "job.failed", failed, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "job.succeeded", succeeded, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "job.completions", completions, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "job.parallelism", parallelism, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "fmt"
        "sync"
        "time"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"
        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/api/autoscaling/v2beta1"
        batchv1 "k8s.io/api/batch/v1"
        batchv1beta1 "k8s.io/api/batch/v1beta1"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
)

const (
        daemonSets               = "daemonsets"
        deployments              = "deployments"
        replicaSets              = "replicasets"
        replicationControllers   = "replicationcontrollers"
        statefulSets             = "statefulsets"
        jobs                     = "jobs"
        cronJobs                 = "cronjobs"
        horizontalPodAutoscalers = "horizontalpodautoscalers"
        nodes                    = "nodes"
        nonRunningPods           = "pods"
)

var (
        doOnce    sync.Once
        singleton *lister
)

type lister struct {
        kubeClient kubernetes.Interface
        informers  map[string]cache.SharedInformer
        stopCh     chan struct{}
}

func newLister(kubeClient kubernetes.Interface) *lister <span class="cov1" title="1">{
        doOnce.Do(func() </span><span class="cov1" title="1">{
                singleton = &amp;lister{
                        kubeClient: kubeClient,
                        informers:  buildInformers(kubeClient),
                }
                leadership.NewManager(singleton, "kstate", kubeClient).Start()
        }</span>)
        <span class="cov1" title="1">return singleton</span>
}

func buildInformers(kubeClient kubernetes.Interface) map[string]cache.SharedInformer <span class="cov1" title="1">{
        m := make(map[string]cache.SharedInformer)
        m[daemonSets] = buildInformer(daemonSets, &amp;appsv1.DaemonSet{}, kubeClient.AppsV1().RESTClient())
        m[deployments] = buildInformer(deployments, &amp;appsv1.Deployment{}, kubeClient.AppsV1().RESTClient())
        m[statefulSets] = buildInformer(statefulSets, &amp;appsv1.StatefulSet{}, kubeClient.AppsV1().RESTClient())
        m[replicaSets] = buildInformer(replicaSets, &amp;appsv1.ReplicaSet{}, kubeClient.AppsV1().RESTClient())
        m[jobs] = buildInformer(jobs, &amp;batchv1.Job{}, kubeClient.BatchV1().RESTClient())
        m[cronJobs] = buildInformer(cronJobs, &amp;batchv1beta1.CronJob{}, kubeClient.BatchV1beta1().RESTClient())
        m[horizontalPodAutoscalers] = buildInformer(horizontalPodAutoscalers, &amp;v2beta1.HorizontalPodAutoscaler{}, kubeClient.AutoscalingV2beta1().RESTClient())
        m[nodes] = buildInformer(nodes, &amp;v1.Node{}, kubeClient.CoreV1().RESTClient())
        m[replicationControllers] = buildInformer(replicationControllers, &amp;v1.ReplicationController{}, kubeClient.CoreV1().RESTClient())
        m[nonRunningPods] = buildInformerWithFieldsSelector(nonRunningPods, &amp;v1.Pod{}, kubeClient.CoreV1().RESTClient(), fields.OneTermNotEqualSelector("status.phase", "Running"))
        return m
}</span>

func buildInformer(resource string, resType runtime.Object, getter cache.Getter) cache.SharedInformer <span class="cov5" title="9">{
        return buildInformerWithFieldsSelector(resource, resType, getter, fields.Everything())
}</span>

func buildInformerWithFieldsSelector(resource string, resType runtime.Object, getter cache.Getter, selector fields.Selector) cache.SharedInformer <span class="cov5" title="10">{
        lw := cache.NewListWatchFromClient(getter, resource, v1.NamespaceAll, selector)
        return cache.NewSharedInformer(lw, resType, time.Hour)
}</span>

func (l *lister) List(resource string) ([]interface{}, error) <span class="cov10" title="100">{
        if informer, exists := l.informers[resource]; exists </span><span class="cov10" title="100">{
                return informer.GetStore().List(), nil
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("unsupported resource type: %s", resource)
        }</span>
}

func (l *lister) Resume() <span class="cov1" title="1">{
        log.Infof("starting kstate lister")
        l.stopCh = make(chan struct{})
        for k, informer := range l.informers </span><span class="cov5" title="10">{
                log.Debugf("starting %s informer", k)
                go informer.Run(l.stopCh)
        }</span>
}

func (l *lister) Pause() <span class="cov0" title="0">{
        log.Infof("pausing kstate lister")
        if l.stopCh != nil </span><span class="cov0" title="0">{
                close(l.stopCh)
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"

        v1 "k8s.io/api/core/v1"
)

func pointsForNode(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov6" title="10">{
        node, ok := item.(*v1.Node)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>
        <span class="cov6" title="10">now := time.Now().Unix()
        points := buildNodeConditions(node, transforms, now)
        points = append(points, buildNodeTaints(node, transforms, now)...)
        points = append(points, buildNodeInfo(node, transforms, now))
        return points</span>
}

func buildNodeConditions(node *v1.Node, transforms configuration.Transforms, ts int64) []wf.Metric <span class="cov6" title="10">{
        points := make([]wf.Metric, len(node.Status.Conditions))
        for i, condition := range node.Status.Conditions </span><span class="cov10" title="40">{
                tags := buildTags("nodename", node.Name, "", transforms.Tags)
                copyLabels(node.GetLabels(), tags)
                tags["status"] = string(condition.Status)
                tags["condition"] = string(condition.Type)
                tags[metrics.LabelNodeRole.Key] = util.GetNodeRole(node)

                // add status and condition (condition.status and condition.type)
                points[i] = metricPoint(transforms.Prefix, "node.status.condition",
                        nodeConditionFloat64(condition.Status), ts, transforms.Source, tags)
        }</span>
        <span class="cov6" title="10">return points</span>
}

func buildNodeTaints(node *v1.Node, transforms configuration.Transforms, ts int64) []wf.Metric <span class="cov6" title="10">{
        points := make([]wf.Metric, len(node.Spec.Taints))
        for i, taint := range node.Spec.Taints </span><span class="cov0" title="0">{
                tags := buildTags("nodename", node.Name, "", transforms.Tags)
                copyLabels(node.GetLabels(), tags)
                tags["key"] = taint.Key
                tags["value"] = taint.Value
                tags["effect"] = string(taint.Effect)
                points[i] = metricPoint(transforms.Prefix, "node.spec.taint", 1.0, ts, transforms.Source, tags)
        }</span>
        <span class="cov6" title="10">return points</span>
}

func buildNodeInfo(node *v1.Node, transforms configuration.Transforms, ts int64) wf.Metric <span class="cov6" title="10">{
        tags := buildTags("nodename", node.Name, "", transforms.Tags)
        copyLabels(node.GetLabels(), tags)
        tags["kernel_version"] = node.Status.NodeInfo.KernelVersion
        tags["os_image"] = node.Status.NodeInfo.OSImage
        tags["container_runtime_version"] = node.Status.NodeInfo.ContainerRuntimeVersion
        tags["kubelet_version"] = node.Status.NodeInfo.KubeletVersion
        tags["kubeproxy_version"] = node.Status.NodeInfo.KubeProxyVersion
        tags["provider_id"] = node.Spec.ProviderID
        tags["pod_cidr"] = node.Spec.PodCIDR
        tags["node_role"] = util.GetNodeRole(node)

        for _, address := range node.Status.Addresses </span><span class="cov8" title="20">{
                if address.Type == "InternalIP" </span><span class="cov6" title="10">{
                        tags["internal_ip"] = address.Address
                }</span>
        }
        <span class="cov6" title="10">return metricPoint(transforms.Prefix, "node.info", 1.0, ts, transforms.Source, tags)</span>
}

func nodeConditionFloat64(status v1.ConditionStatus) float64 <span class="cov10" title="40">{
        switch status </span>{
        case v1.ConditionTrue:<span class="cov6" title="10">
                return 1.0</span>
        case v1.ConditionFalse:<span class="cov9" title="30">
                return 0.0</span>
        default:<span class="cov0" title="0">
                return -1.0</span>
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"
        v1 "k8s.io/api/core/v1"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
)

func pointsForNonRunningPods(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="60">{
        pod, ok := item.(*v1.Pod)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="60">sharedTags := make(map[string]string, len(pod.GetLabels())+1)
        copyLabels(pod.GetLabels(), sharedTags)
        now := time.Now().Unix()

        points := buildPodPhaseMetrics(pod, transforms, sharedTags, now)

        points = append(points, buildContainerStatusMetrics(pod, sharedTags, transforms, now)...)
        return points</span>
}

func truncateMessage(message string) string <span class="cov9" title="50">{
        maxPointTagLength := 255 - len("=") - len("message")
        if len(message) &gt;= maxPointTagLength </span><span class="cov1" title="1">{
                return message[0:maxPointTagLength]
        }</span>
        <span class="cov9" title="50">return message</span>
}

func buildPodPhaseMetrics(pod *v1.Pod, transforms configuration.Transforms, sharedTags map[string]string, now int64) []wf.Metric <span class="cov10" title="60">{
        tags := buildTags("pod_name", pod.Name, pod.Namespace, transforms.Tags)
        tags[metrics.LabelMetricSetType.Key] = metrics.MetricSetTypePod
        tags[metrics.LabelPodId.Key] = string(pod.UID)
        tags["phase"] = string(pod.Status.Phase)

        phaseValue := util.ConvertPodPhase(pod.Status.Phase)
        if phaseValue == util.POD_PHASE_PENDING </span><span class="cov7" title="20">{
                for _, condition := range pod.Status.Conditions </span><span class="cov9" title="50">{
                        if condition.Type == v1.PodScheduled &amp;&amp; condition.Status == "False" </span><span class="cov6" title="10">{
                                tags[metrics.LabelNodename.Key] = "none"
                                tags["reason"] = condition.Reason
                                tags["message"] = truncateMessage(condition.Message)
                        }</span> else<span class="cov9" title="40"> if condition.Type == v1.ContainersReady &amp;&amp; condition.Status == "False" </span><span class="cov6" title="10">{
                                tags["reason"] = condition.Reason
                                tags["message"] = truncateMessage(condition.Message)
                        }</span>
                }
        }

        <span class="cov10" title="60">if phaseValue == util.POD_PHASE_FAILED </span><span class="cov8" title="30">{
                for _, condition := range pod.Status.Conditions </span><span class="cov4" title="4">{
                        if condition.Type == v1.PodReady </span><span class="cov8" title="30">{
                                tags["reason"] = condition.Reason
                                tags["message"] = truncateMessage(condition.Message)
                        }</span>
                }
        }

        <span class="cov10" title="60">nodeName := pod.Spec.NodeName
        if len(nodeName) &gt; 0 </span><span class="cov9" title="50">{
                sharedTags[metrics.LabelNodename.Key] = nodeName
        }</span>
        <span class="cov10" title="60">copyTags(sharedTags, tags)
        points := []wf.Metric{
                metricPoint(transforms.Prefix, "pod.status.phase", float64(phaseValue), now, transforms.Source, tags),
        }
        return points</span>
}

func buildContainerStatusMetrics(pod *v1.Pod, sharedTags map[string]string, transforms configuration.Transforms, now int64) []wf.Metric <span class="cov10" title="60">{
        statuses := pod.Status.ContainerStatuses
        if len(statuses) == 0 </span><span class="cov6" title="10">{
                return []wf.Metric{}
        }</span>

        <span class="cov9" title="50">points := make([]wf.Metric, len(statuses))
        for i, status := range statuses </span><span class="cov9" title="50">{
                containerStateInfo := util.NewContainerStateInfo(status.State)
                tags := buildTags("pod_name", pod.Name, pod.Namespace, transforms.Tags)
                tags[metrics.LabelMetricSetType.Key] = metrics.MetricSetTypePodContainer
                tags[metrics.LabelContainerName.Key] = status.Name
                tags[metrics.LabelContainerBaseImage.Key] = status.Image

                copyTags(sharedTags, tags)
                containerStateInfo.AddMetricTags(tags)

                points[i] = metricPoint(transforms.Prefix, "pod_container.status", float64(containerStateInfo.Value), now, transforms.Source, tags)
        }</span>
        <span class="cov9" title="50">return points</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "fmt"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/wavefronthq/go-metrics-wavefront/reporting"

        gometrics "github.com/rcrowley/go-metrics"
)

type resourceHandler func(interface{}, configuration.Transforms) []wf.Metric

type stateMetricsSource struct {
        lister     *lister
        transforms configuration.Transforms
        source     string
        filters    filter.Filter
        funcs      map[string]resourceHandler

        pps gometrics.Counter
        eps gometrics.Counter
        fps gometrics.Counter
}

func NewStateMetricsSource(lister *lister, transforms configuration.Transforms) (metrics.Source, error) <span class="cov1" title="1">{
        pt := map[string]string{"type": "kubernetes.state"}
        ppsKey := reporting.EncodeKey("source.points.collected", pt)
        epsKey := reporting.EncodeKey("source.collect.errors", pt)
        fpsKey := reporting.EncodeKey("source.points.filtered", pt)

        transforms.Source = getDefault(util.GetNodeName(), transforms.Source)
        transforms.Prefix = getDefault(transforms.Prefix, "kubernetes.")

        funcs := make(map[string]resourceHandler)
        funcs[jobs] = pointsForJob
        funcs[cronJobs] = pointsForCronJob
        funcs[daemonSets] = pointsForDaemonSet
        funcs[deployments] = pointsForDeployment
        funcs[replicaSets] = pointsForReplicaSet
        funcs[replicationControllers] = pointsForReplicationController
        funcs[statefulSets] = pointsForStatefulSet
        funcs[horizontalPodAutoscalers] = pointsForHPA
        funcs[nodes] = pointsForNode
        funcs[nonRunningPods] = pointsForNonRunningPods

        return &amp;stateMetricsSource{
                lister:     lister,
                transforms: transforms,
                filters:    filter.FromConfig(transforms.Filters),
                funcs:      funcs,
                pps:        gometrics.GetOrRegisterCounter(ppsKey, gometrics.DefaultRegistry),
                eps:        gometrics.GetOrRegisterCounter(epsKey, gometrics.DefaultRegistry),
                fps:        gometrics.GetOrRegisterCounter(fpsKey, gometrics.DefaultRegistry),
        }, nil
}</span>

func getDefault(val, defaultVal string) string <span class="cov1" title="2">{
        if val == "" </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov1" title="2">return val</span>
}

func (src *stateMetricsSource) AutoDiscovered() bool <span class="cov0" title="0">{
        return false
}</span>

func (src *stateMetricsSource) Name() string <span class="cov5" title="20">{
        return "kstate_source"
}</span>

func (src *stateMetricsSource) Cleanup() {<span class="cov0" title="0">}</span>

func (src *stateMetricsSource) Scrape() (*metrics.Batch, error) <span class="cov4" title="10">{
        result := &amp;metrics.Batch{
                Timestamp: time.Now(),
        }

        var points []wf.Metric
        for resType := range src.funcs </span><span class="cov7" title="100">{
                for _, point := range src.pointsForResource(resType) </span><span class="cov10" title="660">{
                        points = wf.FilterAppend(src.filters, src.fps, points, point)
                }</span>
        }
        <span class="cov4" title="10">result.Metrics = points
        src.pps.Inc(int64(len(result.Metrics)))
        return result, nil</span>
}

func (src *stateMetricsSource) pointsForResource(resType string) []wf.Metric <span class="cov7" title="100">{
        items, err := src.lister.List(resType)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error listing %s: %v", resType, err)
                return nil
        }</span>

        <span class="cov7" title="100">if len(items) == 0 </span><span class="cov5" title="30">{
                return nil
        }</span>

        <span class="cov6" title="70">f, ok := src.funcs[resType]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov6" title="70">var points []wf.Metric
        for _, item := range items </span><span class="cov8" title="210">{
                points = append(points, f(item, src.transforms)...)
        }</span>
        <span class="cov6" title="70">return points</span>
}

type stateProvider struct {
        metrics.DefaultSourceProvider
        sources []metrics.Source
}

func (p *stateProvider) GetMetricsSources() []metrics.Source <span class="cov4" title="10">{
        if !leadership.Leading() </span><span class="cov0" title="0">{
                log.Infof("not scraping sources from: %s. current leader: %s", providerName, leadership.Leader())
                return nil
        }</span>
        <span class="cov4" title="10">return p.sources</span>
}

func (p *stateProvider) Name() string <span class="cov1" title="1">{
        return providerName
}</span>

const providerName = "kstate_metrics_provider"

func NewStateProvider(cfg configuration.KubernetesStateSourceConfig) (metrics.SourceProvider, error) <span class="cov1" title="1">{
        if !util.ScrapeCluster() </span><span class="cov0" title="0">{
                return &amp;stateProvider{}, nil
        }</span>

        <span class="cov1" title="1">if cfg.KubeClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("kubeclient not initialized")
        }</span>

        <span class="cov1" title="1">var sources []metrics.Source
        metricsSource, err := NewStateMetricsSource(newLister(cfg.KubeClient), cfg.Transforms)
        if err == nil </span><span class="cov1" title="1">{
                sources = append(sources, metricsSource)
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("error creating source: %v", err)
        }</span>

        <span class="cov1" title="1">return &amp;stateProvider{
                sources: sources,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        appsv1 "k8s.io/api/apps/v1"
)

func pointsForReplicaSet(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="40">{
        rs, ok := item.(*appsv1.ReplicaSet)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="40">tags := buildTags("replicaset", rs.Name, rs.Namespace, transforms.Tags)
        now := time.Now().Unix()
        desired := floatVal(rs.Spec.Replicas, 1.0)
        available := float64(rs.Status.AvailableReplicas)
        ready := float64(rs.Status.ReadyReplicas)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "replicaset.desired_replicas", desired, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "replicaset.available_replicas", available, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "replicaset.ready_replicas", ready, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        v1 "k8s.io/api/core/v1"
)

func pointsForReplicationController(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov0" title="0">{
        rs, ok := item.(*v1.ReplicationController)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov0" title="0">tags := buildTags("replicationcontroller", rs.Name, rs.Namespace, transforms.Tags)
        now := time.Now().Unix()
        desired := floatVal(rs.Spec.Replicas, 1.0)
        available := float64(rs.Status.AvailableReplicas)
        ready := float64(rs.Status.ReadyReplicas)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "replicationcontroller.desired_replicas", desired, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "replicationcontroller.available_replicas", available, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "replicationcontroller.ready_replicas", ready, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kstate

import (
        "reflect"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        appsv1 "k8s.io/api/apps/v1"
)

func pointsForStatefulSet(item interface{}, transforms configuration.Transforms) []wf.Metric <span class="cov10" title="10">{
        ss, ok := item.(*appsv1.StatefulSet)
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("invalid type: %s", reflect.TypeOf(item).String())
                return nil
        }</span>

        <span class="cov10" title="10">tags := buildTags("statefulset", ss.Name, ss.Namespace, transforms.Tags)
        now := time.Now().Unix()

        desired := floatVal(ss.Spec.Replicas, 1.0)
        ready := float64(ss.Status.ReadyReplicas)
        current := float64(ss.Status.CurrentReplicas)
        updated := float64(ss.Status.UpdatedReplicas)

        return []wf.Metric{
                metricPoint(transforms.Prefix, "statefulset.desired_replicas", desired, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "statefulset.current_replicas", current, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "statefulset.ready_replicas", ready, now, transforms.Source, tags),
                metricPoint(transforms.Prefix, "statefulset.updated_replicas", updated, now, transforms.Source, tags),
        }</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2020 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package sources

import (
        "fmt"
        "math/rand"
        "sort"
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/discovery"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/controlplane"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/cadvisor"

        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/kstate"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/prometheus"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/stats"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/systemd"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/telegraf"

        gometrics "github.com/rcrowley/go-metrics"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"
)

const (
        jitterMs = 4
)

var (
        providerCount  gometrics.Gauge
        scrapeErrors   gometrics.Counter
        scrapeWarnings gometrics.Counter
        scrapeTimeouts gometrics.Counter
        scrapesMissed  gometrics.Counter
        scrapeLatency  gometrics.Histogram
        singleton      *sourceManagerImpl
        once           sync.Once
)

func init() <span class="cov1" title="1">{
        providerCount = gometrics.GetOrRegisterGauge("source.manager.providers", gometrics.DefaultRegistry)
        scrapeErrors = gometrics.GetOrRegisterCounter("source.manager.scrape.errors", gometrics.DefaultRegistry)
        scrapeWarnings = gometrics.GetOrRegisterCounter("source.manager.scrape.warnings", gometrics.DefaultRegistry)
        scrapeTimeouts = gometrics.GetOrRegisterCounter("source.manager.scrape.timeouts", gometrics.DefaultRegistry)
        scrapesMissed = gometrics.GetOrRegisterCounter("source.manager.scrape.missed", gometrics.DefaultRegistry)
        scrapeLatency = reporting.NewHistogram()
        _ = gometrics.Register("source.manager.scrape.latency", scrapeLatency)
}</span>

// SourceManager ProviderHandler with metrics gathering support
type SourceManager interface {
        metrics.ProviderHandler
        discovery.PluginProvider

        StopProviders()
        GetPendingMetrics() []*metrics.Batch
        SetDefaultCollectionInterval(time.Duration)
        BuildProviders(config configuration.SourceConfig) error
}

type sourceManagerImpl struct {
        responseChannel           chan *metrics.Batch
        defaultCollectionInterval time.Duration

        metricsSourcesMtx      sync.Mutex
        metricsSourceProviders map[string]metrics.SourceProvider
        metricsSourceTimers    map[string]*IntervalTimer
        metricsSourceQuits     map[string]chan struct{}

        responseMtx sync.Mutex
        response    []*metrics.Batch
}

// Manager return the SourceManager
func Manager() SourceManager <span class="cov8" title="6">{
        once.Do(func() </span><span class="cov1" title="1">{
                singleton = &amp;sourceManagerImpl{
                        responseChannel:           make(chan *metrics.Batch),
                        metricsSourceProviders:    make(map[string]metrics.SourceProvider),
                        metricsSourceTimers:       make(map[string]*IntervalTimer),
                        metricsSourceQuits:        make(map[string]chan struct{}),
                        defaultCollectionInterval: time.Minute,
                }
                singleton.rotateResponse()
                go singleton.run()
        }</span>)
        <span class="cov8" title="6">return singleton</span>
}

func (sm *sourceManagerImpl) DiscoveryPluginConfigs() []discovery.PluginConfig <span class="cov4" title="2">{
        var pluginConfigs []discovery.PluginConfig
        for _, provider := range sm.metricsSourceProviders </span><span class="cov4" title="2">{
                if pluginProvider, ok := provider.(discovery.PluginProvider); ok </span><span class="cov4" title="2">{
                        pluginConfigs = append(pluginConfigs, pluginProvider.DiscoveryPluginConfigs()...)
                }</span>
        }
        <span class="cov4" title="2">return pluginConfigs</span>
}

// BuildProviders creates a new source manager with the configured MetricsSourceProviders
func (sm *sourceManagerImpl) BuildProviders(cfg configuration.SourceConfig) error <span class="cov1" title="1">{
        sources := buildProviders(cfg)
        for _, runtime := range sources </span><span class="cov9" title="7">{
                sm.AddProvider(runtime)
        }</span>
        <span class="cov1" title="1">if len(sm.metricsSourceProviders) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no available sources to use")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (sm *sourceManagerImpl) SetDefaultCollectionInterval(defaultCollectionInterval time.Duration) <span class="cov1" title="1">{
        sm.defaultCollectionInterval = defaultCollectionInterval
}</span>

// AddProvider register and start a new SourceProvider
func (sm *sourceManagerImpl) AddProvider(provider metrics.SourceProvider) <span class="cov7" title="4">{
        name := provider.Name()

        log.WithFields(log.Fields{
                "name":                name,
                "collection_interval": provider.CollectionInterval(),
                "timeout":             provider.Timeout(),
        }).Info("Adding provider")

        if _, found := sm.metricsSourceProviders[name]; found </span><span class="cov0" title="0">{
                log.WithField("name", name).Info("deleting existing provider")
                sm.DeleteProvider(name)
        }</span>

        <span class="cov7" title="4">sm.metricsSourcesMtx.Lock()
        defer sm.metricsSourcesMtx.Unlock()

        var interval time.Duration
        if provider.CollectionInterval() &gt; 0 </span><span class="cov7" title="4">{
                interval = provider.CollectionInterval()
        }</span> else<span class="cov4" title="2"> {
                interval = sm.defaultCollectionInterval

                log.WithFields(log.Fields{
                        "provider":            name,
                        "collection_interval": sm.defaultCollectionInterval,
                }).Info("Using default collection interval")
        }</span>
        <span class="cov7" title="4">intervalTimer := NewIntervalTimer(interval)

        quit := make(chan struct{})

        sm.metricsSourceProviders[name] = provider
        sm.metricsSourceTimers[name] = intervalTimer
        sm.metricsSourceQuits[name] = quit

        providerCount.Update(int64(len(sm.metricsSourceProviders)))

        go func() </span><span class="cov7" title="4">{
                for </span><span class="cov8" title="6">{
                        select </span>{
                        case &lt;-intervalTimer.C:<span class="cov7" title="5">
                                scrape(provider, sm.responseChannel)
                                scrapesMissed.Inc(intervalTimer.Reset())</span>
                        case &lt;-quit:<span class="cov5" title="3">
                                return</span>
                        }
                }
        }()
}

func (sm *sourceManagerImpl) DeleteProvider(name string) <span class="cov7" title="4">{
        provider, found := sm.metricsSourceProviders[name]
        if !found </span><span class="cov0" title="0">{
                log.Debugf("Metrics Source Provider '%s' not found", name)
                return
        }</span>

        <span class="cov7" title="4">sm.metricsSourcesMtx.Lock()
        defer sm.metricsSourcesMtx.Unlock()

        delete(sm.metricsSourceProviders, name)
        if ticker, ok := sm.metricsSourceTimers[name]; ok </span><span class="cov7" title="4">{
                ticker.Stop()
                delete(sm.metricsSourceTimers, name)
        }</span>
        <span class="cov7" title="4">if quit, ok := sm.metricsSourceQuits[name]; ok </span><span class="cov7" title="4">{
                close(quit)
                delete(sm.metricsSourceQuits, name)
        }</span>

        <span class="cov7" title="4">for _, source := range provider.GetMetricsSources() </span><span class="cov7" title="4">{
                source.Cleanup()
        }</span>

        <span class="cov7" title="4">log.WithField("name", name).Info("Deleted provider")</span>
}

func (sm *sourceManagerImpl) StopProviders() <span class="cov4" title="2">{
        for provider := range sm.metricsSourceProviders </span><span class="cov4" title="2">{
                sm.DeleteProvider(provider)
        }</span>
}

func (sm *sourceManagerImpl) run() <span class="cov1" title="1">{
        for </span><span class="cov8" title="6">{
                dataBatch := &lt;-sm.responseChannel
                if dataBatch != nil </span><span class="cov7" title="5">{
                        sm.responseMtx.Lock()
                        sm.response = append(sm.response, dataBatch)
                        sm.responseMtx.Unlock()
                }</span>
        }
}

func (sm *sourceManagerImpl) rotateResponse() []*metrics.Batch <span class="cov8" title="6">{
        sm.responseMtx.Lock()
        defer sm.responseMtx.Unlock()
        response := sm.response
        sm.response = make([]*metrics.Batch, 0)
        return response
}</span>

func scrape(provider metrics.SourceProvider, channel chan *metrics.Batch) <span class="cov7" title="5">{
        for _, source := range provider.GetMetricsSources() </span><span class="cov10" title="8">{
                // Prevents network congestion.
                jitter := time.Duration(rand.Intn(jitterMs)) * time.Millisecond
                time.Sleep(jitter)

                scrapeStart := time.Now()
                timeout := provider.Timeout()
                if timeout &lt;= 0 </span><span class="cov0" title="0">{
                        timeout = time.Minute
                }</span>

                <span class="cov10" title="8">log.WithField("name", source.Name()).Info("Querying source")

                dataBatch, err := source.Scrape()
                if err != nil </span><span class="cov4" title="2">{
                        if source.AutoDiscovered() </span><span class="cov1" title="1">{
                                log.Warningf("Could not scrape containers, skipping source '%s': %v", source.Name(), err)
                                scrapeWarnings.Inc(1)
                        }</span> else<span class="cov1" title="1"> {
                                log.Errorf("Error in scraping containers from '%s': %v", source.Name(), err)
                                scrapeErrors.Inc(1)
                        }</span>
                        <span class="cov4" title="2">return</span>
                }

                <span class="cov7" title="5">now := time.Now()
                latency := now.Sub(scrapeStart)
                scrapeLatency.Update(latency.Nanoseconds())

                // always send the collected data even if latency &gt; timeout
                channel &lt;- dataBatch

                if !now.Before(scrapeStart.Add(timeout)) </span><span class="cov0" title="0">{
                        scrapeTimeouts.Inc(1)
                        log.Warningf("'%s' high response latency: %s", source.Name(), latency)
                }</span>

                <span class="cov7" title="5">log.WithFields(log.Fields{
                        "name":          source.Name(),
                        "total_metrics": len(dataBatch.Metrics) + len(dataBatch.Sets),
                        "latency":       latency,
                }).Infof("Finished querying source")</span>
        }
}

func (sm *sourceManagerImpl) GetPendingMetrics() []*metrics.Batch <span class="cov7" title="5">{
        response := sm.rotateResponse()
        sort.Slice(response, func(i, j int) bool </span><span class="cov5" title="3">{ return response[i].Timestamp.Before(response[j].Timestamp) }</span>)
        <span class="cov7" title="5">return response</span>
}

func buildProviders(cfg configuration.SourceConfig) (result []metrics.SourceProvider) <span class="cov1" title="1">{
        if cfg.SummaryConfig != nil </span><span class="cov1" title="1">{
                provider, err := summary.NewSummaryProvider(*cfg.SummaryConfig)
                result = appendProvider(result, provider, err, cfg.SummaryConfig.Collection)

                if cfg.CadvisorConfig != nil </span><span class="cov1" title="1">{
                        provider, err = cadvisor.NewProvider(*cfg.CadvisorConfig, *cfg.SummaryConfig)
                        result = appendProvider(result, provider, err, cfg.CadvisorConfig.Collection)
                }</span>
                <span class="cov1" title="1">if cfg.ControlPlaneConfig != nil </span><span class="cov1" title="1">{
                        provider, err = controlplane.NewProvider(*cfg.ControlPlaneConfig, *cfg.SummaryConfig)
                        result = appendProvider(result, provider, err, cfg.ControlPlaneConfig.Collection)
                }</span>
        }
        <span class="cov1" title="1">if cfg.SystemdConfig != nil </span><span class="cov0" title="0">{
                provider, err := systemd.NewProvider(*cfg.SystemdConfig)
                result = appendProvider(result, provider, err, cfg.SystemdConfig.Collection)
        }</span>
        <span class="cov1" title="1">if cfg.StatsConfig != nil </span><span class="cov1" title="1">{
                provider, err := stats.NewInternalStatsProvider(*cfg.StatsConfig)
                result = appendProvider(result, provider, err, cfg.StatsConfig.Collection)
        }</span>
        <span class="cov1" title="1">if cfg.StateConfig != nil </span><span class="cov1" title="1">{
                provider, err := kstate.NewStateProvider(*cfg.StateConfig)
                result = appendProvider(result, provider, err, cfg.StateConfig.Collection)
        }</span>
        <span class="cov1" title="1">for _, srcCfg := range cfg.TelegrafConfigs </span><span class="cov4" title="2">{
                provider, err := telegraf.NewProvider(*srcCfg)
                result = appendProvider(result, provider, err, srcCfg.Collection)
        }</span>
        <span class="cov1" title="1">for _, srcCfg := range cfg.PrometheusConfigs </span><span class="cov0" title="0">{
                provider, err := prometheus.NewPrometheusProvider(*srcCfg)
                result = appendProvider(result, provider, err, srcCfg.Collection)
        }</span>

        <span class="cov1" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                log.Fatal("No available source to use")
        }</span>
        <span class="cov1" title="1">return result</span>
}

func appendProvider(
        slice []metrics.SourceProvider,
        provider metrics.SourceProvider,
        err error,
        cfg configuration.CollectionConfig,
) []metrics.SourceProvider <span class="cov9" title="7">{

        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create source: %v", err)
                return slice
        }</span>
        <span class="cov9" title="7">slice = append(slice, provider)
        if i, ok := provider.(metrics.ConfigurableSourceProvider); ok </span><span class="cov9" title="7">{
                i.Configure(cfg.Interval, cfg.Timeout)
        }</span>
        <span class="cov9" title="7">return slice</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

type factory struct{}

// Returns a new prometheus provider factory
func NewFactory() metrics.ProviderFactory <span class="cov8" title="5">{
        return factory{}
}</span>

func (p factory) Build(cfg interface{}) (metrics.SourceProvider, error) <span class="cov10" title="7">{
        c := cfg.(configuration.PrometheusSourceConfig)
        provider, err := NewPrometheusProvider(c)
        if err == nil </span><span class="cov10" title="7">{
                if i, ok := provider.(metrics.ConfigurableSourceProvider); ok </span><span class="cov10" title="7">{
                        i.Configure(c.Collection.Interval, c.Collection.Timeout)
                }</span>
        }
        <span class="cov10" title="7">return provider, err</span>
}

func (p factory) Name() string <span class="cov0" title="0">{
        return providerName
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "bufio"
        "io"
)

type LookaheadReader struct {
        scanner   *bufio.Scanner
        done      bool
        lineCount int
}

func NewLookaheadReader(reader io.Reader) *LookaheadReader <span class="cov3" title="27">{
        scanner := bufio.NewScanner(reader)
        scanner.Split(bufio.ScanLines)

        laReader := &amp;LookaheadReader{
                scanner: scanner,
        }

        laReader.advanceLine()
        return laReader
}</span>

func (laReader *LookaheadReader) Done() bool <span class="cov9" title="565712">{
        return laReader.done
}</span>

func (laReader *LookaheadReader) Read() []byte <span class="cov9" title="540005">{
        if laReader.done </span><span class="cov1" title="3">{
                return []byte{}
        }</span>
        // the scanner slice changes unexpectedly in some cases so a defensive copy
        // protects us from that
        <span class="cov9" title="540012">retVal := makeDefensiveCopy(laReader.scanner.Bytes())
        laReader.advanceLine()
        return retVal</span>
}

func makeDefensiveCopy(buf []byte) []byte <span class="cov9" title="540021">{
        retVal := make([]byte, len(buf))
        copy(retVal, buf)
        return retVal
}</span>

func (laReader *LookaheadReader) advanceLine() <span class="cov9" title="540119">{
        laReader.lineCount++
        laReader.done = !laReader.scanner.Scan()
}</span>

func (laReader *LookaheadReader) Peek() []byte <span class="cov10" title="582665">{
        return laReader.scanner.Bytes()
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "bytes"
        "io"
)

type MetricReader struct {
        lar *LookaheadReader
}

func NewMetricReader(reader io.Reader) *MetricReader <span class="cov3" title="24">{
        return &amp;MetricReader{
                lar: NewLookaheadReader(reader),
        }
}</span>

// Done tells us if there is anything left to read
func (mReader *MetricReader) Done() bool <span class="cov7" title="8718">{
        return mReader.lar.Done()
}</span>

func (mReader *MetricReader) Read() []byte <span class="cov7" title="8619">{
        buffer := bytes.NewBuffer(nil)

        mReader.readComments(buffer)
        mReader.readMetrics(buffer)

        return buffer.Bytes()
}</span>

func (mReader *MetricReader) readComments(buffer *bytes.Buffer) <span class="cov7" title="8619">{
        for !mReader.lar.Done() </span><span class="cov3" title="75">{
                if !mReader.commentNext() </span><span class="cov7" title="8617">{
                        break</span>
                }
                <span class="cov3" title="52">buffer.Write(mReader.lar.Read())
                buffer.Write([]byte("\n"))</span>
        }
}

func (mReader *MetricReader) commentNext() bool <span class="cov3" title="75">{
        trimmed := bytes.TrimSpace(mReader.lar.Peek())
        if 0 == bytes.Compare([]byte{}, trimmed) </span><span class="cov3" title="20">{
                return true
        }</span>
        <span class="cov3" title="55">return bytes.HasPrefix(mReader.lar.Peek(), []byte("#"))</span>
}

func (mReader *MetricReader) readMetrics(buffer *bytes.Buffer) <span class="cov7" title="8617">{
        for !mReader.lar.Done() </span><span class="cov10" title="531293">{
                if bytes.HasPrefix(mReader.lar.Peek(), []byte("#")) </span><span class="cov7" title="8517">{
                        break</span>
                }
                <span class="cov9" title="522933">buffer.Write(mReader.lar.Read())
                buffer.Write([]byte("\n"))</span>
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright 2021 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/experimental"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        prom "github.com/prometheus/client_model/go"

        gometrics "github.com/rcrowley/go-metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
)

type pointBuilder struct {
        filters          filter.Filter
        filtered         gometrics.Counter
        source           string
        prefix           string
        omitBucketSuffix bool
        tags             map[string]string
        interner         util.StringInterner
}

func NewPointBuilder(src *prometheusMetricsSource, filtered gometrics.Counter) *pointBuilder <span class="cov2" title="20">{
        return &amp;pointBuilder{
                source:           src.source,
                prefix:           src.prefix,
                omitBucketSuffix: src.omitBucketSuffix,
                tags:             src.tags,
                filters:          src.filters,
                filtered:         filtered,
                interner:         util.NewStringInterner(),
        }

}</span>

// build converts a map of prometheus metric families by metric name to a collection of wavefront points
// build actually never returns an error
func (builder *pointBuilder) build(metricFamilies map[string]*prom.MetricFamily) ([]wf.Metric, error) <span class="cov6" title="8618">{
        now := time.Now().Unix()
        var result []wf.Metric
        for metricName, mf := range metricFamilies </span><span class="cov6" title="8617">{
                for _, m := range mf.Metric </span><span class="cov7" title="88961">{
                        // Prometheus metric family -&gt; wavefront metric points
                        if mf.GetType() == prom.MetricType_SUMMARY </span><span class="cov4" title="250">{
                                result = append(result, builder.buildSummaryPoints(metricName, m, now, builder.buildTags(m))...)
                        }</span> else<span class="cov7" title="88711"> if mf.GetType() == prom.MetricType_HISTOGRAM </span><span class="cov1" title="4">{
                                if experimental.IsEnabled(experimental.HistogramConversion) </span><span class="cov1" title="2">{
                                        point := builder.buildWFHistogram(metricName, m, now, builder.buildTags(m))
                                        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
                                }</span>
                                <span class="cov1" title="4">result = append(result, builder.buildHistogramPoints(metricName, m, now, builder.buildTags(m))...)</span>
                        } else<span class="cov3" title="63"> {
                                result = append(result, builder.buildPoints(metricName, m, now)...)
                        }</span>
                }
        }
        <span class="cov6" title="8618">return result, nil</span>
}

func (builder *pointBuilder) point(name string, value float64, ts int64, source string, tags map[string]string) wf.Metric <span class="cov8" title="522939">{
        point := wf.NewPoint(
                builder.name(name),
                value,
                ts,
                source,
                nil,
        )

        point.SetLabelPairs(builder.deduplicate(tags)) //store tags as LabelPairs for memory optimization
        return point
}</span>

func (builder *pointBuilder) name(name string) string <span class="cov8" title="522944">{
        return builder.prefix + strings.Replace(name, "_", ".", -1)
}</span>

// Get name and value from metric
func (builder *pointBuilder) buildPoints(name string, m *prom.Metric, now int64) []wf.Metric <span class="cov3" title="63">{
        var result []wf.Metric
        if m.Gauge != nil </span><span class="cov7" title="25748">{
                if !math.IsNaN(m.GetGauge().GetValue()) </span><span class="cov7" title="25748">{
                        point := builder.point(name+".gauge", m.GetGauge().GetValue(), now, builder.source, builder.buildTags(m))
                        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
                }</span>
        } else<span class="cov3" title="63"> if m.Counter != nil </span><span class="cov1" title="4">{
                if !math.IsNaN(m.GetCounter().GetValue()) </span><span class="cov1" title="4">{
                        point := builder.point(name+".counter", m.GetCounter().GetValue(), now, builder.source, builder.buildTags(m))
                        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
                }</span>
        } else<span class="cov3" title="59"> if m.Untyped != nil </span><span class="cov3" title="59">{
                if !math.IsNaN(m.GetUntyped().GetValue()) </span><span class="cov3" title="59">{
                        point := builder.point(name+".value", m.GetUntyped().GetValue(), now, builder.source, builder.buildTags(m))
                        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
                }</span>
        }
        <span class="cov3" title="63">return result</span>
}

// Get Quantiles from summary metric
func (builder *pointBuilder) buildSummaryPoints(name string, m *prom.Metric, now int64, tags map[string]string) []wf.Metric <span class="cov4" title="250">{
        var result []wf.Metric
        for _, q := range m.GetSummary().Quantile </span><span class="cov5" title="890">{
                if !math.IsNaN(q.GetValue()) </span><span class="cov5" title="890">{
                        newTags := copyOf(tags)
                        newTags["quantile"] = fmt.Sprintf("%v", q.GetQuantile())
                        point := builder.point(name, q.GetValue(), now, builder.source, newTags)
                        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
                }</span>
        }
        <span class="cov4" title="250">point := builder.point(name+".count", float64(m.GetSummary().GetSampleCount()), now, builder.source, tags)
        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
        point = builder.point(name+".sum", m.GetSummary().GetSampleSum(), now, builder.source, tags)
        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)

        return result</span>
}

func (builder *pointBuilder) buildWFHistogram(name string, m *prom.Metric, now int64, tags map[string]string) wf.Metric <span class="cov1" title="2">{
        buckets := m.GetHistogram().Bucket
        centroids := make([]wf.Centroid, 0, len(buckets))
        for i, bucket := range buckets </span><span class="cov2" title="12">{
                centroids = append(centroids, wf.Centroid{
                        Value: bucket.GetUpperBound(),
                        Count: float64(buckets[i].GetCumulativeCount()),
                })
        }</span>
        <span class="cov1" title="2">return wf.NewCumulativeDistribution(builder.name(name), builder.source, tags, centroids, time.Unix(now, 0))</span>
}

// Get Buckets from histogram metric
func (builder *pointBuilder) buildHistogramPoints(name string, m *prom.Metric, now int64, tags map[string]string) []wf.Metric <span class="cov1" title="4">{
        var result []wf.Metric
        histName := builder.histogramName(name)
        for _, b := range m.GetHistogram().Bucket </span><span class="cov8" title="405900">{
                newTags := copyOf(tags)
                newTags["le"] = fmt.Sprintf("%v", b.GetUpperBound())
                point := builder.point(histName, float64(b.GetCumulativeCount()), now, builder.source, newTags)
                result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
        }</span>
        <span class="cov1" title="4">point := builder.point(name+".count", float64(m.GetHistogram().GetSampleCount()), now, builder.source, tags)
        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
        point = builder.point(name+".sum", m.GetHistogram().GetSampleSum(), now, builder.source, tags)
        result = wf.FilterAppend(builder.filters, builder.filtered, result, point)
        return result</span>
}

// Get labels from metric
func (builder *pointBuilder) buildTags(m *prom.Metric) map[string]string <span class="cov7" title="88961">{
        tags := make(map[string]string, len(builder.tags)+len(m.Label))
        for k, v := range builder.tags </span><span class="cov1" title="4">{
                if len(v) &gt; 0 </span><span class="cov1" title="4">{
                        tags[k] = v
                }</span>
        }
        <span class="cov7" title="88958">if len(m.Label) &gt;= 0 </span><span class="cov7" title="88960">{
                for _, label := range m.Label </span><span class="cov3" title="65">{
                        if len(label.GetName()) &gt; 0 &amp;&amp; len(label.GetValue()) &gt; 0 </span><span class="cov3" title="65">{
                                tags[label.GetName()] = label.GetValue()
                        }</span>
                }
        }
        <span class="cov7" title="88954">return tags</span>
}

func (builder *pointBuilder) histogramName(name string) string <span class="cov1" title="4">{
        if builder.omitBucketSuffix </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov1" title="4">return name + ".bucket"</span>
}

func (builder *pointBuilder) deduplicate(tags map[string]string) []wf.LabelPair <span class="cov8" title="523004">{
        result := make([]wf.LabelPair, 0)
        for k, v := range tags </span><span class="cov10" title="2862078">{
                result = append(result, wf.LabelPair{
                        Name:  builder.interner.Intern(k),
                        Value: builder.interner.Intern(v),
                })
        }</span>
        <span class="cov8" title="522947">return result</span>
}

func copyOf(tags map[string]string) map[string]string <span class="cov8" title="406794">{
        newTags := make(map[string]string, len(tags)+1)
        for k, v := range tags </span><span class="cov9" title="1980914">{
                newTags[k] = v
        }</span>
        <span class="cov8" title="406800">return newTags</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package prometheus

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/httputil"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        log "github.com/sirupsen/logrus"

        "github.com/prometheus/common/expfmt"
        gometrics "github.com/rcrowley/go-metrics"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"
)

var (
        collectErrors   gometrics.Counter
        filteredPoints  gometrics.Counter
        collectedPoints gometrics.Counter
)

func init() <span class="cov1" title="1">{
        pt := map[string]string{"type": "prometheus"}
        collectedPoints = gometrics.GetOrRegisterCounter(reporting.EncodeKey("source.points.collected", pt), gometrics.DefaultRegistry)
        filteredPoints = gometrics.GetOrRegisterCounter(reporting.EncodeKey("source.points.filtered", pt), gometrics.DefaultRegistry)
        collectErrors = gometrics.GetOrRegisterCounter(reporting.EncodeKey("source.collect.errors", pt), gometrics.DefaultRegistry)
}</span>

type prometheusMetricsSource struct {
        metricsURL           string
        prefix               string
        source               string
        tags                 map[string]string
        filters              filter.Filter
        client               *http.Client
        pps                  gometrics.Counter
        eps                  gometrics.Counter
        internalMetricsNames []string
        autoDiscovered       bool

        omitBucketSuffix bool
}

func NewPrometheusMetricsSource(metricsURL, prefix, source, discovered string, tags map[string]string, filters filter.Filter, httpCfg httputil.ClientConfig) (metrics.Source, error) <span class="cov2" title="6">{
        client, err := httpClient(metricsURL, httpCfg)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("error creating http client: %q", err)
                return nil, err
        }</span>

        <span class="cov2" title="6">pt := extractTags(tags, discovered, metricsURL)
        ppsKey := reporting.EncodeKey("target.points.collected", pt)
        epsKey := reporting.EncodeKey("target.collect.errors", pt)

        omitBucketSuffix, _ := strconv.ParseBool(os.Getenv("omitBucketSuffix"))

        return &amp;prometheusMetricsSource{
                metricsURL:           metricsURL,
                prefix:               prefix,
                source:               source,
                tags:                 tags,
                filters:              filters,
                client:               client,
                pps:                  gometrics.GetOrRegisterCounter(ppsKey, gometrics.DefaultRegistry),
                eps:                  gometrics.GetOrRegisterCounter(epsKey, gometrics.DefaultRegistry),
                internalMetricsNames: []string{ppsKey, epsKey},
                omitBucketSuffix:     omitBucketSuffix,
                autoDiscovered:       len(discovered) &gt; 0,
        }, nil</span>
}

func extractTags(tags map[string]string, discovered, metricsURL string) map[string]string <span class="cov2" title="6">{
        result := make(map[string]string)
        for k, v := range tags </span><span class="cov4" title="25">{
                if k == "pod" || k == "service" || k == "apiserver" || k == "namespace" || k == "node" </span><span class="cov3" title="14">{
                        result[k] = v
                }</span>
        }
        <span class="cov2" title="6">if discovered != "" </span><span class="cov2" title="7">{
                result["discovered"] = discovered
        }</span> else<span class="cov3" title="9"> {
                result["discovered"] = "static"
                result["url"] = metricsURL
        }</span>
        <span class="cov2" title="6">result["type"] = "prometheus"
        return result</span>
}

func httpClient(metricsURL string, cfg httputil.ClientConfig) (*http.Client, error) <span class="cov2" title="6">{
        if strings.Contains(metricsURL, "kubernetes.default.svc.cluster.local") </span><span class="cov0" title="0">{
                if cfg.TLSConfig.CAFile == "" </span><span class="cov0" title="0">{
                        log.Debugf("using default client for kubernetes api service")
                        cfg.TLSConfig.CAFile = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                        cfg.TLSConfig.InsecureSkipVerify = true
                }</span>
        }
        <span class="cov2" title="6">client, err := httputil.NewClient(cfg)
        if err == nil </span><span class="cov2" title="6">{
                client.Timeout = time.Second * 30
        }</span>
        <span class="cov2" title="6">return client, err</span>
}

func (src *prometheusMetricsSource) AutoDiscovered() bool <span class="cov2" title="4">{
        return src.autoDiscovered
}</span>

func (src *prometheusMetricsSource) Name() string <span class="cov6" title="200">{
        return fmt.Sprintf("prometheus_source: %s", src.metricsURL)
}</span>

func (src *prometheusMetricsSource) Cleanup() <span class="cov0" title="0">{
        for _, name := range src.internalMetricsNames </span><span class="cov0" title="0">{
                gometrics.Unregister(name)
        }</span>
}

type HTTPError struct {
        MetricsURL string
        Status     string
        StatusCode int
}

func (e *HTTPError) Error() string <span class="cov2" title="4">{
        return fmt.Sprintf("error retrieving prometheus metrics from %s (http status %s)", e.MetricsURL, e.Status)
}</span>

func (src *prometheusMetricsSource) Scrape() (*metrics.Batch, error) <span class="cov2" title="5">{
        result := &amp;metrics.Batch{
                Timestamp: time.Now(),
        }

        // TODO the likely reason this is not unit tested
        resp, err := src.client.Get(src.metricsURL)
        if err != nil </span><span class="cov1" title="1">{
                collectErrors.Inc(1)
                src.eps.Inc(1)
                return nil, err
        }</span>

        /* TODO UNTESTED */
        <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{
                io.Copy(ioutil.Discard, resp.Body)
                resp.Body.Close()
        }</span>()

        <span class="cov2" title="4">if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                collectErrors.Inc(1)
                src.eps.Inc(1)
                return nil, &amp;HTTPError{MetricsURL: src.metricsURL, Status: resp.Status, StatusCode: resp.StatusCode}
        }</span>

        // TODO I can create a wrapper test class on prometheusMetricsSource and override parseMetrics to make testing easier!
        <span class="cov2" title="3">result.Metrics, err = src.parseMetrics(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                collectErrors.Inc(1)
                src.eps.Inc(1)
                return result, err
        }</span>
        <span class="cov2" title="3">collectedPoints.Inc(int64(result.Points()))
        src.pps.Inc(int64(result.Points()))

        return result, nil</span>
}

// parseMetrics converts serialized prometheus metrics to wavefront points
// parseMetrics returns an error when IO or parsing fails
func (src *prometheusMetricsSource) parseMetrics(reader io.Reader) ([]wf.Metric, error) <span class="cov3" title="20">{
        metricReader := NewMetricReader(reader)
        pointBuilder := NewPointBuilder(src, filteredPoints)
        var points []wf.Metric
        var err error
        for !metricReader.Done() </span><span class="cov10" title="8618">{
                var parser expfmt.TextParser
                reader := bytes.NewReader(metricReader.Read())
                metricFamilies, err := parser.TextToMetricFamilies(reader)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("reading text format failed: %s", err)
                }</span>
                // TODO bug: err is overwritten here and above for every metric,
                // so whatever happens to be the last value of err is what is returned
                <span class="cov10" title="8618">pointsToAdd, err := pointBuilder.build(metricFamilies)
                points = append(points, pointsToAdd...)</span>
        }
        <span class="cov3" title="20">return points, err</span>
}

type prometheusProvider struct {
        metrics.DefaultSourceProvider
        name              string
        useLeaderElection bool
        sources           []metrics.Source
}

func (p *prometheusProvider) GetMetricsSources() []metrics.Source <span class="cov5" title="90">{
        if p.useLeaderElection &amp;&amp; !leadership.Leading() </span><span class="cov2" title="3">{
                log.Infof("not scraping sources from: %s. current leader: %s", p.name, leadership.Leader())
                return nil
        }</span>
        <span class="cov5" title="90">return p.sources</span>
}

func (p *prometheusProvider) Name() string <span class="cov2" title="7">{
        return p.name
}</span>

const providerName = "prometheus_metrics_provider"

func NewPrometheusProvider(cfg configuration.PrometheusSourceConfig) (metrics.SourceProvider, error) <span class="cov3" title="9">{
        if len(cfg.URL) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("missing prometheus url")
        }</span>

        <span class="cov3" title="9">source := configuration.GetStringValue(cfg.Source, util.GetNodeName())
        source = configuration.GetStringValue(source, "prom_source")

        name := ""
        if len(cfg.Name) &gt; 0 </span><span class="cov3" title="9">{
                name = fmt.Sprintf("%s: %s", providerName, cfg.Name)
        }</span>
        <span class="cov3" title="9">if name == "" </span><span class="cov3" title="12">{
                name = fmt.Sprintf("%s: %s", providerName, cfg.URL)
        }</span>

        <span class="cov3" title="9">discovered := configuration.GetStringValue(cfg.Discovered, "")
        log.Debugf("name: %s discovered: %s", name, discovered)

        httpCfg := cfg.HTTPClientConfig
        prefix := cfg.Prefix
        tags := cfg.Tags
        filters := filter.FromConfig(cfg.Filters) // TODO test all allow and denylist stuff?

        var sources []metrics.Source
        metricsSource, err := NewPrometheusMetricsSource(cfg.URL, prefix, source, discovered, tags, filters, httpCfg)
        if err == nil </span><span class="cov3" title="9">{
                sources = append(sources, metricsSource)
        }</span> else<span class="cov1" title="1"> {
                return nil, fmt.Errorf("error creating source: %v", err)
        }</span>

        <span class="cov3" title="9">return &amp;prometheusProvider{
                name:              name,
                useLeaderElection: cfg.UseLeaderElection || discovered == "",
                sources:           sources,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// Package stats provides internal metrics on the health of the Wavefront collector
package stats

import (
        "sync"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"

        gometrics "github.com/rcrowley/go-metrics"
)

var doOnce sync.Once

type statsProvider struct {
        metrics.DefaultSourceProvider
        sources []metrics.Source
}

func (h *statsProvider) GetMetricsSources() []metrics.Source <span class="cov10" title="10">{
        return h.sources
}</span>

func (h *statsProvider) Name() string <span class="cov1" title="1">{
        return "internal_stats_provider"
}</span>

func NewInternalStatsProvider(cfg configuration.StatsSourceConfig) (metrics.SourceProvider, error) <span class="cov1" title="1">{
        prefix := configuration.GetStringValue(cfg.Prefix, "kubernetes.")
        tags := cfg.Tags
        filters := filter.FromConfig(cfg.Filters)

        src, err := newInternalMetricsSource(prefix, tags, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">sources := make([]metrics.Source, 1)
        sources[0] = src

        doOnce.Do(func() </span><span class="cov1" title="1">{ // Temporal solution for https://github.com/rcrowley/go-metrics/issues/252
                gometrics.RegisterRuntimeMemStats(gometrics.DefaultRegistry)
        }</span>)

        <span class="cov1" title="1">return &amp;statsProvider{
                sources: sources,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package stats

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"

        gometrics "github.com/rcrowley/go-metrics"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
)

type internalMetricsSource struct {
        metrics.DefaultSourceProvider
        prefix  string
        tags    map[string]string
        filters filter.Filter

        source      string
        zeroFilters []string
        pps         gometrics.Counter
        fps         gometrics.Counter
}

func newInternalMetricsSource(prefix string, tags map[string]string, filters filter.Filter) (metrics.Source, error) <span class="cov1" title="2">{
        ppsKey := reporting.EncodeKey("source.points.collected", map[string]string{"type": "internal"})
        fpsKey := reporting.EncodeKey("source.points.filtered", map[string]string{"type": "internal"})

        zeroFilters := []string{
                "filtered.count",
                "errors.count",
                "targets.registered",
                "collect.errors",
                "points.filtered",
                "points.collected",
        }
        if len(tags) == 0 </span><span class="cov1" title="1">{
                tags = make(map[string]string, 1)
        }</span>
        <span class="cov1" title="2">return &amp;internalMetricsSource{
                prefix:  prefix,
                tags:    tags,
                filters: filters,

                zeroFilters: zeroFilters,
                source:      getDefault(util.GetNodeName(), "wavefront-collector-for-kubernetes"),
                pps:         gometrics.GetOrRegisterCounter(ppsKey, gometrics.DefaultRegistry),
                fps:         gometrics.GetOrRegisterCounter(fpsKey, gometrics.DefaultRegistry),
        }, nil</span>
}

func getDefault(val, defaultVal string) string <span class="cov1" title="2">{
        if val == "" </span><span class="cov1" title="2">{
                return defaultVal
        }</span>
        <span class="cov1" title="1">return val</span>
}

func (src *internalMetricsSource) AutoDiscovered() bool <span class="cov0" title="0">{
        return false
}</span>

func (src *internalMetricsSource) Name() string <span class="cov4" title="20">{
        return "internal_stats_source"
}</span>

func (src *internalMetricsSource) Cleanup() {<span class="cov0" title="0">}</span>

func (src *internalMetricsSource) Scrape() (*metrics.Batch, error) <span class="cov3" title="10">{
        return src.internalStats()
}</span>

func (src *internalMetricsSource) internalStats() (*metrics.Batch, error) <span class="cov3" title="10">{
        now := time.Now()
        result := &amp;metrics.Batch{
                Timestamp: now,
        }
        var points []wf.Metric

        src.tags["leading"] = strconv.FormatBool(leadership.Leading())
        src.tags["installation_method"] = util.GetInstallationMethod()
        util.AddK8sTags(src.tags)

        // update GC and memory stats before populating the map
        gometrics.CaptureRuntimeMemStatsOnce(gometrics.DefaultRegistry)

        gometrics.DefaultRegistry.Each(func(name string, i interface{}) </span><span class="cov8" title="1218">{
                switch metric := i.(type) </span>{
                case gometrics.Counter:<span class="cov8" title="848">
                        points = wf.FilterAppend(src.filters, src.fps, points, src.point(name, float64(metric.Count()), now.Unix()))</span>
                case gometrics.Gauge:<span class="cov7" title="320">
                        points = wf.FilterAppend(src.filters, src.fps, points, src.point(name, float64(metric.Value()), now.Unix()))</span>
                case gometrics.GaugeFloat64:<span class="cov4" title="20">
                        points = wf.FilterAppend(src.filters, src.fps, points, src.point(name, metric.Value(), now.Unix()))</span>
                case gometrics.Timer:<span class="cov3" title="10">
                        timer := metric.Snapshot()
                        points = append(points, src.addHisto(name, timer.Min(), timer.Max(), timer.Mean(),
                                timer.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999}), now.Unix())...)
                        points = append(points, src.addRate(name, timer.Count(), timer.Rate1(), timer.RateMean(), now.Unix())...)</span>
                case gometrics.Histogram:<span class="cov4" title="20">
                        histo := metric.Snapshot()
                        points = append(points, src.addHisto(name, histo.Min(), histo.Max(), histo.Mean(),
                                histo.Percentiles([]float64{0.5, 0.75, 0.95, 0.99, 0.999}), now.Unix())...)</span>
                case gometrics.Meter:<span class="cov0" title="0">
                        meter := metric.Snapshot()
                        points = append(points, src.addRate(name, meter.Count(), meter.Rate1(), meter.RateMean(), now.Unix())...)</span>
                }
        })
        <span class="cov3" title="10">src.pps.Inc(int64(len(points)))
        result.Metrics = points
        return result, nil</span>
}

func (src *internalMetricsSource) addHisto(name string, min, max int64, mean float64, percentiles []float64, now int64) []wf.Metric <span class="cov4" title="30">{
        // convert from nanoseconds to milliseconds
        var points []wf.Metric
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.min"), float64(min)/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.max"), float64(max)/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.mean"), mean/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.median"), percentiles[0]/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.p75"), percentiles[1]/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.p95"), percentiles[2]/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.p99"), percentiles[3]/1e6, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "duration.p999"), percentiles[4]/1e6, now))
        return points
}</span>

func (src *internalMetricsSource) addRate(name string, count int64, m1, mean float64, now int64) []wf.Metric <span class="cov3" title="10">{
        var points []wf.Metric
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "rate.count"), float64(count), now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "rate.m1"), m1, now))
        points = wf.FilterAppend(src.filters, src.fps, points, src.point(combine(name, "rate.mean"), mean, now))
        return points
}</span>

func combine(prefix, name string) string <span class="cov7" title="270">{
        return fmt.Sprintf("%s.%s", prefix, name)
}</span>

func (src *internalMetricsSource) point(name string, value float64, ts int64) wf.Metric <span class="cov8" title="1458">{
        name, tags := reporting.DecodeKey(name)
        if value == 0.0 &amp;&amp; src.filterName(name) </span><span class="cov7" title="458">{
                // don't emit internal counts with zero values
                return nil
        }</span>
        <span class="cov8" title="1000">return wf.NewPoint(
                src.prefix+"collector."+strings.Replace(name, "_", ".", -1),
                value,
                ts,
                src.source,
                src.buildTags(tags),
        )</span>
}

func (src *internalMetricsSource) buildTags(tags map[string]string) map[string]string <span class="cov2" title="3">{
        for k, v := range src.tags </span><span class="cov10" title="4000">{
                if len(v) &gt; 0 </span><span class="cov10" title="4000">{
                        if _, exists := tags[k]; !exists </span><span class="cov10" title="4000">{
                                tags[k] = v
                        }</span>
                }
        }
        <span class="cov2" title="3">return tags</span>
}

func (src *internalMetricsSource) filterName(name string) bool <span class="cov7" title="623">{
        for _, suffix := range src.zeroFilters </span><span class="cov9" title="2957">{
                if strings.HasSuffix(name, suffix) </span><span class="cov7" title="458">{
                        return true
                }</span>
        }
        <span class="cov6" title="165">return false</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package summary

import (
        "sort"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

const (
        sysSubContainerName = "system.slice/"
)

func sortedMetricSetKeys(m map[metrics.ResourceKey]*metrics.Set) []metrics.ResourceKey <span class="cov2" title="4">{
        keys := make([]metrics.ResourceKey, len(m))
        i := 0
        for k := range m </span><span class="cov4" title="24">{
                keys[i] = k
                i++
        }</span>
        <span class="cov2" title="4">sort.Sort(metrics.ResourceKeys(keys))
        return keys</span>
}

func sortedMetricValueKeys(m map[string]metrics.Value) []string <span class="cov4" title="24">{
        keys := make([]string, len(m))
        i := 0
        for k := range m </span><span class="cov10" title="3167">{
                keys[i] = k
                i++
        }</span>
        <span class="cov4" title="24">sort.Strings(keys)
        return keys</span>
}

func sortedLabelKeys(m map[string]string) []string <span class="cov4" title="24">{
        keys := make([]string, len(m))
        i := 0
        for k := range m </span><span class="cov7" title="240">{
                keys[i] = k
                i++
        }</span>
        <span class="cov4" title="24">sort.Strings(keys)
        return keys</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kubelet

import (
        "strconv"

        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"

        kube_config "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/kubernetes"
        kube_client "k8s.io/client-go/rest"
)

const (
        defaultKubeletPort  = 10255
        defaultKubeletHttps = false
)

func GetKubeConfigs(cfg configuration.SummarySourceConfig) (*kube_client.Config, *KubeletClientConfig, error) <span class="cov10" title="4">{

        kubeConfig, err := kube_config.GetKubeClientConfig(cfg)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="3">kubeletPort := defaultKubeletPort
        if len(cfg.KubeletPort) &gt;= 1 </span><span class="cov8" title="3">{
                kubeletPort, err = strconv.Atoi(cfg.KubeletPort)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="3">kubeletHttps := defaultKubeletHttps
        if len(cfg.KubeletHttps) &gt;= 1 </span><span class="cov8" title="3">{
                kubeletHttps, err = strconv.ParseBool(cfg.KubeletHttps)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="3">log.Infof("Using Kubernetes client with master %q and version %+v\n", kubeConfig.Host, kubeConfig.GroupVersion)
        log.Infof("Using kubelet port %d", kubeletPort)

        kubeletConfig := &amp;KubeletClientConfig{
                Port:            uint(kubeletPort),
                EnableHttps:     kubeletHttps,
                TLSClientConfig: kubeConfig.TLSClientConfig,
                BearerToken:     kubeConfig.BearerToken,
        }
        return kubeConfig, kubeletConfig, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/metrics/sources/kubelet/kubelet.go
// Diff against master for changes to the original code.

// Copyright 2014 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file implements a cadvisor datasource, that collects metrics from an instance
// of cadvisor running on a specific host.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kubelet

import (
        "fmt"
        "io/ioutil"
        "net"
        "net/http"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/kubernetes"

        cadvisor "github.com/google/cadvisor/info/v1"
        jsoniter "github.com/json-iterator/go"
        log "github.com/sirupsen/logrus"
        stats "k8s.io/kubelet/pkg/apis/stats/v1alpha1"
)

type KubeletClient struct {
        config *KubeletClientConfig
        client *http.Client
}

type ErrNotFound struct {
        endpoint string
}

func (err *ErrNotFound) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%q not found", err.endpoint)
}</span>

func sampleContainerStats(stats []*cadvisor.ContainerStats) []*cadvisor.ContainerStats <span class="cov0" title="0">{
        if len(stats) == 0 </span><span class="cov0" title="0">{
                return []*cadvisor.ContainerStats{}
        }</span>
        <span class="cov0" title="0">return []*cadvisor.ContainerStats{stats[len(stats)-1]}</span>
}

func (kc *KubeletClient) postRequestAndGetValue(client *http.Client, req *http.Request, value interface{}) error <span class="cov7" title="10">{
        response, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov7" title="10">defer func() </span><span class="cov7" title="10">{
                _ = response.Body.Close()
        }</span>()

        <span class="cov7" title="10">body, err := ioutil.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body - %v", err)
        }</span>
        <span class="cov7" title="10">if response.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return &amp;ErrNotFound{req.URL.String()}
        }</span> else<span class="cov7" title="10"> if response.StatusCode == http.StatusForbidden </span><span class="cov0" title="0">{
                kubernetes.Terminate("Missing ClusterRole resource nodes/stats or nodes/proxy, see https://docs.wavefront.com/kubernetes.html#kubernetes-manual-install")
        }</span> else<span class="cov7" title="10"> if response.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed - %q, response: %q", response.Status, string(body))
        }</span>

        <span class="cov7" title="10">kubeletAddr := "[unknown]"
        if req.URL != nil </span><span class="cov7" title="10">{
                kubeletAddr = req.URL.Host
        }</span>

        <span class="cov7" title="10">log.WithFields(log.Fields{
                "address":  kubeletAddr,
                "response": string(body),
        }).Trace("Raw response from kubelet")

        err = jsoniter.ConfigFastest.Unmarshal(body, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse output. Response: %q. Error: %v", string(body), err)
        }</span>
        <span class="cov7" title="10">return nil</span>
}

func (kc *KubeletClient) parseStat(containerInfo *cadvisor.ContainerInfo) *cadvisor.ContainerInfo <span class="cov0" title="0">{
        containerInfo.Stats = sampleContainerStats(containerInfo.Stats)
        if len(containerInfo.Aliases) &gt; 0 </span><span class="cov0" title="0">{
                containerInfo.Name = containerInfo.Aliases[0]
        }</span>
        <span class="cov0" title="0">return containerInfo</span>
}

func (kc *KubeletClient) GetSummary(ip net.IP) (*stats.Summary, error) <span class="cov7" title="10">{
        u := kc.config.BaseURL(ip, "/stats/summary/").String()

        req, err := http.NewRequest("GET", u, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="10">summary := &amp;stats.Summary{}
        client := kc.client
        if client == nil </span><span class="cov0" title="0">{
                client = http.DefaultClient
        }</span>
        <span class="cov7" title="10">err = kc.postRequestAndGetValue(client, req, summary)
        return summary, err</span>
}

func (kc *KubeletClient) GetPort() uint <span class="cov10" title="20">{
        return kc.config.Port
}</span>

func NewKubeletClient(kubeletConfig *KubeletClientConfig) (*KubeletClient, error) <span class="cov4" title="3">{
        transport, err := MakeTransport(kubeletConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">c := &amp;http.Client{
                Transport: transport,
                Timeout:   kubeletConfig.HTTPTimeout,
        }
        return &amp;KubeletClient{
                config: kubeletConfig,
                client: c,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright 2017 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package kubelet

import (
        "fmt"
        "net"
        "net/http"
        "net/url"
        "time"

        utilnet "k8s.io/apimachinery/pkg/util/net"
        restclient "k8s.io/client-go/rest"
        "k8s.io/client-go/transport"
)

type KubeletClientConfig struct {
        // Default port - used if no information about Kubelet port can be found in Node.NodeStatus.DaemonEndpoints.
        Port         uint
        ReadOnlyPort uint
        EnableHttps  bool

        // PreferredAddressTypes - used to select an address from Node.NodeStatus.Addresses
        PreferredAddressTypes []string

        // TLSClientConfig contains settings to enable transport layer security
        restclient.TLSClientConfig

        // Server requires Bearer authentication
        BearerToken string

        // HTTPTimeout is used by the client to timeout http requests to Kubelet.
        HTTPTimeout time.Duration

        // Dial is a custom dialer used for the client
        Dial utilnet.DialFunc
}

func (c *KubeletClientConfig) HTTPSEnabled() bool <span class="cov10" title="20">{
        if c == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov10" title="20">return c.EnableHttps</span>
}

func (c *KubeletClientConfig) Scheme() string <span class="cov10" title="20">{
        if c.HTTPSEnabled() </span><span class="cov10" title="20">{
                return "https"
        }</span>
        <span class="cov1" title="1">return "http"</span>
}

func (c *KubeletClientConfig) BaseURL(ip net.IP, path string) *url.URL <span class="cov10" title="20">{
        return &amp;url.URL{
                Scheme: c.Scheme(),
                Host:   fmt.Sprintf("%s:%d", ip, c.Port),
                Path:   path,
        }
}</span>

func MakeTransport(config *KubeletClientConfig) (http.RoundTripper, error) <span class="cov4" title="3">{
        tlsConfig, err := transport.TLSConfigFor(config.transportConfig())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="3">rt := http.DefaultTransport
        if config.Dial != nil || tlsConfig != nil </span><span class="cov1" title="1">{
                rt = utilnet.SetOldTransportDefaults(&amp;http.Transport{
                        DialContext:     config.Dial,
                        TLSClientConfig: tlsConfig,
                })
        }</span>

        <span class="cov4" title="3">return transport.HTTPWrappersForConfig(config.transportConfig(), rt)</span>
}

// transportConfig converts a client config to an appropriate transport config.
func (c *KubeletClientConfig) transportConfig() *transport.Config <span class="cov6" title="6">{
        cfg := &amp;transport.Config{
                TLS: transport.TLSConfig{
                        CAFile:   c.CAFile,
                        CAData:   c.CAData,
                        CertFile: c.CertFile,
                        CertData: c.CertData,
                        KeyFile:  c.KeyFile,
                        KeyData:  c.KeyData,
                },
        }
        if c.EnableHttps </span><span class="cov3" title="2">{
                cfg.BearerToken = c.BearerToken
        }</span>
        <span class="cov6" title="6">if c.EnableHttps &amp;&amp; !cfg.HasCA() </span><span class="cov3" title="2">{
                cfg.TLS.Insecure = true
        }</span>
        <span class="cov6" title="6">return cfg</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Based on https://github.com/kubernetes-retired/heapster/blob/master/metrics/sources/summary/summary.go
// Diff against master for changes to the original code.

// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package summary

import (
        "fmt"
        "net"
        "time"

        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/go-metrics-wavefront/reporting"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        . "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/plugins/sources/summary/kubelet"

        kube_api "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        kube_client "k8s.io/client-go/kubernetes"
        v1listers "k8s.io/client-go/listers/core/v1"
        "k8s.io/client-go/tools/cache"
        stats "k8s.io/kubelet/pkg/apis/stats/v1alpha1"
)

// Prefix used for the LabelResourceID for volume metrics.
const VolumeResourcePrefix = "Volume:"

var collectErrors gm.Counter

func init() <span class="cov1" title="1">{
        pt := map[string]string{"type": "kubernetes.summary_api"}
        collectErrors = gm.GetOrRegisterCounter(reporting.EncodeKey("source.collect.errors", pt), gm.DefaultRegistry)
}</span>

type NodeInfo struct {
        NodeName       string
        HostName       string
        HostID         string
        KubeletVersion string
        NodeRole       string
        IP             net.IP
}

// Kubelet-provided metrics for pod and system container.
type summaryMetricsSource struct {
        node          NodeInfo
        kubeletClient *kubelet.KubeletClient
}

func NewSummaryMetricsSource(node NodeInfo, client *kubelet.KubeletClient) Source <span class="cov3" title="10">{
        return &amp;summaryMetricsSource{
                node:          node,
                kubeletClient: client,
        }
}</span>

func (src *summaryMetricsSource) AutoDiscovered() bool <span class="cov0" title="0">{
        return false
}</span>

func (src *summaryMetricsSource) Name() string <span class="cov4" title="20">{
        return src.String()
}</span>

func (src *summaryMetricsSource) Cleanup() {<span class="cov0" title="0">}</span>

func (src *summaryMetricsSource) String() string <span class="cov4" title="20">{
        return fmt.Sprintf("kubelet_summary:%s:%d", src.node.IP, src.kubeletClient.GetPort())
}</span>

func (src *summaryMetricsSource) Scrape() (*Batch, error) <span class="cov3" title="10">{
        result := &amp;Batch{
                Timestamp: time.Now(),
                Sets:      map[metrics.ResourceKey]*Set{},
        }

        summary, err := func() (*stats.Summary, error) </span><span class="cov3" title="10">{
                return src.kubeletClient.GetSummary(src.node.IP)
        }</span>()

        <span class="cov3" title="10">if err != nil </span><span class="cov0" title="0">{
                collectErrors.Inc(1)
                return nil, err
        }</span>

        <span class="cov3" title="10">src.addSummaryMetricSets(result, summary)

        return result, nil</span>
}

const (
        RootFsKey           = "/"
        LogsKey             = "logs"
        NetworkInterfaceKey = "interface_name"
)

// For backwards compatibility, map summary system names into original names.
// TODO: Migrate to the new system names and remove this.
var systemNameMap = map[string]string{
        stats.SystemContainerRuntime: "docker-daemon",
        stats.SystemContainerMisc:    "system",
}

// decodeSummary translates the kubelet statsSummary API into the flattened Set API.
func (src *summaryMetricsSource) addSummaryMetricSets(dataBatch *Batch, summary *stats.Summary) <span class="cov1" title="2">{

        labels := map[string]string{
                LabelNodename.Key: src.node.NodeName,
                LabelHostname.Key: src.node.HostName,
                LabelHostID.Key:   src.node.HostID,
        }

        src.decodeNodeStats(dataBatch.Sets, labels, &amp;summary.Node)
        for _, pod := range summary.Pods </span><span class="cov2" title="6">{

                src.decodePodStats(dataBatch.Sets, labels, &amp;pod)
        }</span>
        <span class="cov1" title="2">log.Debugf("End summary decode")</span>
}

// Convenience method for labels deep copy.
func (src *summaryMetricsSource) cloneLabels(labels map[string]string) map[string]string <span class="cov7" title="350">{
        clone := make(map[string]string, len(labels))
        for k, v := range labels </span><span class="cov5" title="89">{
                clone[k] = v
        }</span>
        <span class="cov7" title="350">return clone</span>
}

func (src *summaryMetricsSource) decodeNodeStats(metrics map[ResourceKey]*Set, labels map[string]string, node *stats.NodeStats) <span class="cov1" title="2">{
        log.Tracef("Decoding node stats for node %s...", node.NodeName)
        nodeMetrics := &amp;Set{
                Labels:              src.cloneLabels(labels),
                Values:              map[string]Value{},
                LabeledValues:       []LabeledValue{},
                CollectionStartTime: node.StartTime.Time,
                ScrapeTime:          src.getScrapeTime(node.CPU, node.Memory, node.Network),
        }
        nodeMetrics.Labels[LabelMetricSetType.Key] = MetricSetTypeNode
        nodeMetrics.Labels[LabelNodeRole.Key] = src.node.NodeRole

        src.decodeUptime(nodeMetrics, node.StartTime.Time)
        src.decodeCPUStats(nodeMetrics, node.CPU)
        src.decodeMemoryStats(nodeMetrics, node.Memory)
        src.decodeNetworkStats(nodeMetrics, node.Network)
        src.decodeFsStats(nodeMetrics, RootFsKey, node.Fs)
        src.decodeEphemeralStorageStats(nodeMetrics, node.Fs)
        metrics[NodeKey(node.NodeName)] = nodeMetrics

        for _, container := range node.SystemContainers </span><span class="cov2" title="3">{
                key := NodeContainerKey(node.NodeName, src.getSystemContainerName(&amp;container))
                containerMetrics := src.decodeContainerStats(labels, &amp;container, true)
                containerMetrics.Labels[LabelMetricSetType.Key] = MetricSetTypeSystemContainer
                metrics[key] = containerMetrics
        }</span>
}

func (src *summaryMetricsSource) decodePodStats(metrics map[ResourceKey]*Set, nodeLabels map[string]string, pod *stats.PodStats) <span class="cov2" title="6">{
        log.Tracef("Decoding pod stats for pod %s/%s (%s)...", pod.PodRef.Namespace, pod.PodRef.Name, pod.PodRef.UID)
        podMetrics := &amp;Set{
                Labels:              src.cloneLabels(nodeLabels),
                Values:              map[string]Value{},
                LabeledValues:       []LabeledValue{},
                CollectionStartTime: pod.StartTime.Time,
                ScrapeTime:          src.getScrapeTime(nil, nil, pod.Network),
        }
        ref := pod.PodRef
        podMetrics.Labels[LabelMetricSetType.Key] = MetricSetTypePod
        podMetrics.Labels[LabelPodId.Key] = ref.UID
        podMetrics.Labels[LabelPodName.Key] = ref.Name
        podMetrics.Labels[LabelNamespaceName.Key] = ref.Namespace

        src.decodeUptime(podMetrics, pod.StartTime.Time)
        src.decodeNetworkStats(podMetrics, pod.Network)
        src.decodeCPUStats(podMetrics, pod.CPU)
        src.decodeMemoryStats(podMetrics, pod.Memory)
        src.decodeEphemeralStorageStats(podMetrics, pod.EphemeralStorage)
        for _, vol := range pod.VolumeStats </span><span class="cov2" title="3">{
                src.decodeFsStats(podMetrics, VolumeResourcePrefix+vol.Name, &amp;vol.FsStats)
        }</span>
        <span class="cov2" title="6">metrics[PodKey(ref.Namespace, ref.Name)] = podMetrics

        for _, container := range pod.Containers </span><span class="cov6" title="160">{
                key := PodContainerKey(ref.Namespace, ref.Name, container.Name)
                // This check ensures that we are not replacing metrics of running container with metrics of terminated one if
                // there are two exactly same containers reported by kubelet.
                if _, exist := metrics[key]; exist </span><span class="cov2" title="3">{
                        log.Infof("Metrics reported from two containers with the same key: %v. Create time of "+
                                "containers are %v and %v. Metrics from the older container are going to be dropped.", key,
                                container.StartTime.Time, metrics[key].CollectionStartTime)
                        if container.StartTime.Time.Before(metrics[key].CollectionStartTime) </span><span class="cov2" title="3">{
                                continue</span>
                        }
                }
                <span class="cov3" title="8">metrics[key] = src.decodeContainerStats(podMetrics.Labels, &amp;container, false)</span>
        }
}

func (src *summaryMetricsSource) decodeContainerStats(podLabels map[string]string, container *stats.ContainerStats, isSystemContainer bool) *Set <span class="cov6" title="180">{
        log.Tracef("Decoding container stats stats for container %s...", container.Name)
        containerMetrics := &amp;Set{
                Labels:              src.cloneLabels(podLabels),
                Values:              map[string]Value{},
                LabeledValues:       []LabeledValue{},
                CollectionStartTime: container.StartTime.Time,
                ScrapeTime:          src.getScrapeTime(container.CPU, container.Memory, nil),
        }
        containerMetrics.Labels[LabelMetricSetType.Key] = MetricSetTypePodContainer
        if isSystemContainer </span><span class="cov2" title="3">{
                containerMetrics.Labels[LabelContainerName.Key] = src.getSystemContainerName(container)
        }</span> else<span class="cov3" title="8"> {
                containerMetrics.Labels[LabelContainerName.Key] = container.Name
        }</span>

        <span class="cov6" title="180">src.decodeUptime(containerMetrics, container.StartTime.Time)
        src.decodeCPUStats(containerMetrics, container.CPU)
        src.decodeMemoryStats(containerMetrics, container.Memory)
        src.decodeAcceleratorStats(containerMetrics, container.Accelerators)
        src.decodeFsStats(containerMetrics, RootFsKey, container.Rootfs)
        src.decodeFsStats(containerMetrics, LogsKey, container.Logs)
        src.decodeEphemeralStorageStatsForContainer(containerMetrics, container.Rootfs, container.Logs)
        src.decodeUserDefinedMetrics(containerMetrics, container.UserDefinedMetrics)

        return containerMetrics</span>
}

func (src *summaryMetricsSource) decodeUptime(metrics *Set, startTime time.Time) <span class="cov7" title="350">{
        if startTime.IsZero() </span><span class="cov1" title="1">{
                log.Trace("missing start time!")
                return
        }</span>

        <span class="cov7" title="350">uptime := uint64(time.Since(startTime).Nanoseconds() / time.Millisecond.Nanoseconds())
        src.addIntMetric(metrics, &amp;MetricUptime, &amp;uptime)</span>
}

func (src *summaryMetricsSource) decodeCPUStats(metrics *Set, cpu *stats.CPUStats) <span class="cov7" title="350">{
        if cpu == nil </span><span class="cov2" title="6">{
                log.Trace("missing cpu usage metric!")
                return
        }</span>
        <span class="cov7" title="350">src.addIntMetric(metrics, &amp;MetricCpuUsage, cpu.UsageCoreNanoSeconds)

        if cpu.UsageNanoCores != nil </span><span class="cov7" title="350">{
                millicores := *cpu.UsageNanoCores / 1e6
                src.addIntMetric(metrics, &amp;MetricCpuUsageCores, &amp;millicores)
        }</span>
}

func (src *summaryMetricsSource) decodeEphemeralStorageStats(metrics *Set, storage *stats.FsStats) <span class="cov3" title="8">{
        if storage == nil </span><span class="cov2" title="6">{
                log.Trace("missing storage usage metric!")
                return
        }</span>
        <span class="cov1" title="2">src.addIntMetric(metrics, &amp;MetricEphemeralStorageUsage, storage.UsedBytes)</span>
}

func (src *summaryMetricsSource) decodeEphemeralStorageStatsForContainer(metrics *Set, rootfs *stats.FsStats, logs *stats.FsStats) <span class="cov6" title="180">{
        if rootfs == nil || logs == nil || rootfs.UsedBytes == nil || logs.UsedBytes == nil </span><span class="cov4" title="20">{
                log.Trace("missing storage usage metric!")
                return
        }</span>
        <span class="cov6" title="160">usage := *rootfs.UsedBytes + *logs.UsedBytes
        src.addIntMetric(metrics, &amp;MetricEphemeralStorageUsage, &amp;usage)</span>
}

func (src *summaryMetricsSource) decodeMemoryStats(metrics *Set, memory *stats.MemoryStats) <span class="cov7" title="350">{
        if memory == nil </span><span class="cov3" title="7">{
                log.Trace("missing memory metrics!")
                return
        }</span>

        <span class="cov7" title="350">src.addIntMetric(metrics, &amp;MetricMemoryUsage, memory.UsageBytes)
        src.addIntMetric(metrics, &amp;MetricMemoryWorkingSet, memory.WorkingSetBytes)
        src.addIntMetric(metrics, &amp;MetricMemoryRSS, memory.RSSBytes)
        src.addIntMetric(metrics, &amp;MetricMemoryPageFaults, memory.PageFaults)
        src.addIntMetric(metrics, &amp;MetricMemoryMajorPageFaults, memory.MajorPageFaults)</span>
}

func (src *summaryMetricsSource) decodeAcceleratorStats(metrics *Set, accelerators []stats.AcceleratorStats) <span class="cov6" title="180">{
        for _, accelerator := range accelerators </span><span class="cov1" title="1">{
                acceleratorLabels := map[string]string{
                        LabelAcceleratorMake.Key:  accelerator.Make,
                        LabelAcceleratorModel.Key: accelerator.Model,
                        LabelAcceleratorID.Key:    accelerator.ID,
                }
                src.addLabeledIntMetric(metrics, &amp;MetricAcceleratorMemoryTotal, acceleratorLabels, &amp;accelerator.MemoryTotal)
                src.addLabeledIntMetric(metrics, &amp;MetricAcceleratorMemoryUsed, acceleratorLabels, &amp;accelerator.MemoryUsed)
                src.addLabeledIntMetric(metrics, &amp;MetricAcceleratorDutyCycle, acceleratorLabels, &amp;accelerator.DutyCycle)
        }</span>
}

func (src *summaryMetricsSource) decodeNetworkStats(metrics *Set, network *stats.NetworkStats) <span class="cov3" title="8">{
        if network == nil </span><span class="cov1" title="2">{
                log.Trace("missing network metrics!")
                return
        }</span>

        <span class="cov2" title="6">for _, netInterface := range network.Interfaces </span><span class="cov7" title="510">{
                log.Tracef("Processing metrics for network interface %s", netInterface.Name)
                intfLabels := map[string]string{NetworkInterfaceKey: netInterface.Name}
                src.addLabeledIntMetric(metrics, &amp;MetricNetworkRx, intfLabels, netInterface.RxBytes)
                src.addLabeledIntMetric(metrics, &amp;MetricNetworkRxErrors, intfLabels, netInterface.RxErrors)
                src.addLabeledIntMetric(metrics, &amp;MetricNetworkTx, intfLabels, netInterface.TxBytes)
                src.addLabeledIntMetric(metrics, &amp;MetricNetworkTxErrors, intfLabels, netInterface.TxErrors)
        }</span>
        <span class="cov2" title="6">src.addIntMetric(metrics, &amp;MetricNetworkRx, network.RxBytes)
        src.addIntMetric(metrics, &amp;MetricNetworkRxErrors, network.RxErrors)
        src.addIntMetric(metrics, &amp;MetricNetworkTx, network.TxBytes)
        src.addIntMetric(metrics, &amp;MetricNetworkTxErrors, network.TxErrors)</span>
}

func (src *summaryMetricsSource) decodeFsStats(metrics *Set, fsKey string, fs *stats.FsStats) <span class="cov7" title="560">{
        if fs == nil </span><span class="cov4" title="40">{
                log.Trace("missing fs metrics!")
                return
        }</span>

        <span class="cov7" title="520">fsLabels := map[string]string{LabelResourceID.Key: fsKey}
        src.addLabeledIntMetric(metrics, &amp;MetricFilesystemUsage, fsLabels, fs.UsedBytes)
        src.addLabeledIntMetric(metrics, &amp;MetricFilesystemLimit, fsLabels, fs.CapacityBytes)
        src.addLabeledIntMetric(metrics, &amp;MetricFilesystemAvailable, fsLabels, fs.AvailableBytes)
        src.addLabeledIntMetric(metrics, &amp;MetricFilesystemInodes, fsLabels, fs.Inodes)
        src.addLabeledIntMetric(metrics, &amp;MetricFilesystemInodesFree, fsLabels, fs.InodesFree)</span>
}

func (src *summaryMetricsSource) decodeUserDefinedMetrics(metrics *Set, udm []stats.UserDefinedMetric) <span class="cov6" title="180">{
        for _, metric := range udm </span><span class="cov0" title="0">{
                metrics.Values[CustomMetricPrefix+metric.Name] = Value{
                        ValueType:  ValueFloat,
                        FloatValue: metric.Value,
                }
        }</span>
}

func (src *summaryMetricsSource) getScrapeTime(cpu *stats.CPUStats, memory *stats.MemoryStats, network *stats.NetworkStats) time.Time <span class="cov7" title="350">{
        // Assume CPU, memory and network scrape times are the same.
        switch </span>{
        case cpu != nil &amp;&amp; !cpu.Time.IsZero():<span class="cov6" title="190">
                return cpu.Time.Time</span>
        case memory != nil &amp;&amp; !memory.Time.IsZero():<span class="cov0" title="0">
                return memory.Time.Time</span>
        case network != nil &amp;&amp; !network.Time.IsZero():<span class="cov2" title="5">
                return network.Time.Time</span>
        default:<span class="cov1" title="2">
                return time.Time{}</span>
        }
}

// addIntMetric is a convenience method for adding the metric and value to the metric set.
func (src *summaryMetricsSource) addIntMetric(metrics *Set, metric *Metric, value *uint64) <span class="cov9" title="3810">{
        if value == nil </span><span class="cov0" title="0">{
                log.Debugf("skipping metric %s because the value was nil", metric.Name)
                return
        }</span>
        <span class="cov9" title="3810">val := Value{
                ValueType: ValueInt64,
                IntValue:  int64(*value),
        }
        metrics.Values[metric.Name] = val</span>
}

// addLabeledIntMetric is a convenience method for adding the labeled metric and value to the metric set.
func (src *summaryMetricsSource) addLabeledIntMetric(metrics *Set, metric *Metric, labels map[string]string, value *uint64) <span class="cov10" title="4640">{
        if value == nil </span><span class="cov5" title="46">{
                log.Debugf("skipping labeled metric %s (%v) because the value was nil", metric.Name, labels)
                return
        }</span>

        <span class="cov5" title="77">val := LabeledValue{
                Name:   metric.Name,
                Labels: labels,
                Value: Value{
                        ValueType: ValueInt64,
                        IntValue:  int64(*value),
                },
        }
        metrics.LabeledValues = append(metrics.LabeledValues, val)</span>
}

// Translate system container names to the legacy names for backwards compatibility.
func (src *summaryMetricsSource) getSystemContainerName(c *stats.ContainerStats) string <span class="cov2" title="6">{
        if legacyName, ok := systemNameMap[c.Name]; ok </span><span class="cov2" title="4">{
                return legacyName
        }</span>
        <span class="cov4" title="40">return c.Name</span>
}

type summaryProvider struct {
        metrics.DefaultSourceProvider
        nodeLister       v1listers.NodeLister
        reflector        *cache.Reflector
        kubeletClient    *kubelet.KubeletClient
        hostIDAnnotation string
}

func (sp *summaryProvider) GetMetricsSources() []Source <span class="cov3" title="10">{
        if !util.ScrapeAnyNodes() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov3" title="10">var sources []Source
        nodes, err := sp.nodeLister.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error while listing nodes: %v", err)
                return sources
        }</span>

        <span class="cov3" title="10">for _, node := range nodes </span><span class="cov3" title="10">{
                info, err := sp.getNodeInfo(node)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("%v", err)
                        continue</span>
                }
                <span class="cov3" title="10">sources = append(sources, NewSummaryMetricsSource(info, sp.kubeletClient))</span>
        }
        <span class="cov3" title="10">return sources</span>
}

func (sp *summaryProvider) Name() string <span class="cov1" title="1">{
        return "kubernetes_summary_provider"
}</span>

func (sp *summaryProvider) getNodeInfo(node *kube_api.Node) (NodeInfo, error) <span class="cov3" title="10">{
        hostname, ip, err := util.GetNodeHostnameAndIP(node)
        if err != nil </span><span class="cov0" title="0">{
                return NodeInfo{}, err
        }</span>
        <span class="cov3" title="10">hostID := ""
        if sp.hostIDAnnotation != "" </span><span class="cov0" title="0">{
                hostID = node.Annotations[sp.hostIDAnnotation]
        }</span>

        <span class="cov3" title="10">util.SetKubernetesVersion(node.Status.NodeInfo.KubeletVersion)
        util.SetKubernetesProvider(node.Spec.ProviderID)

        info := NodeInfo{
                NodeName:       node.Name,
                HostName:       hostname,
                HostID:         hostID,
                IP:             ip,
                KubeletVersion: node.Status.NodeInfo.KubeletVersion,
                NodeRole:       util.GetNodeRole(node),
        }

        log.WithFields(log.Fields{
                "name":      node.Name,
                "hostname":  hostname,
                "hostID":    hostID,
                "ipAddress": ip,
        }).Debug("Node information")

        return info, nil</span>
}

func NewSummaryProvider(cfg configuration.SummarySourceConfig) (SourceProvider, error) <span class="cov1" title="1">{
        hostIDAnnotation := ""

        // create clients
        kubeConfig, kubeletConfig, err := kubelet.GetKubeConfigs(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">kubeClient := kube_client.NewForConfigOrDie(kubeConfig)
        kubeletClient, err := kubelet.NewKubeletClient(kubeletConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // watch nodes
        <span class="cov1" title="1">nodeLister, reflector, _ := util.GetNodeLister(kubeClient)

        return &amp;summaryProvider{
                nodeLister:       nodeLister,
                reflector:        reflector,
                kubeletClient:    kubeletClient,
                hostIDAnnotation: hostIDAnnotation,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Copyright 2018-2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package summary

import (
        "strings"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/go-metrics-wavefront/reporting"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
)

// converts Sets to Metrics.
type pointConverter struct {
        cluster string
        prefix  string
        tags    map[string]string
        filters filter.Filter

        collectedPoints gm.Counter
        filteredPoints  gm.Counter
}

// NewPointConverter creates a new processor that converts summary stats data into the Wavefront point format
func NewPointConverter(cfg configuration.SummarySourceConfig, cluster string) (metrics.Processor, error) <span class="cov2" title="5">{
        cluster = strings.TrimSpace(cluster)
        if cluster == "" </span><span class="cov0" title="0">{
                cluster = "k8s-cluster"
        }</span>

        <span class="cov2" title="5">pt := map[string]string{"type": "kubernetes.summary_api"}
        return &amp;pointConverter{
                cluster:         cluster,
                prefix:          configuration.GetStringValue(cfg.Prefix, "kubernetes."),
                tags:            cfg.Tags,
                filters:         filter.FromConfig(cfg.Filters),
                collectedPoints: gm.GetOrRegisterCounter(reporting.EncodeKey("source.points.collected", pt), gm.DefaultRegistry),
                filteredPoints:  gm.GetOrRegisterCounter(reporting.EncodeKey("source.points.filtered", pt), gm.DefaultRegistry),
        }, nil</span>
}

func (converter *pointConverter) Name() string <span class="cov0" title="0">{
        return "wavefront_point_converter"
}</span>

func (converter *pointConverter) Process(batch *metrics.Batch) (*metrics.Batch, error) <span class="cov2" title="4">{
        if len(batch.Sets) == 0 </span><span class="cov0" title="0">{
                return batch, nil
        }</span>

        <span class="cov2" title="4">metricSets := batch.Sets
        nodeName := util.GetNodeName()
        ts := batch.Timestamp

        log.WithField("total", len(metricSets)).Debug("Processing metric sets")

        for _, key := range sortedMetricSetKeys(metricSets) </span><span class="cov3" title="24">{
                ms := metricSets[key]

                // Populate tag map
                tags := make(map[string]string)

                // Add pod labels as tags
                converter.addLabelTags(ms, tags)
                hostname := tags["hostname"]
                metricType := tags["type"]
                if strings.Contains(tags["container_name"], sysSubContainerName) </span><span class="cov0" title="0">{
                        //don't send system subcontainers
                        continue</span>
                }
                <span class="cov3" title="24">for _, metricName := range sortedMetricValueKeys(ms.Values) </span><span class="cov8" title="3167">{
                        metricValue := ms.Values[metricName]
                        var value float64
                        if metrics.ValueInt64 == metricValue.ValueType </span><span class="cov8" title="2711">{
                                value = float64(metricValue.IntValue)
                        }</span> else<span class="cov6" title="456"> if metrics.ValueFloat == metricValue.ValueType </span><span class="cov6" title="456">{
                                value = metricValue.FloatValue
                        }</span> else<span class="cov0" title="0"> {
                                continue</span>
                        }

                        <span class="cov8" title="3167">ts := ts.Unix()
                        source := nodeName
                        if source == "" </span><span class="cov3" title="24">{
                                if metricType == "cluster" </span><span class="cov0" title="0">{
                                        source = converter.cluster
                                }</span> else<span class="cov3" title="24"> if metricType == "ns" </span><span class="cov0" title="0">{
                                        source = tags["namespace_name"] + "-ns"
                                }</span> else<span class="cov3" title="24"> {
                                        source = hostname
                                }</span>
                        }

                        // convert to a point and add it to the data batch
                        <span class="cov8" title="3167">point := wf.NewPoint(converter.cleanMetricName(metricType, metricName), value, ts, source, tags)
                        batch.Metrics = wf.FilterAppend(converter.filters, converter.filteredPoints, batch.Metrics, point)
                        converter.collectedPoints.Inc(1)</span>
                }
                <span class="cov3" title="24">for _, metric := range ms.LabeledValues </span><span class="cov7" title="1984">{
                        var value float64
                        if metrics.ValueInt64 == metric.ValueType </span><span class="cov7" title="1984">{
                                value = float64(metric.IntValue)
                        }</span> else<span class="cov0" title="0"> if metrics.ValueFloat == metric.ValueType </span><span class="cov0" title="0">{
                                value = metric.FloatValue
                        }</span> else<span class="cov0" title="0"> {
                                continue</span>
                        }

                        <span class="cov7" title="1984">ts := ts.Unix()
                        source := nodeName
                        if source == "" </span><span class="cov0" title="0">{
                                source = hostname
                        }</span>
                        <span class="cov7" title="1984">labels := metric.Labels
                        if labels == nil </span><span class="cov0" title="0">{
                                labels = make(map[string]string, len(tags))
                        }</span>
                        <span class="cov7" title="1984">for k, v := range tags </span><span class="cov10" title="23140">{
                                labels[k] = v
                        }</span>

                        // convert to a point and add it to the data batch
                        <span class="cov7" title="1984">point := wf.NewPoint(converter.cleanMetricName(metricType, metric.Name), value, ts, source, labels)
                        batch.Metrics = wf.FilterAppend(converter.filters, converter.filteredPoints, batch.Metrics, point)
                        converter.collectedPoints.Inc(1)</span>
                }
        }
        <span class="cov2" title="4">return batch, nil</span>
}

func (converter *pointConverter) addLabelTags(ms *metrics.Set, tags map[string]string) <span class="cov3" title="24">{
        for _, labelName := range sortedLabelKeys(ms.Labels) </span><span class="cov5" title="240">{
                labelValue := ms.Labels[labelName]
                if labelName == "labels" </span><span class="cov5" title="132">{
                        for _, label := range strings.Split(labelValue, ",") </span><span class="cov6" title="396">{
                                //labels = app:webproxy,version:latest
                                tagParts := strings.SplitN(label, ":", 2)
                                if len(tagParts) == 2 </span><span class="cov6" title="396">{
                                        tags["label."+tagParts[0]] = tagParts[1]
                                }</span>
                        }
                } else<span class="cov5" title="240"> {
                        tags[labelName] = labelValue
                }</span>
        }
}

func (converter *pointConverter) cleanMetricName(metricType string, metricName string) string <span class="cov8" title="5151">{
        return converter.prefix + metricType + "." + strings.Replace(metricName, "/", ".", -1)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package systemd

import (
        "github.com/gobwas/glob"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
)

type unitFilter struct {
        unitAllowList glob.Glob
        unitDenyList  glob.Glob
}

func (uf *unitFilter) match(name string) bool <span class="cov10" title="5">{
        if uf.unitAllowList != nil &amp;&amp; !uf.unitAllowList.Match(name) </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="4">if uf.unitDenyList != nil &amp;&amp; uf.unitDenyList.Match(name) </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov7" title="3">return true</span>
}

func fromConfig(allowList, denyList []string) *unitFilter <span class="cov7" title="3">{
        if len(allowList) == 0 &amp;&amp; len(denyList) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov4" title="2">return &amp;unitFilter{
                unitAllowList: filter.Compile(allowList),
                unitDenyList:  filter.Compile(denyList),
        }</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Based on https://github.com/prometheus/node_exporter/blob/master/collector/systemd_linux.go.
// Diff against commit f028b816152f6d5650ca2cd707e45cda7333fdc1so for changes to the original code.

// Copyright 2015 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package systemd

import (
        "fmt"
        "math"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/wavefronthq/go-metrics-wavefront/reporting"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        . "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"

        "github.com/coreos/go-systemd/v22/dbus"
        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
)

var unitStatesName = []string{"active", "activating", "deactivating", "inactive", "failed"}

type systemdMetricsSource struct {
        prefix                  string
        source                  string
        collectTaskMetrics      bool
        collectStartTimeMetrics bool
        collectRestartMetrics   bool
        unitsFilter             *unitFilter
        filters                 filter.Filter

        pps gm.Counter
        fps gm.Counter
        eps gm.Counter
}

func (src *systemdMetricsSource) AutoDiscovered() bool <span class="cov0" title="0">{
        return false
}</span>

func (src *systemdMetricsSource) Name() string <span class="cov0" title="0">{
        return "systemd_metrics_source"
}</span>

func (src *systemdMetricsSource) Cleanup() {<span class="cov0" title="0">}</span>

func (src *systemdMetricsSource) Scrape() (*Batch, error) <span class="cov0" title="0">{
        // gathers metrics from systemd using dbus. collection is done in parallel to reduce wait time for responses.
        conn, err := dbus.New()
        if err != nil </span><span class="cov0" title="0">{
                src.eps.Inc(1)
                return nil, fmt.Errorf("couldn't get dbus connection: %s", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        allUnits, err := src.getAllUnits(conn)
        if err != nil </span><span class="cov0" title="0">{
                src.eps.Inc(1)
                return nil, fmt.Errorf("couldn't get units: %s", err)
        }</span>

        <span class="cov0" title="0">now := time.Now().Unix()
        result := &amp;Batch{
                Timestamp: time.Now(),
        }

        // channel for gathering collected metrics
        gather := make(chan wf.Metric, 1000)
        done := make(chan bool)
        var points []wf.Metric

        // goroutine for gathering collected metrics
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case point, more := &lt;-gather:<span class="cov0" title="0">
                                if !more </span><span class="cov0" title="0">{
                                        log.Infof("systemd metrics collection complete")
                                        done &lt;- true
                                        return
                                }</span>
                                <span class="cov0" title="0">points = wf.FilterAppend(src.filters, src.fps, points, point)</span>
                        }
                }
        }()

        <span class="cov0" title="0">summary := summarizeUnits(allUnits)
        src.collectSummaryMetrics(summary, gather, now)

        units := src.filterUnits(allUnits)

        var wg sync.WaitGroup

        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                src.collectUnitStatusMetrics(conn, units, gather, now)
        }</span>()

        <span class="cov0" title="0">if src.collectStartTimeMetrics </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        src.collectUnitStartTimeMetrics(conn, units, gather, now)
                }</span>()
        }

        <span class="cov0" title="0">if src.collectTaskMetrics </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        src.collectUnitTasksMetrics(conn, units, gather, now)
                }</span>()
        }

        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                src.collectTimers(conn, units, gather, now)
        }</span>()

        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                src.collectSockets(conn, units, gather, now)
        }</span>()

        <span class="cov0" title="0">err = src.collectSystemState(conn, gather, now)
        if err != nil </span><span class="cov0" title="0">{
                src.eps.Inc(1)
                log.Errorf("error collecting system stats: %v", err)
        }</span>

        // wait for collection to complete and then close the gathering channel
        <span class="cov0" title="0">wg.Wait()
        close(gather)

        // wait for gathering to process all the points
        &lt;-done

        result.Metrics = points
        count := len(result.Metrics)
        log.Infof("%s metrics: %d", "systemd", count)
        src.pps.Inc(int64(count))

        return result, err</span>
}

func (src *systemdMetricsSource) collectUnitStatusMetrics(conn *dbus.Conn, units []unit, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        for _, unit := range units </span><span class="cov0" title="0">{
                serviceType := ""
                if strings.HasSuffix(unit.Name, ".service") </span><span class="cov0" title="0">{
                        serviceTypeProperty, err := conn.GetUnitTypeProperty(unit.Name, "Service", "Type")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Infof("couldn't get unit '%s' Type: %s", unit.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                serviceType = serviceTypeProperty.Value.Value().(string)
                        }</span>
                } else<span class="cov0" title="0"> if strings.HasSuffix(unit.Name, ".mount") </span><span class="cov0" title="0">{
                        serviceTypeProperty, err := conn.GetUnitTypeProperty(unit.Name, "Mount", "Type")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("couldn't get unit '%s' Type: %s", unit.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                serviceType = serviceTypeProperty.Value.Value().(string)
                        }</span>
                }
                <span class="cov0" title="0">for _, stateName := range unitStatesName </span><span class="cov0" title="0">{
                        isActive := 0.0
                        if stateName == unit.ActiveState </span><span class="cov0" title="0">{
                                isActive = 1.0
                        }</span>
                        <span class="cov0" title="0">tags := map[string]string{}
                        setTags(tags, unit.Name, stateName, serviceType)
                        ch &lt;- src.metricPoint("unit_state", isActive, now, tags)</span>
                }
                <span class="cov0" title="0">if src.collectRestartMetrics &amp;&amp; strings.HasSuffix(unit.Name, ".service") </span><span class="cov0" title="0">{
                        // NRestarts wasn't added until systemd 235.
                        restartsCount, err := conn.GetUnitTypeProperty(unit.Name, "Service", "NRestarts")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("couldn't get unit '%s' NRestarts: %s", unit.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                tags := map[string]string{}
                                setTag(tags, "name", unit.Name)
                                ch &lt;- src.metricPoint("service_restart_total", float64(restartsCount.Value.Value().(uint32)), now, tags)
                        }</span>
                }
        }
}

func (src *systemdMetricsSource) collectSockets(conn *dbus.Conn, units []unit, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        for _, unit := range units </span><span class="cov0" title="0">{
                if !strings.HasSuffix(unit.Name, ".socket") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">acceptedConnectionCount, err := conn.GetUnitTypeProperty(unit.Name, "Socket", "NAccepted")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("couldn't get unit '%s' NAccepted: %s", unit.Name, err)
                        continue</span>
                }
                <span class="cov0" title="0">tags := map[string]string{}
                setTag(tags, "name", unit.Name)
                ch &lt;- src.metricPoint("socket_accepted_connections_total", float64(acceptedConnectionCount.Value.Value().(uint32)), now, tags)

                currentConnectionCount, err := conn.GetUnitTypeProperty(unit.Name, "Socket", "NConnections")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("couldn't get unit '%s' NConnections: %s", unit.Name, err)
                        continue</span>
                }
                <span class="cov0" title="0">ch &lt;- src.metricPoint("socket_current_connections", float64(currentConnectionCount.Value.Value().(uint32)), now, tags)

                // NRefused wasn't added until systemd 239.
                refusedConnectionCount, err := conn.GetUnitTypeProperty(unit.Name, "Socket", "NRefused")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("couldn't get unit '%s' NRefused: %s", unit.Name, err)
                }</span> else<span class="cov0" title="0"> {
                        ch &lt;- src.metricPoint("socket_refused_connections_total", float64(refusedConnectionCount.Value.Value().(uint32)), now, tags)
                }</span>
        }
}

func (src *systemdMetricsSource) collectUnitStartTimeMetrics(conn *dbus.Conn, units []unit, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        var startTimeUsec uint64
        for _, unit := range units </span><span class="cov0" title="0">{
                if unit.ActiveState != "active" </span><span class="cov0" title="0">{
                        startTimeUsec = 0
                }</span> else<span class="cov0" title="0"> {
                        timestampValue, err := conn.GetUnitProperty(unit.Name, "ActiveEnterTimestamp")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debugf("couldn't get unit '%s' StartTimeUsec: %s", unit.Name, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">startTimeUsec = timestampValue.Value.Value().(uint64)</span>
                }
                <span class="cov0" title="0">tags := map[string]string{}
                setTag(tags, "name", unit.Name)
                ch &lt;- src.metricPoint("unit_start_time_seconds", float64(startTimeUsec)/1e6, now, tags)</span>
        }
}

func (src *systemdMetricsSource) collectUnitTasksMetrics(conn *dbus.Conn, units []unit, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        var val uint64
        for _, unit := range units </span><span class="cov0" title="0">{
                if strings.HasSuffix(unit.Name, ".service") </span><span class="cov0" title="0">{
                        tasksCurrentCount, err := conn.GetUnitTypeProperty(unit.Name, "Service", "TasksCurrent")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Infof("couldn't get unit '%s' TasksCurrent: %s", unit.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                val = tasksCurrentCount.Value.Value().(uint64)
                                // Don't set if tasksCurrent if dbus reports MaxUint64.
                                if val != math.MaxUint64 </span><span class="cov0" title="0">{
                                        tags := map[string]string{}
                                        setTag(tags, "name", unit.Name)
                                        ch &lt;- src.metricPoint("unit_tasks_current", float64(val), now, tags)
                                }</span>
                        }
                        <span class="cov0" title="0">tasksMaxCount, err := conn.GetUnitTypeProperty(unit.Name, "Service", "TasksMax")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Infof("couldn't get unit '%s' TasksMax: %s", unit.Name, err)
                        }</span> else<span class="cov0" title="0"> {
                                val = tasksMaxCount.Value.Value().(uint64)
                                // Don't set if tasksMax if dbus reports MaxUint64.
                                if val != math.MaxUint64 </span><span class="cov0" title="0">{
                                        tags := map[string]string{}
                                        setTag(tags, "name", unit.Name)
                                        ch &lt;- src.metricPoint("unit_tasks_max", float64(val), now, tags)
                                }</span>
                        }
                }
        }
}

func (src *systemdMetricsSource) collectTimers(conn *dbus.Conn, units []unit, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        for _, unit := range units </span><span class="cov0" title="0">{
                if !strings.HasSuffix(unit.Name, ".timer") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">lastTriggerValue, err := conn.GetUnitTypeProperty(unit.Name, "Timer", "LastTriggerUSec")
                if err != nil </span><span class="cov0" title="0">{
                        log.Debugf("couldn't get unit '%s' LastTriggerUSec: %s", unit.Name, err)
                        continue</span>
                }
                <span class="cov0" title="0">tags := map[string]string{}
                setTag(tags, "name", unit.Name)
                ch &lt;- src.metricPoint("timer_last_trigger_seconds", float64(lastTriggerValue.Value.Value().(uint64))/1e6, now, tags)</span>
        }
}

func (src *systemdMetricsSource) collectSummaryMetrics(summary map[string]float64, ch chan&lt;- wf.Metric, now int64) <span class="cov0" title="0">{
        for stateName, count := range summary </span><span class="cov0" title="0">{
                tags := map[string]string{}
                setTag(tags, "state_name", stateName)
                ch &lt;- src.metricPoint("units", count, now, tags)
        }</span>
}

func (src *systemdMetricsSource) collectSystemState(conn *dbus.Conn, ch chan&lt;- wf.Metric, now int64) error <span class="cov0" title="0">{
        systemState, err := conn.GetManagerProperty("SystemState")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't get system state: %s", err)
        }</span>
        <span class="cov0" title="0">isSystemRunning := 0.0
        if systemState == `"running"` </span><span class="cov0" title="0">{
                isSystemRunning = 1.0
        }</span>
        <span class="cov0" title="0">ch &lt;- src.metricPoint("system_running", isSystemRunning, now, nil)
        return nil</span>
}

type unit struct {
        dbus.UnitStatus
}

func (src *systemdMetricsSource) getAllUnits(conn *dbus.Conn) ([]unit, error) <span class="cov0" title="0">{
        units, err := conn.ListUnits()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]unit, 0, len(units))
        for _, status := range units </span><span class="cov0" title="0">{
                unit := unit{
                        UnitStatus: status,
                }
                result = append(result, unit)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (src *systemdMetricsSource) filterUnits(units []unit) []unit <span class="cov0" title="0">{
        filtered := make([]unit, 0, len(units))
        for _, unit := range units </span><span class="cov0" title="0">{
                if (src.unitsFilter == nil || src.unitsFilter.match(unit.Name)) &amp;&amp; unit.LoadState == "loaded" </span><span class="cov0" title="0">{
                        log.Debugf("Adding unit: %s", unit.Name)
                        filtered = append(filtered, unit)
                }</span> else<span class="cov0" title="0"> {
                        log.Debugf("Ignoring unit: %s", unit.Name)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func summarizeUnits(units []unit) map[string]float64 <span class="cov0" title="0">{
        summarized := make(map[string]float64)
        for _, unitStateName := range unitStatesName </span><span class="cov0" title="0">{
                summarized[unitStateName] = 0.0
        }</span>
        <span class="cov0" title="0">for _, unit := range units </span><span class="cov0" title="0">{
                summarized[unit.ActiveState] += 1.0
        }</span>
        <span class="cov0" title="0">return summarized</span>
}

func setTags(tags map[string]string, name, state, service string) <span class="cov0" title="0">{
        setTag(tags, "name", name)
        setTag(tags, "state_name", state)
        setTag(tags, "type", service)
}</span>

func setTag(tags map[string]string, key, val string) <span class="cov0" title="0">{
        if val != "" </span><span class="cov0" title="0">{
                tags[key] = val
        }</span>
}

func (src *systemdMetricsSource) metricPoint(name string, value float64, ts int64, tags map[string]string) wf.Metric <span class="cov0" title="0">{
        return wf.NewPoint(
                src.prefix+strings.Replace(name, "_", ".", -1),
                value,
                ts,
                src.source,
                tags,
        )
}</span>

type systemdProvider struct {
        metrics.DefaultSourceProvider
        sources []Source
}

func (sp *systemdProvider) GetMetricsSources() []Source <span class="cov0" title="0">{
        return sp.sources
}</span>

func (sp *systemdProvider) Name() string <span class="cov0" title="0">{
        return "systemd_provider"
}</span>

func NewProvider(cfg configuration.SystemdSourceConfig) (SourceProvider, error) <span class="cov0" title="0">{
        prefix := configuration.GetStringValue(cfg.Prefix, "kubernetes.systemd.")
        source := configuration.GetStringValue(cfg.Source, util.GetNodeName())

        if source == "" </span><span class="cov0" title="0">{
                var err error
                source, err = os.Hostname()
                if err != nil </span><span class="cov0" title="0">{
                        source = "wavefront-collector-for-kubernetes"
                }</span>
        }
        <span class="cov0" title="0">collectTaskMetrics := cfg.IncludeTaskMetrics
        collectStartTimeMetrics := cfg.IncludeStartTimeMetrics
        collectRestartMetrics := cfg.IncludeRestartMetrics

        unitsFilter := fromConfig(cfg.UnitAllowList, cfg.UnitDenyList)
        filters := filter.FromConfig(cfg.Filters)

        pt := map[string]string{"type": "systemd"}
        ppsKey := reporting.EncodeKey("source.points.collected", pt)
        fpsKey := reporting.EncodeKey("source.points.filtered", pt)
        epsKey := reporting.EncodeKey("source.collect.errors", pt)

        sources := make([]Source, 1)
        sources[0] = &amp;systemdMetricsSource{
                prefix:                  prefix,
                source:                  source,
                collectTaskMetrics:      collectTaskMetrics,
                collectStartTimeMetrics: collectStartTimeMetrics,
                collectRestartMetrics:   collectRestartMetrics,
                unitsFilter:             unitsFilter,
                filters:                 filters,
                pps:                     gm.GetOrRegisterCounter(ppsKey, gm.DefaultRegistry),
                fps:                     gm.GetOrRegisterCounter(fpsKey, gm.DefaultRegistry),
                eps:                     gm.GetOrRegisterCounter(epsKey, gm.DefaultRegistry),
        }

        return &amp;systemdProvider{
                sources: sources,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/wf"

        "github.com/influxdata/telegraf"
        log "github.com/sirupsen/logrus"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

// Implements the telegraf Accumulator interface
type telegrafDataBatch struct {
        metrics.Batch
        source *telegrafPluginSource
}

func (t *telegrafDataBatch) preparePoints(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov7" title="2245">{
        var ts time.Time
        if len(timestamp) &gt; 0 </span><span class="cov4" title="93">{
                ts = timestamp[0]
        }</span> else<span class="cov7" title="2152"> {
                ts = time.Now()
        }</span>

        <span class="cov7" title="2245">for metric, v := range fields </span><span class="cov8" title="12690">{
                var value float64
                var err error
                switch p := v.(type) </span>{
                case string:<span class="cov3" title="20">
                        continue</span>
                case bool:<span class="cov0" title="0">
                        if p </span><span class="cov0" title="0">{
                                value = 1
                        }</span> else<span class="cov0" title="0"> {
                                value = 0
                        }</span>
                default:<span class="cov8" title="12670">
                        value, err = getFloat(v)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("unsupported type: %v plugin: %s metric: %v value: %v. error: %v", reflect.TypeOf(v), t.source.name, metric, v, err)
                                continue</span>
                        }
                }

                <span class="cov8" title="12670">metricName := measurement + "." + metric
                metricName = strings.Replace(metricName, "_", ".", -1)
                if len(t.source.prefix) &gt; 0 </span><span class="cov0" title="0">{
                        metricName = t.source.prefix + "." + metricName
                }</span>

                <span class="cov8" title="12670">t.Metrics = wf.FilterAppend(t.source.filters, t.source.pointsFiltered, t.Metrics, wf.NewPoint(
                        metricName,
                        value,
                        ts.UnixNano()/1000,
                        t.source.source,
                        t.buildTags(tags),
                ))</span>
        }
}

func (t *telegrafDataBatch) buildTags(pointTags map[string]string) map[string]string <span class="cov8" title="12670">{
        result := make(map[string]string)
        for k, v := range t.source.tags </span><span class="cov10" title="49830">{
                if len(v) &gt; 0 </span><span class="cov10" title="49830">{
                        result[k] = v
                }</span>
        }
        <span class="cov8" title="12670">for k, v := range pointTags </span><span class="cov9" title="20454">{
                if len(v) &gt; 0 </span><span class="cov9" title="20287">{
                        result[k] = v
                }</span>
        }
        <span class="cov8" title="12670">return result</span>
}

// AddFields adds a metric to the accumulator with the given measurement
// name, fields, and tags (and timestamp). If a timestamp is not provided,
// then the accumulator sets it to "now".
func (t *telegrafDataBatch) AddFields(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov7" title="1952">{
        t.preparePoints(measurement, fields, tags, timestamp...)
}</span>

// AddGauge is the same as AddFields, but will add the metric as a "Gauge" type
func (t *telegrafDataBatch) AddGauge(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov5" title="233">{
        t.preparePoints(measurement, fields, tags, timestamp...)
}</span>

// AddCounter is the same as AddFields, but will add the metric as a "Counter" type
func (t *telegrafDataBatch) AddCounter(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov4" title="60">{
        t.preparePoints(measurement, fields, tags, timestamp...)
}</span>

// AddSummary is the same as AddFields, but will add the metric as a "Summary" type
func (t *telegrafDataBatch) AddSummary(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov0" title="0">{
        log.Fatal("not supported")
}</span>

// AddHistogram is the same as AddFields, but will add the metric as a "Histogram" type
func (t *telegrafDataBatch) AddHistogram(measurement string, fields map[string]interface{}, tags map[string]string, timestamp ...time.Time) <span class="cov0" title="0">{
        log.Fatal("not supported")
}</span>

// AddMetric adds an metric to the accumulator.
func (t *telegrafDataBatch) AddMetric(telegraf.Metric) <span class="cov0" title="0">{
        log.Fatal("not supported")
}</span>

// SetPrecision sets the timestamp rounding precision.  All metrics addeds
// added to the accumulator will have their timestamp rounded to the
// nearest multiple of precision.
func (t *telegrafDataBatch) SetPrecision(precision time.Duration) <span class="cov0" title="0">{
        log.Fatal("not supported")
}</span>

// Report an error.
func (t *telegrafDataBatch) AddError(err error) <span class="cov3" title="23">{
        if err != nil </span><span class="cov0" title="0">{
                t.source.errors.Inc(1)
                if t.source.targetEPS != nil </span><span class="cov0" title="0">{
                        t.source.targetEPS.Inc(1)
                }</span>
                <span class="cov0" title="0">log.Error(err)</span>
        }
}

// Upgrade to a TrackingAccumulator with space for maxTracked metrics/batches.
func (t *telegrafDataBatch) WithTracking(maxTracked int) telegraf.TrackingAccumulator <span class="cov0" title="0">{
        log.Fatal("not supported")
        return nil
}</span>

var floatType = reflect.TypeOf(float64(0))

func getFloat(unk interface{}) (f float64, e error) <span class="cov8" title="12670">{
        v := reflect.ValueOf(unk)
        if unk == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("cannot convert nil value to float64")
        }</span>

        <span class="cov8" title="12670">v = reflect.Indirect(v)
        if !v.Type().ConvertibleTo(floatType) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("cannot convert %v to float64", v.Type())
        }</span>
        <span class="cov8" title="12670">fv := v.Convert(floatType)
        return fv.Float(), nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
)

type factory struct{}

// Returns a new telegraf provider factory
func NewFactory() metrics.ProviderFactory <span class="cov10" title="5">{
        return factory{}
}</span>

func (p factory) Build(cfg interface{}) (metrics.SourceProvider, error) <span class="cov4" title="2">{
        c := cfg.(configuration.TelegrafSourceConfig)
        provider, err := NewProvider(c)
        if err == nil </span><span class="cov4" title="2">{
                if i, ok := provider.(metrics.ConfigurableSourceProvider); ok </span><span class="cov4" title="2">{
                        i.Configure(c.Collection.Interval, c.Collection.Timeout)
                }</span>
        }
        <span class="cov4" title="2">return provider, err</span>
}

func (p factory) Name() string <span class="cov0" title="0">{
        return providerName
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "fmt"

        "github.com/influxdata/telegraf"
        "github.com/influxdata/toml"
)

func initPlugin(input telegraf.Input, conf string) (err error) <span class="cov10" title="3">{
        defer func() </span><span class="cov10" title="3">{
                // handle panic errors when parsing erroneous configurations
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("invalid telegraf configuration: %v", r)
                }</span>
        }()

        <span class="cov10" title="3">if len(conf) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing telegraf configuration")
        }</span>
        <span class="cov10" title="3">err = toml.Unmarshal([]byte(conf), input)
        return</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "fmt"
        "strings"
        "time"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/leadership"

        "github.com/influxdata/telegraf"
        telegrafPlugins "github.com/influxdata/telegraf/plugins/inputs"
        gm "github.com/rcrowley/go-metrics"
        log "github.com/sirupsen/logrus"
        "github.com/wavefronthq/go-metrics-wavefront/reporting"

        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/configuration"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/filter"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/metrics"
        "github.com/wavefronthq/wavefront-collector-for-kubernetes/internal/util"
)

type telegrafPluginSource struct {
        name           string
        source         string
        prefix         string
        tags           map[string]string
        plugin         telegraf.Input
        pluginPrefix   string
        filters        filter.Filter
        autoDiscovered bool

        pointsCollected gm.Counter
        pointsFiltered  gm.Counter
        errors          gm.Counter

        targetTags map[string]string
        targetPPS  gm.Counter
        targetEPS  gm.Counter
}

func newTelegrafPluginSource(name string, plugin telegraf.Input, prefix string, tags map[string]string, filters filter.Filter, discovered string) *telegrafPluginSource <span class="cov2" title="2">{
        pluginType := pluginType(name) + "." + name
        pt := map[string]string{"type": pluginType}
        collected := reporting.EncodeKey("source.points.collected", pt)
        filtered := reporting.EncodeKey("source.points.filtered", pt)
        errors := reporting.EncodeKey("source.collect.errors", pt)

        tsp := &amp;telegrafPluginSource{
                name:            name + "_plugin",
                plugin:          plugin,
                source:          util.GetNodeName(),
                prefix:          prefix,
                tags:            tags,
                filters:         filters,
                autoDiscovered:  len(discovered) &gt; 0,
                pointsCollected: gm.GetOrRegisterCounter(collected, gm.DefaultRegistry),
                pointsFiltered:  gm.GetOrRegisterCounter(filtered, gm.DefaultRegistry),
                errors:          gm.GetOrRegisterCounter(errors, gm.DefaultRegistry),
        }
        if discovered != "" </span><span class="cov2" title="2">{
                tsp.targetTags = extractTags(tags, pluginType, discovered)
                tsp.targetPPS = gm.GetOrRegisterCounter(reporting.EncodeKey("target.points.collected", tsp.targetTags), gm.DefaultRegistry)
                tsp.targetEPS = gm.GetOrRegisterCounter(reporting.EncodeKey("target.collect.errors", tsp.targetTags), gm.DefaultRegistry)
        }</span>
        <span class="cov2" title="2">return tsp</span>
}

func extractTags(tags map[string]string, name, discovered string) map[string]string <span class="cov2" title="2">{
        result := make(map[string]string)
        for k, v := range tags </span><span class="cov5" title="15">{
                if k == "pod" || k == "service" || k == "namespace" || k == "node" </span><span class="cov3" title="4">{
                        result[k] = v
                }</span>
        }
        <span class="cov2" title="2">if discovered != "" </span><span class="cov2" title="2">{
                result["discovered"] = discovered
        }</span> else<span class="cov0" title="0"> {
                result["discovered"] = "static"
        }</span>
        <span class="cov2" title="2">result["type"] = name
        return result</span>
}

func (t *telegrafPluginSource) Cleanup() <span class="cov0" title="0">{
        gm.Unregister(reporting.EncodeKey("target.collect.errors", t.targetTags))
        gm.Unregister(reporting.EncodeKey("target.collect.errors", t.targetTags))
}</span>

func (t *telegrafPluginSource) AutoDiscovered() bool <span class="cov2" title="2">{
        return t.autoDiscovered
}</span>

func (t *telegrafPluginSource) Name() string <span class="cov10" title="399">{
        return "telegraf_" + t.name + "_source"
}</span>

func (t *telegrafPluginSource) Scrape() (*metrics.Batch, error) <span class="cov8" title="133">{
        result := &amp;telegrafDataBatch{
                Batch:  metrics.Batch{Timestamp: time.Now()},
                source: t,
        }

        // Gather invokes callbacks on telegrafDataBatch
        err := t.plugin.Gather(result)
        if err != nil </span><span class="cov0" title="0">{
                t.errors.Inc(1)
                if t.targetEPS != nil </span><span class="cov0" title="0">{
                        t.targetEPS.Inc(1)
                }</span>
                <span class="cov0" title="0">log.Errorf("error gathering %s metrics. error: %v", t.name, err)</span>
        }
        <span class="cov8" title="133">count := len(result.Metrics)

        log.WithFields(log.Fields{
                "name":          t.Name(),
                "total_metrics": count,
        }).Debug("Scraping completed")

        t.pointsCollected.Inc(int64(count))
        if t.targetPPS != nil </span><span class="cov4" title="13">{
                t.targetPPS.Inc(int64(count))
        }</span>
        <span class="cov8" title="133">return &amp;result.Batch, nil</span>
}

// Telegraf provider
type telegrafProvider struct {
        metrics.DefaultSourceProvider
        name              string
        useLeaderElection bool
        sources           []metrics.Source
}

func (p telegrafProvider) GetMetricsSources() []metrics.Source <span class="cov6" title="33">{
        // only the leader will collect from a static source (not auto-discovered) that is not a host plugin
        if p.useLeaderElection &amp;&amp; !leadership.Leading() </span><span class="cov0" title="0">{
                log.Infof("not scraping sources from: %s. current leader: %s", p.name, leadership.Leader())
                return nil
        }</span>
        <span class="cov6" title="33">return p.sources</span>
}

func (p telegrafProvider) Name() string <span class="cov3" title="4">{
        return p.name
}</span>

const providerName = "telegraf_provider"

var hostPlugins = []string{"mem", "net", "netstat", "linux_sysctl_fs", "swap", "cpu", "disk", "diskio", "system", "kernel", "processes"}

// NewProvider creates a Telegraf source
func NewProvider(cfg configuration.TelegrafSourceConfig) (metrics.SourceProvider, error) <span class="cov3" title="4">{
        prefix := configuration.GetStringValue(cfg.Prefix, "")
        if len(prefix) &gt; 0 </span><span class="cov0" title="0">{
                prefix = strings.Trim(prefix, ".")
        }</span>

        <span class="cov3" title="4">plugins := cfg.Plugins
        if len(plugins) == 0 </span><span class="cov1" title="1">{
                plugins = hostPlugins
        }</span>

        <span class="cov3" title="4">filters := filter.FromConfig(cfg.Filters)
        tags := cfg.Tags
        discovered := cfg.Discovered
        hostPlugin := true

        var sources []metrics.Source
        for _, name := range plugins </span><span class="cov4" title="14">{
                if !util.ScrapeAnyNodes() &amp;&amp; pluginType(name) == "telegraf_host" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="14">creator := telegrafPlugins.Inputs[strings.Trim(name, " ")]
                if creator != nil </span><span class="cov4" title="14">{
                        plugin := creator()
                        if cfg.Conf != "" </span><span class="cov2" title="3">{
                                err := initPlugin(plugin, cfg.Conf)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error creating plugin: %s err: %s", name, err)
                                }</span>
                        }
                        <span class="cov4" title="14">sources = append(sources, newTelegrafPluginSource(name, plugin, prefix, tags, filters, discovered))
                        hostPlugin = hostPlugin &amp;&amp; (pluginType(name) == "telegraf_host")</span>
                } else<span class="cov0" title="0"> {
                        log.Errorf("telegraf plugin %s not found", name)
                        var availablePlugins []string
                        for name := range telegrafPlugins.Inputs </span><span class="cov0" title="0">{
                                availablePlugins = append(availablePlugins, name)
                        }</span>
                        <span class="cov0" title="0">log.Infof("available telegraf plugins: '%v'", availablePlugins)
                        return nil, fmt.Errorf("telegraf plugin not found: %s", name)</span>
                }
        }

        <span class="cov3" title="4">name := cfg.Name
        if len(name) &gt; 0 </span><span class="cov2" title="2">{
                name = fmt.Sprintf("%s: %s", providerName, name)
        }</span> else<span class="cov2" title="2"> {
                name = fmt.Sprintf("%s: %v", providerName, plugins)
        }</span>

        // use leader election if static source (not discovered) and is not a host plugin
        <span class="cov3" title="4">useLeaderElection := cfg.UseLeaderElection || (cfg.Discovered == "" &amp;&amp; !hostPlugin)

        return &amp;telegrafProvider{
                name:              name,
                useLeaderElection: useLeaderElection,
                sources:           sources,
        }, nil</span>
}

func pluginType(plugin string) string <span class="cov6" title="28">{
        for _, name := range hostPlugins </span><span class="cov5" title="22">{
                if plugin == name </span><span class="cov5" title="22">{
                        return "telegraf_host"
                }</span>
        }
        <span class="cov3" title="6">return "telegraf"</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Copyright 2019 VMware, Inc. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package telegraf

import (
        "bufio"
        "bytes"
        "fmt"
        "runtime"
        "strings"
        "time"

        "github.com/influxdata/telegraf"
        "github.com/influxdata/telegraf/plugins/inputs"
        "github.com/shirou/gopsutil/host"
        "github.com/shirou/gopsutil/load"
)

func init() <span class="cov1" title="1">{
        inputs.Add("system", func() telegraf.Input </span><span class="cov1" title="1">{
                return &amp;SystemStats{}
        }</span>)
}

type SystemStats struct{}

func (_ *SystemStats) Description() string <span class="cov0" title="0">{
        return "Read metrics about system load &amp; uptime"
}</span>

func (_ *SystemStats) SampleConfig() string <span class="cov0" title="0">{
        return `
  ## Uncomment to remove deprecated metrics.
  # fielddrop = ["uptime_format"]
`
}</span>

func (_ *SystemStats) Gather(acc telegraf.Accumulator) error <span class="cov10" title="10">{
        loadavg, err := load.Avg()
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not implemented") </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="10">fields := map[string]interface{}{
                "load1":  loadavg.Load1,
                "load5":  loadavg.Load5,
                "load15": loadavg.Load15,
                "n_cpus": runtime.NumCPU(),
        }

        now := time.Now()
        acc.AddGauge("system", fields, nil, now)

        uptime, err := host.Uptime()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="10">acc.AddCounter("system", map[string]interface{}{
                "uptime": uptime,
        }, nil, now)
        acc.AddFields("system", map[string]interface{}{
                "uptime_format": formatUptime(uptime),
        }, nil, now)

        return nil</span>
}

func formatUptime(uptime uint64) string <span class="cov10" title="10">{
        buf := new(bytes.Buffer)
        w := bufio.NewWriter(buf)

        days := uptime / (60 * 60 * 24)

        if days != 0 </span><span class="cov10" title="10">{
                s := ""
                if days &gt; 1 </span><span class="cov0" title="0">{
                        s = "s"
                }</span>
                <span class="cov10" title="10">fmt.Fprintf(w, "%d day%s, ", days, s)</span>
        }

        <span class="cov10" title="10">minutes := uptime / 60
        hours := minutes / 60
        hours %= 24
        minutes %= 60

        fmt.Fprintf(w, "%2d:%02d", hours, minutes)

        w.Flush()
        return buf.String()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
